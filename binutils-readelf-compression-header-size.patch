diff --git a/binutils/readelf.c b/binutils/readelf.c
index 6b5bebe743..6246b16428 100644
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -6714,15 +6714,18 @@ process_section_headers (Filedata * filedata)
 		{
 		  Elf_Internal_Chdr chdr;
 
-		  (void) get_compression_header (&chdr, buf, sizeof (buf));
-
-		  if (chdr.ch_type == ELFCOMPRESS_ZLIB)
-		    printf ("       ZLIB, ");
+		  if (get_compression_header (&chdr, buf, sizeof (buf)) == 0)
+		    printf (_("       [<corrupt>]\n"));
 		  else
-		    printf (_("       [<unknown>: 0x%x], "),
-			    chdr.ch_type);
-		  print_vma (chdr.ch_size, LONG_HEX);
-		  printf (", %lu\n", (unsigned long) chdr.ch_addralign);
+		    {
+		      if (chdr.ch_type == ELFCOMPRESS_ZLIB)
+			printf ("       ZLIB, ");
+		      else
+			printf (_("       [<unknown>: 0x%x], "),
+				chdr.ch_type);
+		      print_vma (chdr.ch_size, LONG_HEX);
+		      printf (", %lu\n", (unsigned long) chdr.ch_addralign);
+		    }
 		}
 	    }
 	}
@@ -13658,11 +13661,16 @@ dump_section_as_strings (Elf_Internal_Shdr * section, Filedata * filedata)
 	    = get_compression_header (& chdr, (unsigned char *) start,
 				      num_bytes);
 
+	  if (compression_header_size == 0)
+	    /* An error message will have already been generated
+	       by get_compression_header.  */
+	    goto error_out;
+
 	  if (chdr.ch_type != ELFCOMPRESS_ZLIB)
 	    {
 	      warn (_("section '%s' has unsupported compress type: %d\n"),
 		    printable_section_name (filedata, section), chdr.ch_type);
-	      return FALSE;
+	      goto error_out;
 	    }
 	  uncompressed_size = chdr.ch_size;
 	  start += compression_header_size;
@@ -13694,7 +13702,7 @@ dump_section_as_strings (Elf_Internal_Shdr * section, Filedata * filedata)
 	    {
 	      error (_("Unable to decompress section %s\n"),
 		     printable_section_name (filedata, section));
-	      return FALSE;
+	      goto error_out;
 	    }
 	}
       else
@@ -13764,6 +13772,10 @@ dump_section_as_strings (Elf_Internal_Shdr * section, Filedata * filedata)
 
   putchar ('\n');
   return TRUE;
+
+ error_out:
+  free (real_start);
+  return FALSE;
 }
 
 static bfd_boolean
@@ -13776,7 +13788,7 @@ dump_section_as_bytes (Elf_Internal_Shdr *  section,
   bfd_size_type       section_size;
   bfd_vma             addr;
   unsigned char *     data;
-  unsigned char *     real_start;
+  unsigned char *     real_start = NULL;
   unsigned char *     start;
 
   real_start = start = (unsigned char *) get_section_contents (section, filedata);
@@ -13799,11 +13811,16 @@ dump_section_as_bytes (Elf_Internal_Shdr *  section,
 	  unsigned int compression_header_size
 	    = get_compression_header (& chdr, start, section_size);
 
+	  if (compression_header_size == 0)
+	    /* An error message will have already been generated
+	       by get_compression_header.  */
+	    goto error_out;
+
 	  if (chdr.ch_type != ELFCOMPRESS_ZLIB)
 	    {
 	      warn (_("section '%s' has unsupported compress type: %d\n"),
 		    printable_section_name (filedata, section), chdr.ch_type);
-	      return FALSE;
+	      goto error_out;
 	    }
 	  uncompressed_size = chdr.ch_size;
 	  start += compression_header_size;
@@ -13838,7 +13855,7 @@ dump_section_as_bytes (Elf_Internal_Shdr *  section,
 	      error (_("Unable to decompress section %s\n"),
 		     printable_section_name (filedata, section));
 	      /* FIXME: Print the section anyway ?  */
-	      return FALSE;
+	      goto error_out;
 	    }
 	}
       else
@@ -13918,6 +13935,10 @@ dump_section_as_bytes (Elf_Internal_Shdr *  section,
 
   putchar ('\n');
   return TRUE;
+
+ error_out:
+  free (real_start);
+  return FALSE;
 }
 
 static ctf_sect_t *
@@ -14128,6 +14149,10 @@ load_specific_debug_section (enum dwarf_section_display_enum  debug,
 	    }
 
 	  compression_header_size = get_compression_header (&chdr, start, size);
+	  if (compression_header_size == 0)
+	    /* An error message will have already been generated
+	       by get_compression_header.  */
+	    return FALSE;
 
 	  if (chdr.ch_type != ELFCOMPRESS_ZLIB)
 	    {
