diff -rupN binutils.orig/binutils/NEWS binutils-2.37/binutils/NEWS
--- binutils.orig/binutils/NEWS	2021-11-09 12:34:21.664802928 +0000
+++ binutils-2.37/binutils/NEWS	2021-11-09 12:38:05.757327773 +0000
@@ -1,5 +1,14 @@
 -*- text -*-
 
+* Tools which display symbols or strings (readelf, strings, nm, objdump)
+  have a new command line option which controls how unicode characters are
+  handled.  By default they are treated as normal for the tool.  Using
+  --unicode=locale will display them according to the current locale.
+  Using --unicode=hex will display them as hex byte values, whilst
+  --unicode=escape will display them as escape sequences.  In addition
+  using --unicode=highlight will display them as unicode escape sequences
+  highlighted in red (if supported by the output device).
+
 Changes in 2.37:
 
 * The readelf tool has a new command line option which can be used to specify
diff -rupN binutils.orig/binutils/NEWS.orig binutils-2.37/binutils/NEWS.orig
--- binutils.orig/binutils/NEWS.orig	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.37/binutils/NEWS.orig	2021-11-09 12:34:46.290643870 +0000
@@ -0,0 +1,823 @@
+-*- text -*-
+
+Changes in 2.37:
+
+* The readelf tool has a new command line option which can be used to specify
+  how the numeric values of symbols are reported.  --sym-base=0|8|10|16 tells
+  readelf to display the values in base 8, base 10 or base 16.  A sym base of 0
+  represents the default action of displaying values under 10000 in base 10 and
+  values above that in base 16.
+
+* Binutils now requires a C99 compiler and library to build.
+
+* A new format has been added to the nm program.  Specifying
+  --format=just-symbols (or just using -j) will tell the program to only
+  display symbol names and nothing else.
+
+* A new command line --keep-section-symbols has been added to objcopy and
+  strip.  This stops the removal of unused section symbols when the file is
+  copied.  Removing these symbols saves space, but sometimes they are needed by
+  other tools.
+
+* objcopy --weaken, --weaken-symbol and --weaken-symbols now make undefined
+  symbols weak on targets that support weak symbols.
+
+* Readelf and objdump can now display and use the contents of .debug_sup
+  sections.
+
+* Readelf and objdump will now follow links to separate debug info files by
+  default.  This behaviour can be stopped via the use of the new -wN or
+  --debug-dump=no-follow-links options for readelf and the -WN or
+  --dwarf=no-follow-links options for objdump.  Also the old behaviour can be
+  restored by the use of the --enable-follow-debug-links=no configure time
+  option.
+
+  The semantics of the =follow-links option have also been slightly changed.
+  When enabled, the option allows for the loading of symbol tables and string
+  tables from the separate files which can be used to enhance the information
+  displayed when dumping other sections, but it does not automatically imply
+  that information from the separate files should be displayed.
+
+  If other debug section display options are also enabled (eg
+  --debug-dump=info) then the contents of matching sections in both the main
+  file and the separate debuginfo file *will* be displayed.  This is because in
+  most cases the debug section will only be present in one of the files.
+
+  If however non-debug section display options are enabled (eg --sections) then
+  the contents of matching parts of the separate debuginfo file will *not* be
+  displayed.  This is because in most cases the user probably only wanted to
+  load the symbol information from the separate debuginfo file.  In order to
+  change this behaviour a new command line option --process-links can be used.
+  This will allow di0pslay options to applied to both the main file and any
+  separate debuginfo files.
+
+* Nm has a new command line option: --quiet.  This suppresses "no symbols"
+  diagnostic.
+
+Changes in 2.36:
+
+* Update elfedit and readelf with LAM_U48 and LAM_U57 support.
+
+* Nm has a new command line option: --ifunc-chars=CHARS.  This specifies a
+  string of one or two characters.  The first character is used as the type
+  character when displaying global ifunc symbols.  The second character, if
+  present is used when displaying local ifunc symbols.
+
+  In addition a new configure time option --enable-f-for-ifunc-symbols has been
+  created, which if used will change nm's default characters for ifunc symbols
+  from i (both local and global) to F (global) and f (local).
+
+* The ar tool's previously unused l modifier is now used for specifying
+  dependencies of a static library. The arguments of this option
+  (or --record-libdeps long form option) will be stored verbatim in the
+  __.LIBDEP member of the archive, which the linker may read at link time.
+
+* Readelf can now display the contents of LTO symbol table sections when asked
+  to do so via the --lto-syms command line option.
+
+* Readelf now accepts the -C command line option to enable the demangling of
+  symbol names.  In addition the --demangle=<style>, --no-demangle,
+  --recurse-limit and --no-recurse-limit options are also now availale.
+
+* Add support for the SHF_GNU_RETAIN ELF section flag.
+  This flag specifies that the section should not be garbage collected by the
+  linker.
+
+Changes in 2.35:
+
+* Changed readelf's display of symbol names when wide mode is not enabled.
+  If the name is too long it will be truncated and the last five characters
+  replaced with "[...]".  The old behaviour of displaying 5 more characters but
+  not indicating that truncation has happened can be restored by the use of the
+  -T or --silent-truncation options.
+
+* X86 NaCl target support is removed.
+
+* The readelf tool now has a -L or --lint or --enable-checks option which turns
+  on warning messages about possible problems with the file(s) being examined.
+  These checks include things like zero-sized sections, which are allowed by
+  the ELF standard but which nevertheless might be of concern if the user
+  was expecting them to actually contain something.
+
+Changes in 2.34:
+
+* Binutils now supports debuginfod, an HTTP server for distributing
+  ELF/DWARF debugging information as well as source code. When built with
+  debuginfod, readelf and objdump can automatically query debuginfod
+  servers for separate debug files when they otherwise cannot be found.
+  To build binutils with debuginfod, pass --with-debuginfod to configure.
+  This requires libdebuginfod, the debuginfod client library. debuginfod
+  is distributed with elfutils, starting with version 0.178. For more
+  information see https://sourceware.org/elfutils.
+
+* Add --output option to the "ar" program.  This option can be used to specify
+  the output directory when extracting members from an archive.
+
+* Add --keep-section option to objcopy and strip.  This option keeps the
+  specified section from being removed.
+
+ * Add visualization of jumps inside a function by drawing an ascii character
+   graph between the address and the disassembler column.  Enabled via the
+   --visualize-jumps command line option for objdump.  Currently supported by
+   the x86, x86_64, and ARM targets.  The output looks something like this:
+
+  c6:	|  |     \----------> be 00 00 00 00       	mov    $0x0,%esi
+  cb:	|  |           /----> 48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # d2 <main+0xd2>
+  d2:	|  |           |      31 c0                	xor    %eax,%eax
+  d4:	|  |           |  /-- e8 00 00 00 00       	callq  d9 <main+0xd9>
+  d9:	|  |           |  \-> bf 02 00 00 00       	mov    $0x2,%edi
+  de:	|  +-----------|----- e8 00 00 00 00       	callq  e3 <main+0xe3>
+  e3:	|  \-----------|----> 48 89 da             	mov    %rbx,%rdx
+  e6:	|              |      be 00 00 00 00       	mov    $0x0,%esi
+  eb:	|              \----- eb de                	jmp    cb <main+0xcb>
+  ed:	\-------------------> 48 8b 16             	mov    (%rsi),%rdx
+
+  Additional arguments to the --visualize-jumps option add colors to the
+  output.
+
+Changes in 2.33:
+
+* Add --source-comment[=<txt>] option to objdump which if present,
+  provides a prefix to source code lines displayed in a disassembly.
+
+* Add --set-section-alignment <section-name>=<align> option to objcopy to allow
+  the changing of section alignments.
+
+* Add --verilog-data-width option to objcopy for verilog targets to control
+  width of data elements in verilog hex format.
+
+* Add support for the Armv8.1-M Mainline and M-profile Vector Extension (MVE)
+  instructions.
+
+* The separate debug info file options of readelf (--debug-dump=links
+  and --debug-dump=follow) and objdump (--dwarf=links and
+  --dwarf=follow-links) will now display and/or follow multiple links if
+  more than one are present in a file.  (This usually happens when gcc's
+  -gsplit-dwarf option is used).
+
+  In addition objdump's --dwarf=follow-links now also affects its other
+  display options, so that for example, when combined with --syms it will
+  cause the symbol tables in any linked debug info files to also be
+  displayed.  In addition when combined with --disassemble the --dwarf=
+  follow-links option will ensure that any symbol tables in the linked
+  files are read and used when disassembling code in the main file.
+
+ * Add support for dumping types encoded in the Compact Type Format
+   to objdump and readelf.
+
+Changes in 2.32:
+
+* The addr2line, c++filt, nm and objdump tools now have a limit on the
+  maximum amount of recursion that is allowed whilst demangling strings.
+  The value for this limit is defined by the DEMANGLE_RECRUSE_LIMIT
+  constant declared in the include/demangle.h header file.  At the time
+  of writing this constant has the value of 2048.
+
+  The --no-recurse-limit option can be used to remove the limit, restoring
+  the behaviour of earlier versions of these tools.  This may be needed in
+  order to dmangle truly complicated names, but it also leaves the tools
+  vulnerable to stack exhaustion from maliciously constructed mangled names.
+
+* Objdump's --disassemble option can now take a parameter, specifying the
+  starting symbol for disassembly.  Disassembly will continue from this
+  symbol up to the next symbol or the end of the function.
+
+* The MIPS port now supports the Loongson 2K1000 processor which implements
+  the MIPS64r2 ISA, the Loongson-mmi ASE, Loongson-cam ASE, Loongson-ext ASE,
+  Loongson-ext2 ASE and MSA ASE instructions. Add -march=gs264e option for
+  Loongson 2K1000 processor.
+
+* The MIPS port now supports the Loongson 3A2000/3A3000 processor which
+  implements the MIPS64r2 ISA, the Loongson-mmi ASE, Loongson-cam ASE,
+  Loongson-ext ASE and Loongson-ext2 ASE instructions. Add -march=gs464e
+  option for Loongson 3A2000/3A3000 processor.
+
+* The MIPS port now supports the Loongson 3A1000 processor, aka Loongson3a,
+  which implements the MIPS64r2 ISA, the Loongson-mmi ASE, Loongson-cam ASE
+  and Loongson-ext ASE instructions. Add -march=gs464 option for Loongson
+  3A1000 processor, The -march=loongson3a is an alias of -march=gs464 for
+  compatibility.
+
+* The size tool now has a new output format '--format=GNU' or '-G'.  The
+  results are displayed in a similar manor to the default berkeley layout,
+  except read-only data is counted in the data column, not the text column.
+  Additionally the total is only included once.
+
+Changes in 2.31:
+
+* Add support for disassembling netronome Flow Processor (NFP) firmware files.
+
+* The AArch64 port now supports showing disassembly notes which are emitted
+  when inconsistencies are found with the instruction that may result in the
+  instruction being invalid.  These can be turned on with the option -M notes
+  to objdump.
+
+* The AArch64 port now emits warnings when a combination of an instruction and
+  a named register could be invalid.
+
+* Added O modifier to ar to display member offsets inside an archive
+
+Changes in 2.30:
+
+* Add --debug-dump=links option to readelf and --dwarf=links option to objdump
+  which displays the contents of any .gnu_debuglink or .gnu_debugaltlink
+  sections.
+
+  Add a --debug-dump=follow-links option to readelf and a --dwarf=follow-links
+  option to objdump which causes indirect links into separate debug info files
+  to be followed when dumping other DWARF sections.
+
+Changes in 2.29:
+
+* The MIPS port now supports microMIPS eXtended Physical Addressing (XPA)
+  instructions for assembly and disassembly.
+
+* The MIPS port now supports the microMIPS Release 5 ISA for assembly and
+  disassembly.
+
+* The MIPS port now supports the Imagination interAptiv MR2 processor,
+  which implements the MIPS32r3 ISA, the MIPS16e2 ASE as well as a couple
+  of implementation-specific regular MIPS and MIPS16e2 ASE instructions.
+
+* The SPARC port now supports the SPARC M8 processor, which implements the
+  Oracle SPARC Architecture 2017.
+
+* The MIPS port now supports the MIPS16e2 ASE for assembly and disassembly.
+
+* Add support for ELF SHF_GNU_MBIND and PT_GNU_MBIND_XXX.
+
+* Add support for the wasm32 ELF conversion of the WebAssembly file format.
+
+* Add --inlines option to objdump, which extends the --line-numbers option
+  so that inlined functions will display their nesting information.
+
+* Add --merge-notes options to objcopy to reduce the size of notes in
+  a binary file by merging and deleting redundant notes.
+
+* Add support for locating separate debug info files using the build-id
+  method, where the separate file has a name based upon the build-id of
+  the original file.
+
+Changes in 2.28:
+
+* This version of binutils fixes a problem with PowerPC VLE 16A and 16D
+  relocations which were functionally swapped, for example,
+  R_PPC_VLE_HA16A performed like R_PPC_VLE_HA16D while R_PPC_VLE_HA16D
+  performed like R_PPC_VLE_HA16A.  This could have been fixed by
+  renumbering relocations, which would keep object files created by an
+  older version of gas compatible with a newer ld.  However, that would
+  require an ABI update, affecting other assemblers and linkers that
+  create and process the relocations correctly.  It is recommended that
+  all VLE object files be recompiled, but ld can modify the relocations
+  if --vle-reloc-fixup is passed to ld.  If the new ld command-line
+  option is not used, ld will ld warn on finding relocations inconsistent
+  with the instructions being relocated.
+
+* The nm program has a new command-line option (--with-version-strings)
+  which will display a symbol's version information, if any, after the
+  symbol's name.
+
+* The ARC port of objdump now accepts a -M option to specify the extra
+  instruction class(es) that should be disassembled.
+
+* The --remove-section option for objcopy and strip now accepts section
+  patterns starting with an exclamation point to indicate a non-matching
+  section.  A non-matching section is removed from the set of sections
+  matched by an earlier --remove-section pattern.
+
+* The --only-section option for objcopy now accepts section patterns
+  starting with an exclamation point to indicate a non-matching section.
+  A non-matching section is removed from the set of sections matched by
+  an earlier --only-section pattern.
+
+* New --remove-relocations=SECTIONPATTERN option for objcopy and strip.
+  This option can be used to remove sections containing relocations.
+  The SECTIONPATTERN is the section to which the relocations apply, not
+  the relocation section itself.
+
+Changes in 2.27:
+
+* Add a configure option, --enable-64-bit-archive, to force use of a
+  64-bit format when creating an archive symbol index.
+
+* Add --elf-stt-common= option to objcopy for ELF targets to control
+  whether to convert common symbols to the STT_COMMON type.
+
+Changes in 2.26:
+
+* Add option to objcopy to insert new symbols into a file:
+  --add-symbol <name>=[<section>:]<value>[,<flags>]
+
+* Add support for the ARC EM/HS, and ARC600/700 architectures.
+
+* Extend objcopy --compress-debug-sections option to support
+  --compress-debug-sections=[none|zlib|zlib-gnu|zlib-gabi] for ELF
+  targets.
+
+* Add --update-section option to objcopy.
+
+* Add --output-separator option to strings.
+
+Changes in 2.25:
+
+* Add --data option to strings to only print strings in loadable, initialized
+  data sections.  Change the default behaviour to be --all, but add a new
+  configure time option of --disable-default-strings-all to restore the old
+  default behaviour.
+
+* Add --include-all-whitespace to strings.
+
+* Add --dump-section option to objcopy.
+
+* Add support for the Andes NDS32.
+
+Changes in 2.24:
+
+* Objcopy now supports wildcard characters in command-line options that take
+  section names.
+
+* Add support for Altera Nios II.
+
+Changes in 2.23:
+
+* Add support for the VLE extension to the PowerPC architecture.
+
+* Add support for x64 Windows target of the delayed-load-library.
+
+* Add support for the Renesas RL78 architecture.
+
+Changes in 2.22:
+
+* Add support for displaying the contents of .debug.macro sections.
+
+* Add --preprocessor-arg option to windres to specify additional options
+  passed to preprocessor.
+
+* Add --dwarf-start and --dwarf-end to readelf and objdump.  These are used by
+  the new Emacs mode, see dwarf-mode.el.
+
+* Add support for the Tilera TILEPro and TILE-Gx architectures.
+
+changes in 2.21:
+
+* Add --interleave-width option to objcopy to allowing copying a range of
+  bytes from the input to the output with the --interleave option.
+
+* Add support for the TMS320C6000 (TI C6X) processor family.
+
+* Readelf can now display ARM unwind tables (.ARM.exidx / .ARM.extab) using
+  the -u / --unwind option.
+
+* Add --dyn-syms to readelf to dump dynamic symbol table.
+
+* A new tool - elfedit - has been added to directly manipulate ELF format
+  binaries.
+
+* Add to dlltool .def file feature of aliasing PE internal symbol name by
+  '== <ID>' option.
+
+* Add a new command-line option -a / --addresses to addr2line to display the
+  address before function name or source filename.
+
+* Add a new command-line option -p / --pretty-print to addr2line to have
+  a more human readable output.
+
+* The hppa/som targets can now be compiled on any host.
+
+Changes in 2.20:
+
+* Add support for delay importing to dlltool.  Use the --output-delaylib <file>
+  switch to create a delay-import library.  The resulting app will load the dll
+  as soon as the first function is called.  It will link to __delayLoadHelper2()
+  from the static delayimp library, which will import LoadLibraryA and
+  GetProcAddress from kernel32.
+
+* Add a new command-line option, --insn-width=WIDTH, to objdump to specify
+  number of bytes to be displayed on a single line when disassembling
+  instructions.
+
+* Readelf can now display the relocated contents of a section as a sequence
+  of bytes via the --relocated-dump=<name|number> command-line option.
+
+* The gprof program has been given a new command-line option:
+  --external-symbols-table=<filename> which reads in symbols from a specified
+  file.
+
+* The plugin target has been added to bfd. It can load the same shared objects
+  used by gold and uses them to provide basic support for new file formats.
+
+* The verilog memory hex dump file format is now supported as an output format
+  for objcopy.
+
+* Add --file-alignment, --heap, --image-base, --section-alignment,
+  --stack and --subsystem command-line options to objcopy, which will
+  set PE optional header.
+
+* Option --dwarf/-W of objdump is now as flexible as readelf --debug-dump/-w.
+
+* --as-needed now links in a dynamic library if it satisfies undefined
+  symbols in regular objects, or in other dynamic libraries.  In the
+  latter case the library is not linked if it is found in a DT_NEEDED
+  entry of one of the libraries already linked.
+
+* Added --prefix=PREFIX and --prefix-strip=LEVEL switches to objdump to
+  add absolute paths for -S.
+
+* Add new option --use-nul-prefixed-import-tables to dlltool to allow fall-
+  back to old import table generation with null element prefix.
+
+* Added --identify-strict switch to cause --identify <implib> to
+  report an error when the import library is associated with
+  multiple DLLs.
+
+* Added --identify <implib> option to dlltool, which determines the
+  name of the DLL associated with the specified <implib>.
+
+* Support for PowerPC booke64 instructions has been removed.  The assembler no
+  longer accepts -mbooke32 or -mbooke64 and the disassembler no longer accepts
+  -Mbooke32 or -Mbooke64.  Instead, -mbooke and -Mbooke should be used.
+
+Changes in 2.19:
+
+* Added -wL switch to dump decoded contents of .debug_line.
+
+* Added support for "thin" archives which contain pathnames pointing to
+  object files rather than the files themselves and which contain a
+  flattened symbol index for all objects, and archives, which have been
+  added to the archive.
+
+* Added -F switch to objdump to include file offsets in the disassembly.
+
+* Added -c switch to readelf to allow string dumps of archive symbol index.
+
+* Support for SSE5 has been added to the i386 port.
+
+* Added -p switch to readelf to allow string dumps of sections.
+
+Changes in 2.18:
+
+* Resolved 37 coding problems in bfd including static array overruns, null
+  pointer dereferences and use of a malloc buffer after it has been freed, as
+  revealed by static analysis donated by Coverity, Inc. (http://scan.coverity.com).
+
+* The binutils sources are now released under version 3 of the GNU General
+  Public License.
+
+* A new tool "windmc" has been added for some targets.  This is a message
+  compiler which attempts to be compatible with the MS version.
+
+* Add codepage support to the windres tool.  It now supports many new
+  resource types (e.g. MANIFEST, TOOLBAR, etc).  The output generation
+  for binary files is done now via bfd itself.  The endianess problems
+  for different hosts are solved.  Dumps of .res files can now be
+  re-compiled by windres without lossing resources or compilation errors.
+  Some problems on dialog resource translations are corrected.
+
+* Add --extract-symbol command-line option to objcopy, which will
+  strip everything out of an ordinary object file or executable except
+  for its symbol table.  Files containing just symbols can be useful
+  to some OSes.
+
+Changes in 2.17:
+
+* Add "-x NAME" to readelf in addition to "-x NUMBER".
+
+* Add -i and -t switches to cxxfilt.  -i disables the display of implementation
+  specific extra demangling information (if any) and -t disables the demangling
+  of types.
+
+* Add support for the "@<file>" syntax to the command lines of all tools, so
+  that extra switches can be read from <file>.
+
+* Add "-W/--dwarf" to objdump to display the contents of the DWARF
+  debug sections.
+
+* Add "-t/--section-details" to readelf to display section details.
+  "-N/--full-section-name" is deprecated.
+
+* powerpc-linux ld now supports a variant form of PLT and GOT for the security
+  conscious.  This form will automatically be chosen when ld detects that all
+  code in regular object files was generated by gcc -msecure-plt.  The old PLT
+  and GOT may be forced by a new ld option, --bss-plt.
+
+* Add "-i/--inlines" to addr2line to print enclosing scope information
+  for inlined function chains, back to first non-inlined function.
+
+* Add "-N/--full-section-name" to readelf to display full section name.
+
+* Add "-M entry:<addr>" switch to objdump to specify a function entry address
+  when disassembling VAX binaries.
+
+* Add "--globalize-symbol <name>" and "--globalize-symbols <filename>" switches
+  to objcopy to convert local symbols into global symbols.
+
+* gprof now allows input files to have histogram records for
+  several memory ranges, provided those ranges are disjoint.
+
+Changes in 2.16:
+
+* Add "-g/--section-groups" to readelf to display section groups.
+
+* objcopy recognizes two new options --strip-unneeded-symbol and
+  --strip-unneeded-symbols, namely for use together with the wildcard
+  matching the original --strip-symbol/--strip-symbols provided, but
+  retaining any symbols matching but needed by relocations.
+
+* readelf can now display address ranges from .debug_range sections.  This
+  happens automatically when a DW_AT_range attribute is encountered.  The
+  command-line switch --debug-dump=Ranges (or -wR) can also be used to display
+  the contents of the .debug_range section.
+
+* nm and objdump now have a switch "--special-syms" to enable the displaying of
+  symbols which the target considers to be special.  By default these symbols
+  are no longer displayed.  Currently the only special symbols are the Mapping
+  symbols used by the ARM port to mark transitions between text and data and
+  between ARM and THUMB code.
+
+* dlltool has a switch "--ext-prefix-alias <prefix>" to generate additional
+  import and export symbols with <preifx> prepended to them.
+
+Changes in 2.15:
+
+* objcopy for MIPS targets now accepts "-M no-aliases" as an option to the
+  disassembler to print the "raw" mips instruction mnemonic instead of some
+  pseudo instruction name.  I.E. print "daddu" or "or" instead of "move",
+  "sll" instead of "nop", etc.
+
+* objcopy and strip can now take wildcard patterns in symbol names specified on
+  the command line provided that the --wildcard switch is used to enable them.
+
+* readelf can now parse archives.
+
+* objdump now accepts --debugging-tags to print the debug information in a
+  format compatible with ctags tool.
+
+* objcopy and strip now accept --only-keep-debug to create a file containing
+  those sections that would be stripped out by --strip-debug.  The idea is that
+  this can be used in conjunction with the --add-gnu-debuglink switch to create
+  a two part program distribution - one a stripped executable and the other the
+  debugging info.
+
+* objcopy now accepts --add-gnu-debuglink=<file> to insert a .gnu_debuglink
+  section into a (presumably stripped) executable.  This allows the debug
+  information for the file to be held in a separate file.
+
+* BFD marks the sections .comment and .note as 'n' in the BSD/POSIX
+  single-character representation.  This can be checked by running nm
+  with the -a switch.
+
+Changes in 2.14:
+
+* Added --info switch to objcopy and strip.
+
+* Support for Vitesse IQ2000 added by Red Hat.
+
+* Added 'S' encoding to strings to allow the display of 8-bit characters.
+
+* Added --prefix-symbols=<text>, --prefix-sections=<text> and
+  --prefix-alloc-sections=<text> to objcopy.
+
+* readelf can handle the extensions to the DWARF2 spec used by the Unified
+  Parallel C compiler.
+
+* BFD no longer declares a "boolean" type, to avoid clashes with other
+  headers that declare the same.  Users of BFD should replace boolean,
+  false and true, with int, 0 and 1, or define their own boolean type.
+
+* Support for IP2K added by Denis Chertykov.
+
+Changes in 2.13:
+
+* Support for the Fujitsu FRV architecture added by Red Hat. Models for FR400
+  and FR500 included.
+
+Changes in version 2.12:
+
+* Support for Don Knuth's MMIX, by Hans-Peter Nilsson.
+
+* size: Add --totals to display summary of sizes (Berkeley format only).
+
+* readelf: Add --wide option to not break section header or segment listing
+  lines to fit into 80 columns.
+
+* strings: Add --encoding to display wide character strings.  By Markus Kuhn.
+
+* objcopy: Add --rename-section to change section names.
+
+* readelf: Support added for DWARF 2.1 extensions.  Support added for
+  displaying the contents of .debug.macinfo sections.
+
+* New command-line switches added to objcopy to allow symbols to be kept as
+  global symbols, and also to specify files containing lists of such symbols.
+  by Honda Hiroki.
+
+* Support for OpenRISC by Johan Rydberg.
+
+* New command-line switch to objcopy --alt-machine-code which creates a binary
+  with an alternate machine code if one is defined in the architecture
+  description.  Only supported for ELF targets.  By Alexandre Oliva.
+
+* New command-line switch to objcopy -B (or --binary-architecture) which sets
+  the architecture of the output file to the given argument.  This option only
+  makes sense, if the input target is binary.  Otherwise it is ignored.
+  By Stefan Geuken.
+
+* Support for PDP-11 by Lars Brinkhoff.
+
+Changes in binutils 2.11:
+
+* Add support for ARM v5t and v5te architectures and Intel's XScale ARM
+  extenstions.
+
+* Add --srec-len and --srec-forceS3 command-line switch to objcopy.
+  By Luciano Gemme.
+
+* Support for the MIPS32, by Anders Norlander.
+
+* Support for the i860, by Jason Eckhardt.
+
+* Support for CRIS (Axis Communications ETRAX series).
+
+Changes in binutils 2.10:
+
+* Support for 64-bit ELF on HPPA.
+
+* New command-line switch to objdump --file-start-context which shows the
+  entire file contents up to the source line first encountered for a given
+  file.
+
+* New command-line switch to objdump -M (or --disassembler-options) which takes
+  a parameter which can then be interpreted on a per-target basis by the
+  disassembler.  Used by ARM targets to select register name sets, ISA, APCS or
+  raw verions.
+
+* objdump support for -mi386:intel which causes disassembly to be displayed
+  with intel syntax.
+
+* New program: readelf.  This displays the contents of ELF format files,
+  regardless of target machine.
+
+* objcopy now takes --change-section-lma, --change-section-vma, and
+  --change-section-address options.  The old --adjust-section-vma option is
+  equivalent to --change-section-address.  The other --adjust-* options are now
+  renamed to --change-*, although --adjust-* continues to work.
+
+* objcopy has a --redefine-sym option that lets you rename symbols.
+
+* objcopy now takes a -j/--only-section option to copy only the specified
+  sections.
+
+* dlltool now supports the IMPORTS command.
+
+* dlltool now takes --export-all-symbols, --no-export-all-symbols,
+  --exclude-symbols, and --no-default-excludes options.
+
+Changes in binutils 2.9:
+
+* Added windres program, which can be used to manipulate resources in WIN32
+  files as used on Windows 95 and Windows NT.
+
+* The objcopy --gap-fill and --pad-to options operate on the LMA rather than
+  the VMA of the sections.
+
+* Added S modifier to ar to not build a symbol table.
+
+Changes in binutils 2.8:
+
+* The objdump disassembly format has been changed, and hopefully improved.  Use
+  the new --prefix-addresses option to get the old format.  There are also new
+  --disassemble-zeroes and --no-show-raw-insn options which affect disassembler
+  output.
+
+* Formats may now be specified as configuration triplets.  For example,
+  objdump -b i386-pc-linux.  The triplets are not passed through config.sub,
+  so they must be in canonical form.
+
+* Added new addr2line program.  This uses the debugging information to convert
+  an address into a file name and line number within a program.
+
+* Added --change-leading-char argument to objcopy.
+
+* Added --weaken argument to objcopy.
+
+* objdump --dynamic-reloc now works on ELF executables and shared libraries.
+
+* Added --adjust-vma option to objdump.
+
+* Added -C/--demangle option to objdump.
+
+* Added -p/--preserve-dates option to strip and objcopy.
+
+Changes in binutils 2.7:
+
+* Added --enable-shared and --enable-commonbfdlib options to configure.
+
+* Added --debugging argument to objdump and objcopy.
+
+* Added --defined-only argument to nm.
+
+* Added --remove-leading-char argument to objcopy.
+
+* The objdump --line-numbers option is now meaningful with --reloc.
+
+* Added --line-numbers option to nm.
+
+* Added --endian/-EB/-EL option to objdump.
+
+* Added support for Alpha OpenVMS/AXP.
+
+Changes in binutils 2.6:
+
+* Added -N/--strip-symbol and -K/--keep-symbol arguments to strip and objcopy.
+
+* Added several arguments to objcopy to provide some control over how the new
+  file is laid out in memory.  Also added binary output format to BFD to permit
+  generating plain binary files.
+
+* Added --start-address and --stop-address options to objdump.
+
+* ar and ranlib now work on AIX.  The tools are now built by default on AIX.
+
+Changes in binutils 2.5:
+
+* Changed objdump -dr to dump the relocs interspersed with the assembly
+  listing, for a more useful listing of relocatable files.
+
+* Changed objdump -d/--disassemble to only disassemble SEC_CODE sections.
+  Added -D/--disassemble-all option to disassemble all sections.
+
+* Added --size-sort option to nm.
+
+* strip and objcopy should now be able to handle dynamically linked ELF
+  executables.
+
+Changes in binutils 2.4:
+
+* Support for HP-PA (by Jeff Law), i386 Mach (by David Mackenzie), RS/6000 and
+  PowerPC (except ar and ranlib; by Ian Taylor).
+
+* Support for Irix 5.
+
+* Programs `strip' and `objcopy' will not attempt to write dynamically linked
+  ELF output files, since BFD currently can't create them properly.
+
+Changes in binutils 2.3:
+
+* A new --stabs argument has been added to objdump to dump stabs sections in
+  ELF and COFF files.
+
+* A new program, nlmconv, has been added.  It can convert object files into
+  Novell NetWare Loadable Modules.
+
+* The strings program has been added.
+
+Changes in binutils 2.2:
+
+* The 'copy' program has been renamed to 'objcopy', for consistency with
+  'objdump', and because 'copy' might more plausibly be used as a synonym for
+  'cp'.
+
+* The new stand-alone program c++filt is a filter that converts encoded
+  (mangled) C++ assembly-level identifiers to user-level names.  (Note: This
+  may get moved to the gcc distribution.)
+
+* nm -o on an archive now prefixes each line with the archive name, matching
+  the output from BSD nm.
+
+* ar (and ld) can now read (but not write) BSD4.4-style archives.
+
+* New support for H8500, Z8000, and the Hitach SH.
+
+* Dis-assembler interface changed to allow sharing with gdb.
+
+* There is new Elf code, but it is not yet ready for general use.
+
+* There is the beginnings of a test suite.
+
+Changes in binutils 2.1:
+
+* There is now support for writing ECOFF files, so ld and the other utilities
+  should work on Risc/Ultrix and Irix.  Please let us know how well this works.
+
+* ar now automatically creates a symbol table (a __.SYMDEF member, in the BSD
+  version), if there are any object files in the archive.  So running ranlib is
+  now redundant (unless the non-standard q command is used).  This is required
+  for Posix.2 conformance.
+
+* The archive-reading code now reads both BSD-style and SYSV-style archives
+  independently of the selected target format.  This is to encourage people to
+  switch to SYSV-format, which has a number of advantages.
+
+* The strip and copy programs now have options to remove debug-symbols only
+  and/or local symbols only.  They now also support long options.
+
+
+Copyright (C) 2012-2021 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+
+Local variables:
+fill-column: 79
+End:
diff -rupN binutils.orig/binutils/NEWS.rej binutils-2.37/binutils/NEWS.rej
--- binutils.orig/binutils/NEWS.rej	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.37/binutils/NEWS.rej	2021-11-09 12:34:46.290643870 +0000
@@ -0,0 +1,18 @@
+--- binutils/NEWS
++++ binutils/NEWS
+@@ -2,6 +2,15 @@
+ 
+ * Add support for the LoongArch instruction set.
+ 
++* Tools which display symbols or strings (readelf, strings, nm, objdump)
++  have a new command line option which controls how unicode characters are
++  handled.  By default they are treated as normal for the tool.  Using
++  --unicode=locale will display them according to the current locale.
++  Using --unicode=hex will display them as hex byte values, whilst
++  --unicode=escape will display them as escape sequences.  In addition
++  using --unicode=highlight will display them as unicode escape sequences
++  highlighted in red (if supported by the output device).
++
+ Changes in 2.37:
+ 
+ * The readelf tool has a new command line option which can be used to specify
diff -rupN binutils.orig/binutils/doc/binutils.texi binutils-2.37/binutils/doc/binutils.texi
--- binutils.orig/binutils/doc/binutils.texi	2021-11-09 12:34:21.665802922 +0000
+++ binutils-2.37/binutils/doc/binutils.texi	2021-11-09 12:34:46.290643870 +0000
@@ -812,6 +812,7 @@ nm [@option{-A}|@option{-o}|@option{--pr
    [@option{-s}|@option{--print-armap}]
    [@option{-t} @var{radix}|@option{--radix=}@var{radix}]
    [@option{-u}|@option{--undefined-only}]
+   [@option{-U} @var{method}] [@option{--unicode=}@var{method}]
    [@option{-V}|@option{--version}]
    [@option{-X 32_64}]
    [@option{--defined-only}]
@@ -1132,6 +1133,21 @@ Use @var{radix} as the radix for printin
 @cindex undefined symbols
 Display only undefined symbols (those external to each object file).
 
+@item -U @var{[d|i|l|e|x|h]}
+@itemx --unicode=@var{[default|invalid|locale|escape|hex|highlight]}
+Controls the display of UTF-8 encoded mulibyte characters in strings.
+The default (@option{--unicode=default}) is to give them no special
+treatment.  The @option{--unicode=locale} option displays the sequence
+in the current locale, which may or may not support them.  The options
+@option{--unicode=hex} and @option{--unicode=invalid} display them as
+hex byte sequences enclosed by either angle brackets or curly braces.
+
+The @option{--unicode=escape} option displays them as escape sequences
+(@var{\uxxxx}) and the @option{--unicode=highlight} option displays
+them as escape sequences highlighted in red (if supported by the
+output device).  The colouring is intended to draw attention to the
+presence of unicode sequences where they might not be expected.
+
 @item -V
 @itemx --version
 Show the version number of @command{nm} and exit.
@@ -2247,6 +2263,7 @@ objdump [@option{-a}|@option{--archive-h
         [@option{--prefix-strip=}@var{level}]
         [@option{--insn-width=}@var{width}]
         [@option{--visualize-jumps[=color|=extended-color|=off]}
+        [@option{-U} @var{method}] [@option{--unicode=}@var{method}]
         [@option{-V}|@option{--version}]
         [@option{-H}|@option{--help}]
         @var{objfile}@dots{}
@@ -2921,6 +2938,21 @@ When displaying symbols include those wh
 special in some way and which would not normally be of interest to the
 user.
 
+@item -U @var{[d|i|l|e|x|h]}
+@itemx --unicode=@var{[default|invalid|locale|escape|hex|highlight]}
+Controls the display of UTF-8 encoded mulibyte characters in strings.
+The default (@option{--unicode=default}) is to give them no special
+treatment.  The @option{--unicode=locale} option displays the sequence
+in the current locale, which may or may not support them.  The options
+@option{--unicode=hex} and @option{--unicode=invalid} display them as
+hex byte sequences enclosed by either angle brackets or curly braces.
+
+The @option{--unicode=escape} option displays them as escape sequences
+(@var{\uxxxx}) and the @option{--unicode=highlight} option displays
+them as escape sequences highlighted in red (if supported by the
+output device).  The colouring is intended to draw attention to the
+presence of unicode sequences where they might not be expected.
+
 @item -V
 @itemx --version
 Print the version number of @command{objdump} and exit.
@@ -3197,6 +3229,7 @@ strings [@option{-afovV}] [@option{-}@va
         [@option{-n} @var{min-len}] [@option{--bytes=}@var{min-len}]
         [@option{-t} @var{radix}] [@option{--radix=}@var{radix}]
         [@option{-e} @var{encoding}] [@option{--encoding=}@var{encoding}]
+        [@option{-U} @var{method}] [@option{--unicode=}@var{method}]
         [@option{-}] [@option{--all}] [@option{--print-file-name}]
         [@option{-T} @var{bfdname}] [@option{--target=}@var{bfdname}]
         [@option{-w}] [@option{--include-all-whitespace}]
@@ -3288,6 +3321,28 @@ single-8-bit-byte characters, @samp{b} =
 littleendian.  Useful for finding wide character strings. (@samp{l}
 and @samp{b} apply to, for example, Unicode UTF-16/UCS-2 encodings).
 
+@item -U @var{[d|i|l|e|x|h]}
+@itemx --unicode=@var{[default|invalid|locale|escape|hex|highlight]}
+Controls the display of UTF-8 encoded mulibyte characters in strings.
+The default (@option{--unicode=default}) is to give them no special
+treatment, and instead rely upon the setting of the
+@option{--encoding} option.  The other values for this option
+automatically enable @option{--encoding=S}.
+
+The @option{--unicode=invalid} option treats them as non-graphic
+characters and hence not part of a valid string.  All the remaining
+options treat them as valid string characters.
+
+The @option{--unicode=locale} option displays them in the current
+locale, which may or may not support UTF-8 encoding.  The
+@option{--unicode=hex} option displays them as hex byte sequences
+enclosed between @var{<>} characters.  The @option{--unicode=escape}
+option displays them as escape sequences (@var{\uxxxx}) and the
+@option{--unicode=highlight} option displays them as escape sequences
+highlighted in red (if supported by the output device).  The colouring
+is intended to draw attention to the presence of unicode sequences
+where they might not be expected.
+
 @item -T @var{bfdname}
 @itemx --target=@var{bfdname}
 @cindex object code format
@@ -4796,6 +4851,7 @@ readelf [@option{-a}|@option{--all}]
         [@option{--demangle@var{=style}}|@option{--no-demangle}]
         [@option{--quiet}]
         [@option{--recurse-limit}|@option{--no-recurse-limit}]
+        [@option{-U} @var{method}|@option{--unicode=}@var{method}]
         [@option{-n}|@option{--notes}]
         [@option{-r}|@option{--relocs}]
         [@option{-u}|@option{--unwind}]
@@ -4962,6 +5018,28 @@ necessary in order to demangle truly com
 that if the recursion limit is disabled then stack exhaustion is
 possible and any bug reports about such an event will be rejected.
 
+@item -U @var{[d|i|l|e|x|h]}
+@itemx --unicode=[default|invalid|locale|escape|hex|highlight]
+Controls the display of non-ASCII characters in identifier names.
+The default (@option{--unicode=locale} or @option{--unicode=default}) is
+to treat them as multibyte characters and display them in the current
+locale.  All other versions of this option treat the bytes as UTF-8
+encoded values and attempt to interpret them.  If they cannot be
+interpreted or if the @option{--unicode=invalid} option is used then
+they are displayed as a sequence of hex bytes, encloses in curly
+parethesis characters.
+
+Using the @option{--unicode=escape} option will display the characters
+as as unicode escape sequences (@var{\uxxxx}).  Using the
+@option{--unicode=hex} will display the characters as hex byte
+sequences enclosed between angle brackets.
+
+Using the @option{--unicode=highlight} will display the characters as 
+unicode escape sequences but it will also highlighted them in red,
+assuming that colouring is supported by the output device.  The
+colouring is intended to draw attention to the presence of unicode
+sequences when they might not be expected.
+
 @item -e
 @itemx --headers
 Display all the headers in the file.  Equivalent to @option{-h -l -S}.
diff -rupN binutils.orig/binutils/nm.c binutils-2.37/binutils/nm.c
--- binutils.orig/binutils/nm.c	2021-11-09 12:34:21.661802947 +0000
+++ binutils-2.37/binutils/nm.c	2021-11-09 12:34:46.291643864 +0000
@@ -38,6 +38,11 @@
 #include "bucomm.h"
 #include "plugin-api.h"
 #include "plugin.h"
+#include "safe-ctype.h"
+
+#ifndef streq
+#define streq(a,b) (strcmp ((a),(b)) == 0)
+#endif
 
 /* When sorting by size, we use this structure to hold the size and a
    pointer to the minisymbol.  */
@@ -216,6 +221,18 @@ static const char *plugin_target = NULL;
 static bfd *lineno_cache_bfd;
 static bfd *lineno_cache_rel_bfd;
 
+typedef enum unicode_display_type
+{
+  unicode_default = 0,
+  unicode_locale,
+  unicode_escape,
+  unicode_hex,
+  unicode_highlight,
+  unicode_invalid
+} unicode_display_type;
+
+static unicode_display_type unicode_display = unicode_default;
+
 enum long_option_values
 {
   OPTION_TARGET = 200,
@@ -260,6 +277,7 @@ static struct option long_options[] =
   {"target", required_argument, 0, OPTION_TARGET},
   {"defined-only", no_argument, &defined_only, 1},
   {"undefined-only", no_argument, &undefined_only, 1},
+  {"unicode", required_argument, NULL, 'U'},
   {"version", no_argument, &show_version, 1},
   {"with-symbol-versions", no_argument, &with_symbol_versions, 1},
   {"without-symbol-versions", no_argument, &with_symbol_versions, 0},
@@ -313,6 +331,8 @@ usage (FILE *stream, int status)
   -t, --radix=RADIX      Use RADIX for printing symbol values\n\
       --target=BFDNAME   Specify the target object format as BFDNAME\n\
   -u, --undefined-only   Display only undefined symbols\n\
+  -U {d|s|i|x|e|h}       Specify how to treat UTF-8 encoded unicode characters\n\
+      --unicode={default|show|invalid|hex|escape|highlight}\n\
       --with-symbol-versions  Display version strings after symbol names\n\
   -X 32_64               (ignored)\n\
   @FILE                  Read options from FILE\n\
@@ -432,6 +452,187 @@ get_coff_symbol_type (const struct inter
   return bufp;
 }
 
+/* Convert a potential UTF-8 encoded sequence in IN into characters in OUT.
+   The conversion format is controlled by the unicode_display variable.
+   Returns the number of characters added to OUT.
+   Returns the number of bytes consumed from IN in CONSUMED.
+   Always consumes at least one byte and displays at least one character.  */
+   
+static unsigned int
+display_utf8 (const unsigned char * in, char * out, unsigned int * consumed)
+{
+  char *        orig_out = out;
+  unsigned int  nchars = 0;
+  unsigned int j;
+
+  if (unicode_display == unicode_default)
+    goto invalid;
+
+  if (in[0] < 0xc0)
+    goto invalid;
+
+  if ((in[1] & 0xc0) != 0x80)
+    goto invalid;
+
+  if ((in[0] & 0x20) == 0)
+    {
+      nchars = 2;
+      goto valid;
+    }
+
+  if ((in[2] & 0xc0) != 0x80)
+    goto invalid;
+
+  if ((in[0] & 0x10) == 0)
+    {
+      nchars = 3;
+      goto valid;
+    }
+
+  if ((in[3] & 0xc0) != 0x80)
+    goto invalid;
+
+  nchars = 4;
+
+ valid:
+  switch (unicode_display)
+    {
+    case unicode_locale:
+      /* Copy the bytes into the output buffer as is.  */
+      memcpy (out, in, nchars);
+      out += nchars;
+      break;
+
+    case unicode_invalid:
+    case unicode_hex:
+      out += sprintf (out, "%c", unicode_display == unicode_hex ? '<' : '{');
+      out += sprintf (out, "0x");
+      for (j = 0; j < nchars; j++)
+	out += sprintf (out, "%02x", in [j]);
+      out += sprintf (out, "%c", unicode_display == unicode_hex ? '>' : '}');
+      break;
+      
+    case unicode_highlight:
+      if (isatty (1))
+	out += sprintf (out, "\x1B[31;47m"); /* Red.  */
+      /* Fall through.  */
+    case unicode_escape:
+      switch (nchars)
+	{
+	case 2:
+	  out += sprintf (out, "\\u%02x%02x",
+		  ((in[0] & 0x1c) >> 2), 
+		  ((in[0] & 0x03) << 6) | (in[1] & 0x3f));
+	  break;
+
+	case 3:
+	  out += sprintf (out, "\\u%02x%02x",
+		  ((in[0] & 0x0f) << 4) | ((in[1] & 0x3c) >> 2),
+		  ((in[1] & 0x03) << 6) | ((in[2] & 0x3f)));
+	  break;
+
+	case 4:
+	  out += sprintf (out, "\\u%02x%02x%02x",
+		  ((in[0] & 0x07) << 6) | ((in[1] & 0x3c) >> 2),
+		  ((in[1] & 0x03) << 6) | ((in[2] & 0x3c) >> 2),
+		  ((in[2] & 0x03) << 6) | ((in[3] & 0x3f)));
+	  break;
+	default:
+	  /* URG.  */
+	  break;
+	}
+
+      if (unicode_display == unicode_highlight && isatty (1))
+	out += sprintf (out, "\033[0m"); /* Default colour.  */
+      break;
+
+    default:
+      /* URG */
+      break;
+    }
+
+  * consumed = nchars;
+  return out - orig_out;
+
+ invalid:
+  /* Not a valid UTF-8 sequence.  */
+  *out = *in;
+  * consumed = 1;
+  return 1;
+}
+
+/* Convert any UTF-8 encoded characters in NAME into the form specified by
+   unicode_display.  Also converts control characters.  Returns a static
+   buffer if conversion was necessary.
+   Code stolen from objdump.c:sanitize_string().  */
+
+static const char *
+convert_utf8 (const char * in)
+{
+  static char *  buffer = NULL;
+  static size_t  buffer_len = 0;
+  const char *   original = in;
+  char *         out;
+
+  /* Paranoia.  */
+  if (in == NULL)
+    return "";
+
+  /* See if any conversion is necessary.
+     In the majority of cases it will not be needed.  */
+  do
+    {
+      unsigned char c = *in++;
+
+      if (c == 0)
+	return original;
+
+      if (ISCNTRL (c))
+	break;
+
+      if (unicode_display != unicode_default && c >= 0xc0)
+	break;
+    }
+  while (1);
+
+  /* Copy the input, translating as needed.  */
+  in = original;
+  if (buffer_len < (strlen (in) * 9))
+    {
+      free ((void *) buffer);
+      buffer_len = strlen (in) * 9;
+      buffer = xmalloc (buffer_len + 1);
+    }
+
+  out = buffer;
+  do
+    {
+      unsigned char c = *in++;
+
+      if (c == 0)
+	break;
+
+      if (ISCNTRL (c))
+	{
+	  *out++ = '^';
+	  *out++ = c + 0x40;
+	}
+      else if (unicode_display != unicode_default && c >= 0xc0)
+	{
+	  unsigned int num_consumed;
+
+	  out += display_utf8 ((const unsigned char *)(in - 1), out, & num_consumed);
+	  in += num_consumed - 1;
+	}
+      else
+	*out++ = c;
+    }
+  while (1);
+
+  *out = 0;
+  return buffer;
+}
+
 /* Print symbol name NAME, read from ABFD, with printf format FORM,
    demangling it if requested.  */
 
@@ -444,6 +645,7 @@ print_symname (const char *form, struct
 
   if (name == NULL)
     name = info->sinfo->name;
+
   if (!with_symbol_versions
       && bfd_get_flavour (abfd) == bfd_target_elf_flavour)
     {
@@ -451,6 +653,7 @@ print_symname (const char *form, struct
       if (atver)
 	*atver = 0;
     }
+
   if (do_demangle && *name)
     {
       alloc = bfd_demangle (abfd, name, demangle_flags);
@@ -458,6 +661,11 @@ print_symname (const char *form, struct
 	name = alloc;
     }
 
+  if (unicode_display != unicode_default)
+    {
+      name = convert_utf8 (name);
+    }
+
   if (info != NULL && info->elfinfo && with_symbol_versions)
     {
       const char *version_string;
@@ -1807,7 +2015,7 @@ main (int argc, char **argv)
     fatal (_("fatal error: libbfd ABI mismatch"));
   set_default_bfd_target ();
 
-  while ((c = getopt_long (argc, argv, "aABCDef:gHhjJlnopPrSst:uvVvX:",
+  while ((c = getopt_long (argc, argv, "aABCDef:gHhjJlnopPrSst:uU:vVvX:",
 			   long_options, (int *) 0)) != EOF)
     {
       switch (c)
@@ -1900,6 +2108,24 @@ main (int argc, char **argv)
 	case 'u':
 	  undefined_only = 1;
 	  break;
+
+	case 'U':
+	  if (streq (optarg, "default") || streq (optarg, "d"))
+	    unicode_display = unicode_default;
+	  else if (streq (optarg, "locale") || streq (optarg, "l"))
+	    unicode_display = unicode_locale;
+	  else if (streq (optarg, "escape") || streq (optarg, "e"))
+	    unicode_display = unicode_escape;
+	  else if (streq (optarg, "invalid") || streq (optarg, "i"))
+	    unicode_display = unicode_invalid;
+	  else if (streq (optarg, "hex") || streq (optarg, "x"))
+	    unicode_display = unicode_hex;
+	  else if (streq (optarg, "highlight") || streq (optarg, "h"))
+	    unicode_display = unicode_highlight;
+	  else
+	    fatal (_("invalid argument to -U/--unicode: %s"), optarg);
+	  break;
+
 	case 'V':
 	  show_version = 1;
 	  break;
diff -rupN binutils.orig/binutils/nm.c.orig binutils-2.37/binutils/nm.c.orig
--- binutils.orig/binutils/nm.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.37/binutils/nm.c.orig	2021-07-08 12:37:19.000000000 +0100
@@ -0,0 +1,1973 @@
+/* nm.c -- Describe symbol table of a rel file.
+   Copyright (C) 1991-2021 Free Software Foundation, Inc.
+
+   This file is part of GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "progress.h"
+#include "getopt.h"
+#include "aout/stab_gnu.h"
+#include "aout/ranlib.h"
+#include "demangle.h"
+#include "libiberty.h"
+#include "elf-bfd.h"
+#include "elf/common.h"
+#define DO_NOT_DEFINE_AOUTHDR
+#define DO_NOT_DEFINE_FILHDR
+#define DO_NOT_DEFINE_LINENO
+#define DO_NOT_DEFINE_SCNHDR
+#include "coff/external.h"
+#include "coff/internal.h"
+#include "libcoff.h"
+#include "bucomm.h"
+#include "plugin-api.h"
+#include "plugin.h"
+
+/* When sorting by size, we use this structure to hold the size and a
+   pointer to the minisymbol.  */
+
+struct size_sym
+{
+  const void *minisym;
+  bfd_vma size;
+};
+
+/* When fetching relocs, we use this structure to pass information to
+   get_relocs.  */
+
+struct get_relocs_info
+{
+  asection **secs;
+  arelent ***relocs;
+  long *relcount;
+  asymbol **syms;
+};
+
+struct extended_symbol_info
+{
+  symbol_info *sinfo;
+  bfd_vma ssize;
+  elf_symbol_type *elfinfo;
+  coff_symbol_type *coffinfo;
+  /* FIXME: We should add more fields for Type, Line, Section.  */
+};
+#define SYM_VALUE(sym)       (sym->sinfo->value)
+#define SYM_TYPE(sym)        (sym->sinfo->type)
+#define SYM_STAB_NAME(sym)   (sym->sinfo->stab_name)
+#define SYM_STAB_DESC(sym)   (sym->sinfo->stab_desc)
+#define SYM_STAB_OTHER(sym)  (sym->sinfo->stab_other)
+#define SYM_SIZE(sym) \
+  (sym->elfinfo ? sym->elfinfo->internal_elf_sym.st_size: sym->ssize)
+
+/* The output formatting functions.  */
+static void print_object_filename_bsd (const char *);
+static void print_object_filename_sysv (const char *);
+static void print_object_filename_posix (const char *);
+static void do_not_print_object_filename (const char *);
+
+static void print_archive_filename_bsd (const char *);
+static void print_archive_filename_sysv (const char *);
+static void print_archive_filename_posix (const char *);
+static void do_not_print_archive_filename (const char *);
+
+static void print_archive_member_bsd (const char *, const char *);
+static void print_archive_member_sysv (const char *, const char *);
+static void print_archive_member_posix (const char *, const char *);
+static void do_not_print_archive_member (const char *, const char *);
+
+static void print_symbol_filename_bsd (bfd *, bfd *);
+static void print_symbol_filename_sysv (bfd *, bfd *);
+static void print_symbol_filename_posix (bfd *, bfd *);
+static void do_not_print_symbol_filename (bfd *, bfd *);
+
+static void print_symbol_info_bsd (struct extended_symbol_info *, bfd *);
+static void print_symbol_info_sysv (struct extended_symbol_info *, bfd *);
+static void print_symbol_info_posix (struct extended_symbol_info *, bfd *);
+static void just_print_symbol_name (struct extended_symbol_info *, bfd *);
+
+static void print_value (bfd *, bfd_vma);
+
+/* Support for different output formats.  */
+struct output_fns
+{
+  /* Print the name of an object file given on the command line.  */
+  void (*print_object_filename) (const char *);
+
+  /* Print the name of an archive file given on the command line.  */
+  void (*print_archive_filename) (const char *);
+
+  /* Print the name of an archive member file.  */
+  void (*print_archive_member) (const char *, const char *);
+
+  /* Print the name of the file (and archive, if there is one)
+     containing a symbol.  */
+  void (*print_symbol_filename) (bfd *, bfd *);
+
+  /* Print a line of information about a symbol.  */
+  void (*print_symbol_info) (struct extended_symbol_info *, bfd *);
+};
+
+/* Indices in `formats'.  */
+enum formats
+{
+  FORMAT_BSD = 0,
+  FORMAT_SYSV,
+  FORMAT_POSIX,
+  FORMAT_JUST_SYMBOLS,
+  FORMAT_MAX
+};
+
+#define FORMAT_DEFAULT FORMAT_BSD
+
+static struct output_fns formats[FORMAT_MAX] =
+{
+  {print_object_filename_bsd,
+   print_archive_filename_bsd,
+   print_archive_member_bsd,
+   print_symbol_filename_bsd,
+   print_symbol_info_bsd},
+  {print_object_filename_sysv,
+   print_archive_filename_sysv,
+   print_archive_member_sysv,
+   print_symbol_filename_sysv,
+   print_symbol_info_sysv},
+  {print_object_filename_posix,
+   print_archive_filename_posix,
+   print_archive_member_posix,
+   print_symbol_filename_posix,
+   print_symbol_info_posix},
+  {do_not_print_object_filename,
+   do_not_print_archive_filename,
+   do_not_print_archive_member,
+   do_not_print_symbol_filename,
+   just_print_symbol_name}
+};
+
+
+/* The output format to use.  */
+static struct output_fns *format = &formats[FORMAT_DEFAULT];
+static unsigned int print_format = FORMAT_DEFAULT;
+static const char *print_format_string = NULL;
+
+/* Command options.  */
+
+static int do_demangle = 0;	/* Pretty print C++ symbol names.  */
+static int external_only = 0;	/* Print external symbols only.  */
+static int defined_only = 0;	/* Print defined symbols only.  */
+static int no_sort = 0;		/* Don't sort; print syms in order found.  */
+static int print_debug_syms = 0;/* Print debugger-only symbols too.  */
+static int print_armap = 0;	/* Describe __.SYMDEF data in archive files.  */
+static int print_size = 0;	/* Print size of defined symbols.  */
+static int reverse_sort = 0;	/* Sort in downward(alpha or numeric) order.  */
+static int sort_numerically = 0;/* Sort in numeric rather than alpha order.  */
+static int sort_by_size = 0;	/* Sort by size of symbol.  */
+static int undefined_only = 0;	/* Print undefined symbols only.  */
+static int dynamic = 0;		/* Print dynamic symbols.  */
+static int show_version = 0;	/* Show the version number.  */
+static int show_synthetic = 0;	/* Display synthesized symbols too.  */
+static int line_numbers = 0;	/* Print line numbers for symbols.  */
+static int allow_special_symbols = 0;  /* Allow special symbols.  */
+static int with_symbol_versions = -1; /* Output symbol version information.  */
+static int quiet = 0;		/* Suppress "no symbols" diagnostic.  */
+
+/* The characters to use for global and local ifunc symbols.  */
+#if DEFAULT_F_FOR_IFUNC_SYMBOLS
+static const char * ifunc_type_chars = "Ff";
+#else
+static const char * ifunc_type_chars = NULL;
+#endif
+
+static int demangle_flags = DMGL_ANSI | DMGL_PARAMS;
+
+/* When to print the names of files.  Not mutually exclusive in SYSV format.  */
+static int filename_per_file = 0;	/* Once per file, on its own line.  */
+static int filename_per_symbol = 0;	/* Once per symbol, at start of line.  */
+
+static int print_width = 0;
+static int print_radix = 16;
+/* Print formats for printing stab info.  */
+static char other_format[] = "%02x";
+static char desc_format[] = "%04x";
+
+static char *target = NULL;
+#if BFD_SUPPORTS_PLUGINS
+static const char *plugin_target = "plugin";
+#else
+static const char *plugin_target = NULL;
+#endif
+
+/* Used to cache the line numbers for a BFD.  */
+static bfd *lineno_cache_bfd;
+static bfd *lineno_cache_rel_bfd;
+
+enum long_option_values
+{
+  OPTION_TARGET = 200,
+  OPTION_PLUGIN,
+  OPTION_SIZE_SORT,
+  OPTION_RECURSE_LIMIT,
+  OPTION_NO_RECURSE_LIMIT,
+  OPTION_IFUNC_CHARS,
+  OPTION_QUIET
+};
+
+static struct option long_options[] =
+{
+  {"debug-syms", no_argument, &print_debug_syms, 1},
+  {"demangle", optional_argument, 0, 'C'},
+  {"dynamic", no_argument, &dynamic, 1},
+  {"extern-only", no_argument, &external_only, 1},
+  {"format", required_argument, 0, 'f'},
+  {"help", no_argument, 0, 'h'},
+  {"ifunc-chars", required_argument, 0, OPTION_IFUNC_CHARS},
+  {"just-symbols", no_argument, 0, 'j'},
+  {"line-numbers", no_argument, 0, 'l'},
+  {"no-cplus", no_argument, &do_demangle, 0},  /* Linux compatibility.  */
+  {"no-demangle", no_argument, &do_demangle, 0},
+  {"no-recurse-limit", no_argument, NULL, OPTION_NO_RECURSE_LIMIT},
+  {"no-recursion-limit", no_argument, NULL, OPTION_NO_RECURSE_LIMIT},
+  {"no-sort", no_argument, 0, 'p'},
+  {"numeric-sort", no_argument, 0, 'n'},
+  {"plugin", required_argument, 0, OPTION_PLUGIN},
+  {"portability", no_argument, 0, 'P'},
+  {"print-armap", no_argument, &print_armap, 1},
+  {"print-file-name", no_argument, 0, 'o'},
+  {"print-size", no_argument, 0, 'S'},
+  {"quiet", no_argument, 0, OPTION_QUIET},
+  {"radix", required_argument, 0, 't'},
+  {"recurse-limit", no_argument, NULL, OPTION_RECURSE_LIMIT},
+  {"recursion-limit", no_argument, NULL, OPTION_RECURSE_LIMIT},
+  {"reverse-sort", no_argument, &reverse_sort, 1},
+  {"size-sort", no_argument, 0, OPTION_SIZE_SORT},
+  {"special-syms", no_argument, &allow_special_symbols, 1},
+  {"synthetic", no_argument, &show_synthetic, 1},
+  {"target", required_argument, 0, OPTION_TARGET},
+  {"defined-only", no_argument, &defined_only, 1},
+  {"undefined-only", no_argument, &undefined_only, 1},
+  {"version", no_argument, &show_version, 1},
+  {"with-symbol-versions", no_argument, &with_symbol_versions, 1},
+  {"without-symbol-versions", no_argument, &with_symbol_versions, 0},
+  {0, no_argument, 0, 0}
+};
+
+/* Some error-reporting functions.  */
+
+ATTRIBUTE_NORETURN static void
+usage (FILE *stream, int status)
+{
+  fprintf (stream, _("Usage: %s [option(s)] [file(s)]\n"), program_name);
+  fprintf (stream, _(" List symbols in [file(s)] (a.out by default).\n"));
+  fprintf (stream, _(" The options are:\n\
+  -a, --debug-syms       Display debugger-only symbols\n\
+  -A, --print-file-name  Print name of the input file before every symbol\n\
+  -B                     Same as --format=bsd\n\
+  -C, --demangle[=STYLE] Decode low-level symbol names into user-level names\n\
+                          The STYLE, if specified, can be `auto' (the default),\n\
+                          `gnu', `lucid', `arm', `hp', `edg', `gnu-v3', `java'\n\
+                          or `gnat'\n\
+      --no-demangle      Do not demangle low-level symbol names\n\
+      --recurse-limit    Enable a demangling recursion limit.  This is the default.\n\
+      --no-recurse-limit Disable a demangling recursion limit.\n\
+  -D, --dynamic          Display dynamic symbols instead of normal symbols\n\
+      --defined-only     Display only defined symbols\n\
+  -e                     (ignored)\n\
+  -f, --format=FORMAT    Use the output format FORMAT.  FORMAT can be `bsd',\n\
+                           `sysv', `posix' or 'just-symbols'.  The default is `bsd'\n\
+  -g, --extern-only      Display only external symbols\n\
+    --ifunc-chars=CHARS  Characters to use when displaying ifunc symbols\n\
+  -j, --just-symbols     Same as --format=just-symbols\n\
+  -l, --line-numbers     Use debugging information to find a filename and\n\
+                           line number for each symbol\n\
+  -n, --numeric-sort     Sort symbols numerically by address\n\
+  -o                     Same as -A\n\
+  -p, --no-sort          Do not sort the symbols\n\
+  -P, --portability      Same as --format=posix\n\
+  -r, --reverse-sort     Reverse the sense of the sort\n"));
+#if BFD_SUPPORTS_PLUGINS
+  fprintf (stream, _("\
+      --plugin NAME      Load the specified plugin\n"));
+#endif
+  fprintf (stream, _("\
+  -S, --print-size       Print size of defined symbols\n\
+  -s, --print-armap      Include index for symbols from archive members\n\
+      --quiet            Suppress \"no symbols\" diagnostic\n\
+      --size-sort        Sort symbols by size\n\
+      --special-syms     Include special symbols in the output\n\
+      --synthetic        Display synthetic symbols as well\n\
+  -t, --radix=RADIX      Use RADIX for printing symbol values\n\
+      --target=BFDNAME   Specify the target object format as BFDNAME\n\
+  -u, --undefined-only   Display only undefined symbols\n\
+      --with-symbol-versions  Display version strings after symbol names\n\
+  -X 32_64               (ignored)\n\
+  @FILE                  Read options from FILE\n\
+  -h, --help             Display this information\n\
+  -V, --version          Display this program's version number\n\
+\n"));
+  list_supported_targets (program_name, stream);
+  if (REPORT_BUGS_TO[0] && status == 0)
+    fprintf (stream, _("Report bugs to %s.\n"), REPORT_BUGS_TO);
+  exit (status);
+}
+
+/* Set the radix for the symbol value and size according to RADIX.  */
+
+static void
+set_print_radix (char *radix)
+{
+  switch (*radix)
+    {
+    case 'x': print_radix = 16; break;
+    case 'd': print_radix = 10; break;
+    case 'o': print_radix =  8; break;
+
+    default:
+      fatal (_("%s: invalid radix"), radix);
+    }
+
+  other_format[3] = desc_format[3] = *radix;
+}
+
+static void
+set_output_format (char *f)
+{
+  int i;
+
+  switch (*f)
+    {
+    case 'b':
+    case 'B':
+      i = FORMAT_BSD;
+      break;
+    case 'p':
+    case 'P':
+      i = FORMAT_POSIX;
+      break;
+    case 's':
+    case 'S':
+      i = FORMAT_SYSV;
+      break;
+    case 'j':
+    case 'J':
+      i = FORMAT_JUST_SYMBOLS;
+      break;
+    default:
+      fatal (_("%s: invalid output format"), f);
+    }
+  format = &formats[i];
+  print_format = i;
+}
+
+static const char *
+get_elf_symbol_type (unsigned int type)
+{
+  static char *bufp;
+  int n;
+
+  switch (type)
+    {
+    case STT_NOTYPE:   return "NOTYPE";
+    case STT_OBJECT:   return "OBJECT";
+    case STT_FUNC:     return "FUNC";
+    case STT_SECTION:  return "SECTION";
+    case STT_FILE:     return "FILE";
+    case STT_COMMON:   return "COMMON";
+    case STT_TLS:      return "TLS";
+    }
+
+  free (bufp);
+  if (type >= STT_LOPROC && type <= STT_HIPROC)
+    n = asprintf (&bufp, _("<processor specific>: %d"), type);
+  else if (type >= STT_LOOS && type <= STT_HIOS)
+    n = asprintf (&bufp, _("<OS specific>: %d"), type);
+  else
+    n = asprintf (&bufp, _("<unknown>: %d"), type);
+  if (n < 0)
+    fatal ("%s", xstrerror (errno));
+  return bufp;
+}
+
+static const char *
+get_coff_symbol_type (const struct internal_syment *sym)
+{
+  static char *bufp;
+  int n;
+
+  switch (sym->n_sclass)
+    {
+    case C_BLOCK: return "Block";
+    case C_FILE:  return "File";
+    case C_LINE:  return "Line";
+    }
+
+  if (!sym->n_type)
+    return "None";
+
+  switch (DTYPE(sym->n_type))
+    {
+    case DT_FCN: return "Function";
+    case DT_PTR: return "Pointer";
+    case DT_ARY: return "Array";
+    }
+
+  free (bufp);
+  n = asprintf (&bufp, _("<unknown>: %d/%d"), sym->n_sclass, sym->n_type);
+  if (n < 0)
+    fatal ("%s", xstrerror (errno));
+  return bufp;
+}
+
+/* Print symbol name NAME, read from ABFD, with printf format FORM,
+   demangling it if requested.  */
+
+static void
+print_symname (const char *form, struct extended_symbol_info *info,
+	       const char *name, bfd *abfd)
+{
+  char *alloc = NULL;
+  char *atver = NULL;
+
+  if (name == NULL)
+    name = info->sinfo->name;
+  if (!with_symbol_versions
+      && bfd_get_flavour (abfd) == bfd_target_elf_flavour)
+    {
+      atver = strchr (name, '@');
+      if (atver)
+	*atver = 0;
+    }
+  if (do_demangle && *name)
+    {
+      alloc = bfd_demangle (abfd, name, demangle_flags);
+      if (alloc != NULL)
+	name = alloc;
+    }
+
+  if (info != NULL && info->elfinfo && with_symbol_versions)
+    {
+      const char *version_string;
+      bool hidden;
+
+      version_string
+	= bfd_get_symbol_version_string (abfd, &info->elfinfo->symbol,
+					 false, &hidden);
+      if (version_string && version_string[0])
+	{
+	  const char *at = "@@";
+	  if (hidden || bfd_is_und_section (info->elfinfo->symbol.section))
+	    at = "@";
+	  alloc = reconcat (alloc, name, at, version_string, NULL);
+	  if (alloc != NULL)
+	    name = alloc;
+	}
+    }
+  printf (form, name);
+  if (atver)
+    *atver = '@';
+  free (alloc);
+}
+
+static void
+print_symdef_entry (bfd *abfd)
+{
+  symindex idx = BFD_NO_MORE_SYMBOLS;
+  carsym *thesym;
+  bool everprinted = false;
+
+  for (idx = bfd_get_next_mapent (abfd, idx, &thesym);
+       idx != BFD_NO_MORE_SYMBOLS;
+       idx = bfd_get_next_mapent (abfd, idx, &thesym))
+    {
+      bfd *elt;
+      if (!everprinted)
+	{
+	  printf (_("\nArchive index:\n"));
+	  everprinted = true;
+	}
+      elt = bfd_get_elt_at_index (abfd, idx);
+      if (elt == NULL)
+	bfd_fatal ("bfd_get_elt_at_index");
+      if (thesym->name != (char *) NULL)
+	{
+	  print_symname ("%s", NULL, thesym->name, abfd);
+	  printf (" in %s\n", bfd_get_filename (elt));
+	}
+    }
+}
+
+
+/* True when we can report missing plugin error.  */
+bool report_plugin_err = true;
+
+/* Choose which symbol entries to print;
+   compact them downward to get rid of the rest.
+   Return the number of symbols to be printed.  */
+
+static long
+filter_symbols (bfd *abfd, bool is_dynamic, void *minisyms,
+		long symcount, unsigned int size)
+{
+  bfd_byte *from, *fromend, *to;
+  asymbol *store;
+
+  store = bfd_make_empty_symbol (abfd);
+  if (store == NULL)
+    bfd_fatal (bfd_get_filename (abfd));
+
+  from = (bfd_byte *) minisyms;
+  fromend = from + symcount * size;
+  to = (bfd_byte *) minisyms;
+
+  for (; from < fromend; from += size)
+    {
+      int keep = 0;
+      asymbol *sym;
+
+      PROGRESS (1);
+
+      sym = bfd_minisymbol_to_symbol (abfd, is_dynamic, (const void *) from, store);
+      if (sym == NULL)
+	bfd_fatal (bfd_get_filename (abfd));
+
+      if (sym->name[0] == '_'
+	  && sym->name[1] == '_'
+	  && strcmp (sym->name + (sym->name[2] == '_'), "__gnu_lto_slim") == 0
+	  && report_plugin_err)
+	{
+	  report_plugin_err = false;
+	  non_fatal (_("%s: plugin needed to handle lto object"),
+		     bfd_get_filename (abfd));
+	}
+
+      if (undefined_only)
+	keep = bfd_is_und_section (sym->section);
+      else if (external_only)
+	/* PR binutls/12753: Unique symbols are global too.  */
+	keep = ((sym->flags & (BSF_GLOBAL
+			       | BSF_WEAK
+			       | BSF_GNU_UNIQUE)) != 0
+		|| bfd_is_und_section (sym->section)
+		|| bfd_is_com_section (sym->section));
+      else
+	keep = 1;
+
+      if (keep
+	  && ! print_debug_syms
+	  && (sym->flags & BSF_DEBUGGING) != 0)
+	keep = 0;
+
+      if (keep
+	  && sort_by_size
+	  && (bfd_is_abs_section (sym->section)
+	      || bfd_is_und_section (sym->section)))
+	keep = 0;
+
+      if (keep
+	  && defined_only)
+	{
+	  if (bfd_is_und_section (sym->section))
+	    keep = 0;
+	}
+
+      if (keep
+	  && bfd_is_target_special_symbol (abfd, sym)
+	  && ! allow_special_symbols)
+	keep = 0;
+
+      if (keep)
+	{
+	  if (to != from)
+	    memcpy (to, from, size);
+	  to += size;
+	}
+    }
+
+  return (to - (bfd_byte *) minisyms) / size;
+}
+
+/* These globals are used to pass information into the sorting
+   routines.  */
+static bfd *sort_bfd;
+static bool sort_dynamic;
+static asymbol *sort_x;
+static asymbol *sort_y;
+
+/* Symbol-sorting predicates */
+#define valueof(x) ((x)->section->vma + (x)->value)
+
+/* Numeric sorts.  Undefined symbols are always considered "less than"
+   defined symbols with zero values.  Common symbols are not treated
+   specially -- i.e., their sizes are used as their "values".  */
+
+static int
+non_numeric_forward (const void *P_x, const void *P_y)
+{
+  asymbol *x, *y;
+  const char *xn, *yn;
+
+  x = bfd_minisymbol_to_symbol (sort_bfd, sort_dynamic, P_x, sort_x);
+  y = bfd_minisymbol_to_symbol (sort_bfd, sort_dynamic, P_y, sort_y);
+  if (x == NULL || y == NULL)
+    bfd_fatal (bfd_get_filename (sort_bfd));
+
+  xn = bfd_asymbol_name (x);
+  yn = bfd_asymbol_name (y);
+
+  if (yn == NULL)
+    return xn != NULL;
+  if (xn == NULL)
+    return -1;
+
+  /* Solaris 2.5 has a bug in strcoll.
+     strcoll returns invalid values when confronted with empty strings.  */
+  if (*yn == '\0')
+    return *xn != '\0';
+  if (*xn == '\0')
+    return -1;
+
+  return strcoll (xn, yn);
+}
+
+static int
+non_numeric_reverse (const void *x, const void *y)
+{
+  return - non_numeric_forward (x, y);
+}
+
+static int
+numeric_forward (const void *P_x, const void *P_y)
+{
+  asymbol *x, *y;
+  asection *xs, *ys;
+
+  x = bfd_minisymbol_to_symbol (sort_bfd, sort_dynamic, P_x, sort_x);
+  y =  bfd_minisymbol_to_symbol (sort_bfd, sort_dynamic, P_y, sort_y);
+  if (x == NULL || y == NULL)
+    bfd_fatal (bfd_get_filename (sort_bfd));
+
+  xs = bfd_asymbol_section (x);
+  ys = bfd_asymbol_section (y);
+
+  if (bfd_is_und_section (xs))
+    {
+      if (! bfd_is_und_section (ys))
+	return -1;
+    }
+  else if (bfd_is_und_section (ys))
+    return 1;
+  else if (valueof (x) != valueof (y))
+    return valueof (x) < valueof (y) ? -1 : 1;
+
+  return non_numeric_forward (P_x, P_y);
+}
+
+static int
+numeric_reverse (const void *x, const void *y)
+{
+  return - numeric_forward (x, y);
+}
+
+static int (*(sorters[2][2])) (const void *, const void *) =
+{
+  { non_numeric_forward, non_numeric_reverse },
+  { numeric_forward, numeric_reverse }
+};
+
+/* This sort routine is used by sort_symbols_by_size.  It is similar
+   to numeric_forward, but when symbols have the same value it sorts
+   by section VMA.  This simplifies the sort_symbols_by_size code
+   which handles symbols at the end of sections.  Also, this routine
+   tries to sort file names before other symbols with the same value.
+   That will make the file name have a zero size, which will make
+   sort_symbols_by_size choose the non file name symbol, leading to
+   more meaningful output.  For similar reasons, this code sorts
+   gnu_compiled_* and gcc2_compiled before other symbols with the same
+   value.  */
+
+static int
+size_forward1 (const void *P_x, const void *P_y)
+{
+  asymbol *x, *y;
+  asection *xs, *ys;
+  const char *xn, *yn;
+  size_t xnl, ynl;
+  int xf, yf;
+
+  x = bfd_minisymbol_to_symbol (sort_bfd, sort_dynamic, P_x, sort_x);
+  y = bfd_minisymbol_to_symbol (sort_bfd, sort_dynamic, P_y, sort_y);
+  if (x == NULL || y == NULL)
+    bfd_fatal (bfd_get_filename (sort_bfd));
+
+  xs = bfd_asymbol_section (x);
+  ys = bfd_asymbol_section (y);
+
+  if (bfd_is_und_section (xs))
+    abort ();
+  if (bfd_is_und_section (ys))
+    abort ();
+
+  if (valueof (x) != valueof (y))
+    return valueof (x) < valueof (y) ? -1 : 1;
+
+  if (xs->vma != ys->vma)
+    return xs->vma < ys->vma ? -1 : 1;
+
+  xn = bfd_asymbol_name (x);
+  yn = bfd_asymbol_name (y);
+  xnl = strlen (xn);
+  ynl = strlen (yn);
+
+  /* The symbols gnu_compiled and gcc2_compiled convey even less
+     information than the file name, so sort them out first.  */
+
+  xf = (strstr (xn, "gnu_compiled") != NULL
+	|| strstr (xn, "gcc2_compiled") != NULL);
+  yf = (strstr (yn, "gnu_compiled") != NULL
+	|| strstr (yn, "gcc2_compiled") != NULL);
+
+  if (xf && ! yf)
+    return -1;
+  if (! xf && yf)
+    return 1;
+
+  /* We use a heuristic for the file name.  It may not work on non
+     Unix systems, but it doesn't really matter; the only difference
+     is precisely which symbol names get printed.  */
+
+#define file_symbol(s, sn, snl)			\
+  (((s)->flags & BSF_FILE) != 0			\
+   || ((snl) > 2				\
+       && (sn)[(snl) - 2] == '.'		\
+       && ((sn)[(snl) - 1] == 'o'		\
+	   || (sn)[(snl) - 1] == 'a')))
+
+  xf = file_symbol (x, xn, xnl);
+  yf = file_symbol (y, yn, ynl);
+
+  if (xf && ! yf)
+    return -1;
+  if (! xf && yf)
+    return 1;
+
+  return non_numeric_forward (P_x, P_y);
+}
+
+/* This sort routine is used by sort_symbols_by_size.  It is sorting
+   an array of size_sym structures into size order.  */
+
+static int
+size_forward2 (const void *P_x, const void *P_y)
+{
+  const struct size_sym *x = (const struct size_sym *) P_x;
+  const struct size_sym *y = (const struct size_sym *) P_y;
+
+  if (x->size < y->size)
+    return reverse_sort ? 1 : -1;
+  else if (x->size > y->size)
+    return reverse_sort ? -1 : 1;
+  else
+    return sorters[0][reverse_sort] (x->minisym, y->minisym);
+}
+
+/* Sort the symbols by size.  ELF provides a size but for other formats
+   we have to make a guess by assuming that the difference between the
+   address of a symbol and the address of the next higher symbol is the
+   size.  */
+
+static long
+sort_symbols_by_size (bfd *abfd, bool is_dynamic, void *minisyms,
+		      long symcount, unsigned int size,
+		      struct size_sym **symsizesp)
+{
+  struct size_sym *symsizes;
+  bfd_byte *from, *fromend;
+  asymbol *sym = NULL;
+  asymbol *store_sym, *store_next;
+
+  qsort (minisyms, symcount, size, size_forward1);
+
+  /* We are going to return a special set of symbols and sizes to
+     print.  */
+  symsizes = (struct size_sym *) xmalloc (symcount * sizeof (struct size_sym));
+  *symsizesp = symsizes;
+
+  /* Note that filter_symbols has already removed all absolute and
+     undefined symbols.  Here we remove all symbols whose size winds
+     up as zero.  */
+  from = (bfd_byte *) minisyms;
+  fromend = from + symcount * size;
+
+  store_sym = sort_x;
+  store_next = sort_y;
+
+  if (from < fromend)
+    {
+      sym = bfd_minisymbol_to_symbol (abfd, is_dynamic, (const void *) from,
+				      store_sym);
+      if (sym == NULL)
+	bfd_fatal (bfd_get_filename (abfd));
+    }
+
+  for (; from < fromend; from += size)
+    {
+      asymbol *next;
+      asection *sec;
+      bfd_vma sz;
+      asymbol *temp;
+
+      if (from + size < fromend)
+	{
+	  next = bfd_minisymbol_to_symbol (abfd,
+					   is_dynamic,
+					   (const void *) (from + size),
+					   store_next);
+	  if (next == NULL)
+	    bfd_fatal (bfd_get_filename (abfd));
+	}
+      else
+	next = NULL;
+
+      sec = bfd_asymbol_section (sym);
+
+      /* Synthetic symbols don't have a full type set of data available, thus
+	 we can't rely on that information for the symbol size.  Ditto for
+	 bfd/section.c:global_syms like *ABS*.  */
+      if ((sym->flags & (BSF_SECTION_SYM | BSF_SYNTHETIC)) == 0
+	  && bfd_get_flavour (abfd) == bfd_target_elf_flavour)
+	sz = ((elf_symbol_type *) sym)->internal_elf_sym.st_size;
+      else if ((sym->flags & (BSF_SECTION_SYM | BSF_SYNTHETIC)) == 0
+	       && bfd_is_com_section (sec))
+	sz = sym->value;
+      else
+	{
+	  if (from + size < fromend
+	      && sec == bfd_asymbol_section (next))
+	    sz = valueof (next) - valueof (sym);
+	  else
+	    sz = (bfd_section_vma (sec)
+		  + bfd_section_size (sec)
+		  - valueof (sym));
+	}
+
+      if (sz != 0)
+	{
+	  symsizes->minisym = (const void *) from;
+	  symsizes->size = sz;
+	  ++symsizes;
+	}
+
+      sym = next;
+
+      temp = store_sym;
+      store_sym = store_next;
+      store_next = temp;
+    }
+
+  symcount = symsizes - *symsizesp;
+
+  /* We must now sort again by size.  */
+  qsort ((void *) *symsizesp, symcount, sizeof (struct size_sym), size_forward2);
+
+  return symcount;
+}
+
+/* This function is used to get the relocs for a particular section.
+   It is called via bfd_map_over_sections.  */
+
+static void
+get_relocs (bfd *abfd, asection *sec, void *dataarg)
+{
+  struct get_relocs_info *data = (struct get_relocs_info *) dataarg;
+
+  *data->secs = sec;
+
+  if ((sec->flags & SEC_RELOC) == 0)
+    {
+      *data->relocs = NULL;
+      *data->relcount = 0;
+    }
+  else
+    {
+      long relsize;
+
+      relsize = bfd_get_reloc_upper_bound (abfd, sec);
+      if (relsize < 0)
+	bfd_fatal (bfd_get_filename (abfd));
+
+      *data->relocs = (arelent **) xmalloc (relsize);
+      *data->relcount = bfd_canonicalize_reloc (abfd, sec, *data->relocs,
+						data->syms);
+      if (*data->relcount < 0)
+	bfd_fatal (bfd_get_filename (abfd));
+    }
+
+  ++data->secs;
+  ++data->relocs;
+  ++data->relcount;
+}
+
+/* Print a single symbol.  */
+
+static void
+print_symbol (bfd *        abfd,
+	      asymbol *    sym,
+	      bfd_vma      ssize,
+	      bfd *        archive_bfd)
+{
+  symbol_info syminfo;
+  struct extended_symbol_info info;
+
+  PROGRESS (1);
+
+  format->print_symbol_filename (archive_bfd, abfd);
+
+  bfd_get_symbol_info (abfd, sym, &syminfo);
+
+  /* PR 22967 - Distinguish between local and global ifunc symbols.  */
+  if (syminfo.type == 'i'
+      && sym->flags & BSF_GNU_INDIRECT_FUNCTION)
+    {
+      if (ifunc_type_chars == NULL || ifunc_type_chars[0] == 0)
+	; /* Change nothing.  */
+      else if (sym->flags & BSF_GLOBAL) 
+	syminfo.type = ifunc_type_chars[0];
+      else if (ifunc_type_chars[1] != 0)
+	syminfo.type = ifunc_type_chars[1];
+    }
+
+  info.sinfo = &syminfo;
+  info.ssize = ssize;
+  /* Synthetic symbols do not have a full symbol type set of data available.
+     Nor do bfd/section.c:global_syms like *ABS*.  */
+  if ((sym->flags & (BSF_SECTION_SYM | BSF_SYNTHETIC)) != 0)
+    {
+      info.elfinfo = NULL;
+      info.coffinfo = NULL;
+    }
+  else
+    {
+      info.elfinfo = elf_symbol_from (sym);
+      info.coffinfo = coff_symbol_from (sym);
+    }
+
+  format->print_symbol_info (&info, abfd);
+
+  if (line_numbers)
+    {
+      static asymbol **syms;
+      static long symcount;
+      const char *filename, *functionname;
+      unsigned int lineno;
+
+      /* We need to get the canonical symbols in order to call
+         bfd_find_nearest_line.  This is inefficient, but, then, you
+         don't have to use --line-numbers.  */
+      if (abfd != lineno_cache_bfd && syms != NULL)
+	{
+	  free (syms);
+	  syms = NULL;
+	}
+      if (syms == NULL)
+	{
+	  long symsize;
+
+	  symsize = bfd_get_symtab_upper_bound (abfd);
+	  if (symsize < 0)
+	    bfd_fatal (bfd_get_filename (abfd));
+	  syms = (asymbol **) xmalloc (symsize);
+	  symcount = bfd_canonicalize_symtab (abfd, syms);
+	  if (symcount < 0)
+	    bfd_fatal (bfd_get_filename (abfd));
+	  lineno_cache_bfd = abfd;
+	}
+
+      if (bfd_is_und_section (bfd_asymbol_section (sym)))
+	{
+	  static asection **secs;
+	  static arelent ***relocs;
+	  static long *relcount;
+	  static unsigned int seccount;
+	  unsigned int i;
+	  const char *symname;
+
+	  /* For an undefined symbol, we try to find a reloc for the
+             symbol, and print the line number of the reloc.  */
+	  if (abfd != lineno_cache_rel_bfd && relocs != NULL)
+	    {
+	      for (i = 0; i < seccount; i++)
+		if (relocs[i] != NULL)
+		  free (relocs[i]);
+	      free (secs);
+	      free (relocs);
+	      free (relcount);
+	      secs = NULL;
+	      relocs = NULL;
+	      relcount = NULL;
+	    }
+
+	  if (relocs == NULL)
+	    {
+	      struct get_relocs_info rinfo;
+
+	      seccount = bfd_count_sections (abfd);
+
+	      secs = (asection **) xmalloc (seccount * sizeof *secs);
+	      relocs = (arelent ***) xmalloc (seccount * sizeof *relocs);
+	      relcount = (long *) xmalloc (seccount * sizeof *relcount);
+
+	      rinfo.secs = secs;
+	      rinfo.relocs = relocs;
+	      rinfo.relcount = relcount;
+	      rinfo.syms = syms;
+	      bfd_map_over_sections (abfd, get_relocs, (void *) &rinfo);
+	      lineno_cache_rel_bfd = abfd;
+	    }
+
+	  symname = bfd_asymbol_name (sym);
+	  for (i = 0; i < seccount; i++)
+	    {
+	      long j;
+
+	      for (j = 0; j < relcount[i]; j++)
+		{
+		  arelent *r;
+
+		  r = relocs[i][j];
+		  if (r->sym_ptr_ptr != NULL
+		      && (*r->sym_ptr_ptr)->section == sym->section
+		      && (*r->sym_ptr_ptr)->value == sym->value
+		      && strcmp (symname,
+				 bfd_asymbol_name (*r->sym_ptr_ptr)) == 0
+		      && bfd_find_nearest_line (abfd, secs[i], syms,
+						r->address, &filename,
+						&functionname, &lineno)
+		      && filename != NULL)
+		    {
+		      /* We only print the first one we find.  */
+		      printf ("\t%s:%u", filename, lineno);
+		      i = seccount;
+		      break;
+		    }
+		}
+	    }
+	}
+      else if (bfd_asymbol_section (sym)->owner == abfd)
+	{
+	  if ((bfd_find_line (abfd, syms, sym, &filename, &lineno)
+	       || bfd_find_nearest_line (abfd, bfd_asymbol_section (sym),
+					 syms, sym->value, &filename,
+					 &functionname, &lineno))
+	      && filename != NULL
+	      && lineno != 0)
+	    printf ("\t%s:%u", filename, lineno);
+	}
+    }
+
+  putchar ('\n');
+}
+
+/* Print the symbols when sorting by size.  */
+
+static void
+print_size_symbols (bfd *abfd,
+		    bool is_dynamic,
+		    struct size_sym *symsizes,
+		    long symcount,
+		    bfd *archive_bfd)
+{
+  asymbol *store;
+  struct size_sym *from;
+  struct size_sym *fromend;
+
+  store = bfd_make_empty_symbol (abfd);
+  if (store == NULL)
+    bfd_fatal (bfd_get_filename (abfd));
+
+  from = symsizes;
+  fromend = from + symcount;
+
+  for (; from < fromend; from++)
+    {
+      asymbol *sym;
+
+      sym = bfd_minisymbol_to_symbol (abfd, is_dynamic, from->minisym, store);
+      if (sym == NULL)
+	bfd_fatal (bfd_get_filename (abfd));
+
+      print_symbol (abfd, sym, from->size, archive_bfd);
+    }
+}
+
+
+/* Print the symbols of ABFD that are held in MINISYMS.
+
+   If ARCHIVE_BFD is non-NULL, it is the archive containing ABFD.
+
+   SYMCOUNT is the number of symbols in MINISYMS.
+
+   SIZE is the size of a symbol in MINISYMS.  */
+
+static void
+print_symbols (bfd *abfd,
+	       bool is_dynamic,
+	       void *minisyms,
+	       long symcount,
+	       unsigned int size,
+	       bfd *archive_bfd)
+{
+  asymbol *store;
+  bfd_byte *from;
+  bfd_byte *fromend;
+
+  store = bfd_make_empty_symbol (abfd);
+  if (store == NULL)
+    bfd_fatal (bfd_get_filename (abfd));
+
+  from = (bfd_byte *) minisyms;
+  fromend = from + symcount * size;
+
+  for (; from < fromend; from += size)
+    {
+      asymbol *sym;
+
+      sym = bfd_minisymbol_to_symbol (abfd, is_dynamic, from, store);
+      if (sym == NULL)
+	bfd_fatal (bfd_get_filename (abfd));
+
+      print_symbol (abfd, sym, (bfd_vma) 0, archive_bfd);
+    }
+}
+
+/* If ARCHIVE_BFD is non-NULL, it is the archive containing ABFD.  */
+
+static void
+display_rel_file (bfd *abfd, bfd *archive_bfd)
+{
+  long symcount;
+  void *minisyms;
+  unsigned int size;
+  struct size_sym *symsizes;
+  asymbol *synthsyms = NULL;
+
+  if (! dynamic)
+    {
+      if (!(bfd_get_file_flags (abfd) & HAS_SYMS))
+	{
+	  if (!quiet)
+	    non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
+	  return;
+	}
+    }
+
+  symcount = bfd_read_minisymbols (abfd, dynamic, &minisyms, &size);
+  if (symcount < 0)
+    {
+      if (dynamic && bfd_get_error () == bfd_error_no_symbols)
+	{
+	  if (!quiet)
+	    non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
+	  return;
+	}
+
+      bfd_fatal (bfd_get_filename (abfd));
+    }
+
+  if (symcount == 0)
+    {
+      if (!quiet)
+	non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
+      return;
+    }
+
+  if (show_synthetic && size == sizeof (asymbol *))
+    {
+      asymbol **static_syms = NULL;
+      asymbol **dyn_syms = NULL;
+      long static_count = 0;
+      long dyn_count = 0;
+      long synth_count;
+
+      if (dynamic)
+	{
+	  dyn_count = symcount;
+	  dyn_syms = (asymbol **) minisyms;
+	}
+      else
+	{
+	  long storage = bfd_get_dynamic_symtab_upper_bound (abfd);
+
+	  static_count = symcount;
+	  static_syms = (asymbol **) minisyms;
+
+	  if (storage > 0)
+	    {
+	      dyn_syms = (asymbol **) xmalloc (storage);
+	      dyn_count = bfd_canonicalize_dynamic_symtab (abfd, dyn_syms);
+	      if (dyn_count < 0)
+		bfd_fatal (bfd_get_filename (abfd));
+	    }
+	}
+
+      synth_count = bfd_get_synthetic_symtab (abfd, static_count, static_syms,
+					      dyn_count, dyn_syms, &synthsyms);
+      if (synth_count > 0)
+	{
+	  asymbol **symp;
+	  long i;
+
+	  minisyms = xrealloc (minisyms,
+			       (symcount + synth_count + 1) * sizeof (*symp));
+	  symp = (asymbol **) minisyms + symcount;
+	  for (i = 0; i < synth_count; i++)
+	    *symp++ = synthsyms + i;
+	  *symp = 0;
+	  symcount += synth_count;
+	}
+      if (!dynamic && dyn_syms != NULL)
+	free (dyn_syms);
+    }
+
+  /* lto_slim_object is set to false when a bfd is loaded with a compiler
+     LTO plugin.  */
+  if (abfd->lto_slim_object)
+    {
+      report_plugin_err = false;
+      non_fatal (_("%s: plugin needed to handle lto object"),
+		 bfd_get_filename (abfd));
+    }
+
+  /* Discard the symbols we don't want to print.
+     It's OK to do this in place; we'll free the storage anyway
+     (after printing).  */
+
+  symcount = filter_symbols (abfd, dynamic, minisyms, symcount, size);
+
+  symsizes = NULL;
+  if (! no_sort)
+    {
+      sort_bfd = abfd;
+      sort_dynamic = dynamic;
+      sort_x = bfd_make_empty_symbol (abfd);
+      sort_y = bfd_make_empty_symbol (abfd);
+      if (sort_x == NULL || sort_y == NULL)
+	bfd_fatal (bfd_get_filename (abfd));
+
+      if (! sort_by_size)
+	qsort (minisyms, symcount, size,
+	       sorters[sort_numerically][reverse_sort]);
+      else
+	symcount = sort_symbols_by_size (abfd, dynamic, minisyms, symcount,
+					 size, &symsizes);
+    }
+
+  if (! sort_by_size)
+    print_symbols (abfd, dynamic, minisyms, symcount, size, archive_bfd);
+  else
+    print_size_symbols (abfd, dynamic, symsizes, symcount, archive_bfd);
+
+  if (synthsyms)
+    free (synthsyms);
+  free (minisyms);
+  free (symsizes);
+}
+
+/* Construct a formatting string for printing symbol values.  */
+
+static const char *
+get_print_format (void)
+{
+  const char * padding;
+  if (print_format == FORMAT_POSIX || print_format == FORMAT_JUST_SYMBOLS)
+    {
+      /* POSIX compatible output does not have any padding.  */
+      padding = "";
+    }
+  else if (print_width == 32)
+    {
+      padding ="08";
+    }
+  else /* print_width == 64 */
+    {
+      padding = "016";
+    }
+
+  const char * length = "l";
+  if (print_width == 64)
+    {
+#if BFD_HOST_64BIT_LONG
+      ;
+#elif BFD_HOST_64BIT_LONG_LONG
+#ifndef __MSVCRT__
+      length = "ll";
+#else
+      length = "I64";
+#endif
+#endif
+    }
+
+  const char * radix = NULL;
+  switch (print_radix)
+    {
+    case 8:  radix = "o"; break;
+    case 10: radix = "d"; break;
+    case 16: radix = "x"; break;
+    }
+
+  return concat ("%", padding, length, radix, NULL);
+}
+
+static void
+set_print_width (bfd *file)
+{
+  print_width = bfd_get_arch_size (file);
+
+  if (print_width == -1)
+    {
+      /* PR binutils/4292
+	 Guess the target's bitsize based on its name.
+	 We assume here than any 64-bit format will include
+	 "64" somewhere in its name.  The only known exception
+	 is the MMO object file format.  */
+      if (strstr (bfd_get_target (file), "64") != NULL
+	  || strcmp (bfd_get_target (file), "mmo") == 0)
+	print_width = 64;
+      else
+	print_width = 32;
+    }
+  free ((char *) print_format_string);
+  print_format_string = get_print_format ();
+}
+
+static void
+display_archive (bfd *file)
+{
+  bfd *arfile = NULL;
+  bfd *last_arfile = NULL;
+  char **matching;
+
+  format->print_archive_filename (bfd_get_filename (file));
+
+  if (print_armap)
+    print_symdef_entry (file);
+
+  for (;;)
+    {
+      PROGRESS (1);
+
+      arfile = bfd_openr_next_archived_file (file, arfile);
+
+      if (arfile == NULL)
+	{
+	  if (bfd_get_error () != bfd_error_no_more_archived_files)
+	    bfd_fatal (bfd_get_filename (file));
+	  break;
+	}
+
+      if (bfd_check_format_matches (arfile, bfd_object, &matching))
+	{
+	  set_print_width (arfile);
+	  format->print_archive_member (bfd_get_filename (file),
+					bfd_get_filename (arfile));
+	  display_rel_file (arfile, file);
+	}
+      else
+	{
+	  bfd_nonfatal (bfd_get_filename (arfile));
+	  if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
+	    {
+	      list_matching_formats (matching);
+	      free (matching);
+	    }
+	}
+
+      if (last_arfile != NULL)
+	{
+	  bfd_close (last_arfile);
+	  lineno_cache_bfd = NULL;
+	  lineno_cache_rel_bfd = NULL;
+	  if (arfile == last_arfile)
+	    return;
+	}
+      last_arfile = arfile;
+    }
+
+  if (last_arfile != NULL)
+    {
+      bfd_close (last_arfile);
+      lineno_cache_bfd = NULL;
+      lineno_cache_rel_bfd = NULL;
+    }
+}
+
+static bool
+display_file (char *filename)
+{
+  bool retval = true;
+  bfd *file;
+  char **matching;
+
+  if (get_file_size (filename) < 1)
+    return false;
+
+  file = bfd_openr (filename, target ? target : plugin_target);
+  if (file == NULL)
+    {
+      bfd_nonfatal (filename);
+      return false;
+    }
+
+  /* If printing line numbers, decompress the debug sections.  */
+  if (line_numbers)
+    file->flags |= BFD_DECOMPRESS;
+
+  if (bfd_check_format (file, bfd_archive))
+    {
+      display_archive (file);
+    }
+  else if (bfd_check_format_matches (file, bfd_object, &matching))
+    {
+      set_print_width (file);
+      format->print_object_filename (filename);
+      display_rel_file (file, NULL);
+    }
+  else
+    {
+      bfd_nonfatal (filename);
+      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
+	{
+	  list_matching_formats (matching);
+	  free (matching);
+	}
+      retval = false;
+    }
+
+  if (!bfd_close (file))
+    bfd_fatal (filename);
+
+  lineno_cache_bfd = NULL;
+  lineno_cache_rel_bfd = NULL;
+
+  return retval;
+}
+
+/* The following 3 groups of functions are called unconditionally,
+   once at the start of processing each file of the appropriate type.
+   They should check `filename_per_file' and `filename_per_symbol',
+   as appropriate for their output format, to determine whether to
+   print anything.  */
+
+/* Print the name of an object file given on the command line.  */
+
+static void
+print_object_filename_bsd (const char *filename)
+{
+  if (filename_per_file && !filename_per_symbol)
+    printf ("\n%s:\n", filename);
+}
+
+static void
+print_object_filename_sysv (const char *filename)
+{
+  if (undefined_only)
+    printf (_("\n\nUndefined symbols from %s:\n\n"), filename);
+  else
+    printf (_("\n\nSymbols from %s:\n\n"), filename);
+  if (print_width == 32)
+    printf (_("\
+Name                  Value   Class        Type         Size     Line  Section\n\n"));
+  else
+    printf (_("\
+Name                  Value           Class        Type         Size             Line  Section\n\n"));
+}
+
+static void
+print_object_filename_posix (const char *filename)
+{
+  if (filename_per_file && !filename_per_symbol)
+    printf ("%s:\n", filename);
+}
+
+static void
+do_not_print_object_filename (const char *filename ATTRIBUTE_UNUSED)
+{
+}
+
+/* Print the name of an archive file given on the command line.  */
+
+static void
+print_archive_filename_bsd (const char *filename)
+{
+  if (filename_per_file)
+    printf ("\n%s:\n", filename);
+}
+
+static void
+print_archive_filename_sysv (const char *filename ATTRIBUTE_UNUSED)
+{
+}
+
+static void
+print_archive_filename_posix (const char *filename ATTRIBUTE_UNUSED)
+{
+}
+
+static void
+do_not_print_archive_filename (const char *filename ATTRIBUTE_UNUSED)
+{
+}
+
+/* Print the name of an archive member file.  */
+
+static void
+print_archive_member_bsd (const char *archive ATTRIBUTE_UNUSED,
+			  const char *filename)
+{
+  if (!filename_per_symbol)
+    printf ("\n%s:\n", filename);
+}
+
+static void
+print_archive_member_sysv (const char *archive, const char *filename)
+{
+  if (undefined_only)
+    printf (_("\n\nUndefined symbols from %s[%s]:\n\n"), archive, filename);
+  else
+    printf (_("\n\nSymbols from %s[%s]:\n\n"), archive, filename);
+  if (print_width == 32)
+    printf (_("\
+Name                  Value   Class        Type         Size     Line  Section\n\n"));
+  else
+    printf (_("\
+Name                  Value           Class        Type         Size             Line  Section\n\n"));
+}
+
+static void
+print_archive_member_posix (const char *archive, const char *filename)
+{
+  if (!filename_per_symbol)
+    printf ("%s[%s]:\n", archive, filename);
+}
+
+static void
+do_not_print_archive_member (const char *archive ATTRIBUTE_UNUSED,
+			     const char *filename ATTRIBUTE_UNUSED)
+{
+}
+
+
+/* Print the name of the file (and archive, if there is one)
+   containing a symbol.  */
+
+static void
+print_symbol_filename_bsd (bfd *archive_bfd, bfd *abfd)
+{
+  if (filename_per_symbol)
+    {
+      if (archive_bfd)
+	printf ("%s:", bfd_get_filename (archive_bfd));
+      printf ("%s:", bfd_get_filename (abfd));
+    }
+}
+
+static void
+print_symbol_filename_sysv (bfd *archive_bfd, bfd *abfd)
+{
+  if (filename_per_symbol)
+    {
+      if (archive_bfd)
+	printf ("%s:", bfd_get_filename (archive_bfd));
+      printf ("%s:", bfd_get_filename (abfd));
+    }
+}
+
+static void
+print_symbol_filename_posix (bfd *archive_bfd, bfd *abfd)
+{
+  if (filename_per_symbol)
+    {
+      if (archive_bfd)
+	printf ("%s[%s]: ", bfd_get_filename (archive_bfd),
+		bfd_get_filename (abfd));
+      else
+	printf ("%s: ", bfd_get_filename (abfd));
+    }
+}
+
+static void
+do_not_print_symbol_filename (bfd *archive_bfd ATTRIBUTE_UNUSED,
+			      bfd *abfd ATTRIBUTE_UNUSED)
+{
+}
+
+
+/* Print a symbol value.  */
+
+static void
+print_value (bfd *abfd ATTRIBUTE_UNUSED, bfd_vma val)
+{
+  switch (print_width)
+    {
+    case 32:
+      printf (print_format_string, (unsigned long) val);
+      break;
+
+    case 64:
+#if BFD_HOST_64BIT_LONG || BFD_HOST_64BIT_LONG_LONG
+      printf (print_format_string, val);
+#else
+      /* We have a 64 bit value to print, but the host is only 32 bit.  */
+      if (print_radix == 16)
+	bfd_fprintf_vma (abfd, stdout, val);
+      else
+	{
+	  char buf[30];
+	  char *s;
+
+	  s = buf + sizeof buf;
+	  *--s = '\0';
+	  while (val > 0)
+	    {
+	      *--s = (val % print_radix) + '0';
+	      val /= print_radix;
+	    }
+	  while ((buf + sizeof buf - 1) - s < 16)
+	    *--s = '0';
+	  printf ("%s", s);
+	}
+#endif
+      break;
+
+    default:
+      fatal (_("Print width has not been initialized (%d)"), print_width);
+      break;
+    }
+}
+
+/* Print a line of information about a symbol.  */
+
+static void
+print_symbol_info_bsd (struct extended_symbol_info *info, bfd *abfd)
+{
+  if (bfd_is_undefined_symclass (SYM_TYPE (info)))
+    {
+      if (print_width == 64)
+	printf ("        ");
+      printf ("        ");
+    }
+  else
+    {
+      /* Normally we print the value of the symbol.  If we are printing the
+	 size or sorting by size then we print its size, except for the
+	 (weird) special case where both flags are defined, in which case we
+	 print both values.  This conforms to documented behaviour.  */
+      if (sort_by_size && !print_size)
+	print_value (abfd, SYM_SIZE (info));
+      else
+	print_value (abfd, SYM_VALUE (info));
+      if (print_size && SYM_SIZE (info))
+	{
+	  printf (" ");
+	  print_value (abfd, SYM_SIZE (info));
+	}
+    }
+
+  printf (" %c", SYM_TYPE (info));
+
+  if (SYM_TYPE (info) == '-')
+    {
+      /* A stab.  */
+      printf (" ");
+      printf (other_format, SYM_STAB_OTHER (info));
+      printf (" ");
+      printf (desc_format, SYM_STAB_DESC (info));
+      printf (" %5s", SYM_STAB_NAME (info));
+    }
+  print_symname (" %s", info, NULL, abfd);
+}
+
+static void
+print_symbol_info_sysv (struct extended_symbol_info *info, bfd *abfd)
+{
+  print_symname ("%-20s|", info, NULL, abfd);
+
+  if (bfd_is_undefined_symclass (SYM_TYPE (info)))
+    {
+      if (print_width == 32)
+	printf ("        ");
+      else
+	printf ("                ");
+    }
+  else
+    print_value (abfd, SYM_VALUE (info));
+
+  printf ("|   %c  |", SYM_TYPE (info));
+
+  if (SYM_TYPE (info) == '-')
+    {
+      /* A stab.  */
+      printf ("%18s|  ", SYM_STAB_NAME (info));		/* (C) Type.  */
+      printf (desc_format, SYM_STAB_DESC (info));	/* Size.  */
+      printf ("|     |");				/* Line, Section.  */
+    }
+  else
+    {
+      /* Type, Size, Line, Section */
+      if (info->elfinfo)
+	printf ("%18s|",
+		get_elf_symbol_type (ELF_ST_TYPE (info->elfinfo->internal_elf_sym.st_info)));
+      else if (info->coffinfo)
+	printf ("%18s|",
+		get_coff_symbol_type (&info->coffinfo->native->u.syment));
+      else
+	printf ("                  |");
+
+      if (SYM_SIZE (info))
+	print_value (abfd, SYM_SIZE (info));
+      else
+	{
+	  if (print_width == 32)
+	    printf ("        ");
+	  else
+	    printf ("                ");
+	}
+
+      if (info->elfinfo)
+	printf("|     |%s", info->elfinfo->symbol.section->name);
+      else if (info->coffinfo)
+	printf("|     |%s", info->coffinfo->symbol.section->name);
+      else
+	printf("|     |");
+    }
+}
+
+static void
+print_symbol_info_posix (struct extended_symbol_info *info, bfd *abfd)
+{
+  print_symname ("%s ", info, NULL, abfd);
+  printf ("%c ", SYM_TYPE (info));
+
+  if (bfd_is_undefined_symclass (SYM_TYPE (info)))
+    printf ("        ");
+  else
+    {
+      print_value (abfd, SYM_VALUE (info));
+      printf (" ");
+      if (SYM_SIZE (info))
+	print_value (abfd, SYM_SIZE (info));
+    }
+}
+
+static void
+just_print_symbol_name (struct extended_symbol_info *info, bfd *abfd)
+{
+  print_symname ("%s", info, NULL, abfd);
+}
+
+int
+main (int argc, char **argv)
+{
+  int c;
+  int retval;
+
+#ifdef HAVE_LC_MESSAGES
+  setlocale (LC_MESSAGES, "");
+#endif
+  setlocale (LC_CTYPE, "");
+  setlocale (LC_COLLATE, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+
+  program_name = *argv;
+  xmalloc_set_program_name (program_name);
+  bfd_set_error_program_name (program_name);
+#if BFD_SUPPORTS_PLUGINS
+  bfd_plugin_set_program_name (program_name);
+#endif
+
+  START_PROGRESS (program_name, 0);
+
+  expandargv (&argc, &argv);
+
+  if (bfd_init () != BFD_INIT_MAGIC)
+    fatal (_("fatal error: libbfd ABI mismatch"));
+  set_default_bfd_target ();
+
+  while ((c = getopt_long (argc, argv, "aABCDef:gHhjJlnopPrSst:uvVvX:",
+			   long_options, (int *) 0)) != EOF)
+    {
+      switch (c)
+	{
+	case 'a':
+	  print_debug_syms = 1;
+	  break;
+	case 'A':
+	case 'o':
+	  filename_per_symbol = 1;
+	  break;
+	case 'B':		/* For MIPS compatibility.  */
+	  set_output_format ("bsd");
+	  break;
+	case 'C':
+	  do_demangle = 1;
+	  if (optarg != NULL)
+	    {
+	      enum demangling_styles style;
+
+	      style = cplus_demangle_name_to_style (optarg);
+	      if (style == unknown_demangling)
+		fatal (_("unknown demangling style `%s'"),
+		       optarg);
+
+	      cplus_demangle_set_style (style);
+	    }
+	  break;
+	case OPTION_RECURSE_LIMIT:
+	  demangle_flags &= ~ DMGL_NO_RECURSE_LIMIT;
+	  break;
+	case OPTION_NO_RECURSE_LIMIT:
+	  demangle_flags |= DMGL_NO_RECURSE_LIMIT;
+	  break;
+	case OPTION_QUIET:
+	  quiet = 1;
+	  break;
+	case 'D':
+	  dynamic = 1;
+	  break;
+	case 'e':
+	  /* Ignored for HP/UX compatibility.  */
+	  break;
+	case 'f':
+	  set_output_format (optarg);
+	  break;
+	case 'g':
+	  external_only = 1;
+	  break;
+	case 'H':
+	case 'h':
+	  usage (stdout, 0);
+	case 'l':
+	  line_numbers = 1;
+	  break;
+	case 'n':
+	case 'v':
+	  no_sort = 0;
+	  sort_numerically = 1;
+	  sort_by_size = 0;
+	  break;
+	case 'p':
+	  no_sort = 1;
+	  sort_numerically = 0;
+	  sort_by_size = 0;
+	  break;
+	case OPTION_SIZE_SORT:
+	  no_sort = 0;
+	  sort_numerically = 0;
+	  sort_by_size = 1;
+	  break;
+	case 'P':
+	  set_output_format ("posix");
+	  break;
+	case 'j':
+	  set_output_format ("just-symbols");
+	  break;
+	case 'r':
+	  reverse_sort = 1;
+	  break;
+	case 's':
+	  print_armap = 1;
+	  break;
+	case 'S':
+	  print_size = 1;
+	  break;
+	case 't':
+	  set_print_radix (optarg);
+	  break;
+	case 'u':
+	  undefined_only = 1;
+	  break;
+	case 'V':
+	  show_version = 1;
+	  break;
+	case 'X':
+	  /* Ignored for (partial) AIX compatibility.  On AIX, the
+	     argument has values 32, 64, or 32_64, and specifies that
+	     only 32-bit, only 64-bit, or both kinds of objects should
+	     be examined.  The default is 32.  So plain AIX nm on a
+	     library archive with both kinds of objects will ignore
+	     the 64-bit ones.  For GNU nm, the default is and always
+	     has been -X 32_64, and other options are not supported.  */
+	  if (strcmp (optarg, "32_64") != 0)
+	    fatal (_("Only -X 32_64 is supported"));
+	  break;
+
+	case OPTION_TARGET:	/* --target */
+	  target = optarg;
+	  break;
+
+	case OPTION_PLUGIN:	/* --plugin */
+#if BFD_SUPPORTS_PLUGINS
+	  bfd_plugin_set_plugin (optarg);
+#else
+	  fatal (_("sorry - this program has been built without plugin support\n"));
+#endif
+	  break;
+
+	case OPTION_IFUNC_CHARS:
+	  ifunc_type_chars = optarg;
+	  break;
+
+	case 0:		/* A long option that just sets a flag.  */
+	  break;
+
+	default:
+	  usage (stderr, 1);
+	}
+    }
+
+  if (show_version)
+    print_version ("nm");
+
+  if (sort_by_size && undefined_only)
+    {
+      non_fatal (_("Using the --size-sort and --undefined-only options together"));
+      non_fatal (_("will produce no output, since undefined symbols have no size."));
+      return 0;
+    }
+
+  /* OK, all options now parsed.  If no filename specified, do a.out.  */
+  if (optind == argc)
+    return !display_file ("a.out");
+
+  retval = 0;
+
+  if (argc - optind > 1)
+    filename_per_file = 1;
+
+  /* We were given several filenames to do.  */
+  while (optind < argc)
+    {
+      PROGRESS (1);
+      if (!display_file (argv[optind++]))
+	retval++;
+    }
+
+  END_PROGRESS (program_name);
+
+  exit (retval);
+  return retval;
+}
diff -rupN binutils.orig/binutils/objdump.c binutils-2.37/binutils/objdump.c
--- binutils.orig/binutils/objdump.c	2021-11-09 12:34:21.662802941 +0000
+++ binutils-2.37/binutils/objdump.c	2021-11-09 12:40:53.084208435 +0000
@@ -204,6 +204,18 @@ static const struct objdump_private_desc
 
 /* The list of detected jumps inside a function.  */
 static struct jump_info *detected_jumps = NULL;
+
+typedef enum unicode_display_type
+{
+  unicode_default = 0,
+  unicode_locale,
+  unicode_escape,
+  unicode_hex,
+  unicode_highlight,
+  unicode_invalid
+} unicode_display_type;
+
+static unicode_display_type unicode_display = unicode_default;
 
 static void usage (FILE *, int) ATTRIBUTE_NORETURN;
 static void
@@ -330,6 +342,9 @@ usage (FILE *stream, int status)
       fprintf (stream, _("\
   -w, --wide                     Format output for more than 80 columns\n"));
       fprintf (stream, _("\
+  -U[d|l|i|x|e|h]                Controls the display of UTF-8 unicode characters\n\
+  --unicode=[default|locale|invalid|hex|escape|highlight]\n"));
+      fprintf (stream, _("\
   -z, --disassemble-zeroes       Do not skip blocks of zeroes when disassembling\n"));
       fprintf (stream, _("\
       --start-address=ADDR       Only process data whose address is >= ADDR\n"));
@@ -420,17 +435,23 @@ static struct option long_options[]=
 {
   {"adjust-vma", required_argument, NULL, OPTION_ADJUST_VMA},
   {"all-headers", no_argument, NULL, 'x'},
-  {"private-headers", no_argument, NULL, 'p'},
-  {"private", required_argument, NULL, 'P'},
   {"architecture", required_argument, NULL, 'm'},
   {"archive-headers", no_argument, NULL, 'a'},
+#ifdef ENABLE_LIBCTF
+  {"ctf", required_argument, NULL, OPTION_CTF},
+  {"ctf-parent", required_argument, NULL, OPTION_CTF_PARENT},
+#endif
   {"debugging", no_argument, NULL, 'g'},
   {"debugging-tags", no_argument, NULL, 'e'},
   {"demangle", optional_argument, NULL, 'C'},
   {"disassemble", optional_argument, NULL, 'd'},
   {"disassemble-all", no_argument, NULL, 'D'},
-  {"disassembler-options", required_argument, NULL, 'M'},
   {"disassemble-zeroes", no_argument, NULL, 'z'},
+  {"disassembler-options", required_argument, NULL, 'M'},
+  {"dwarf", optional_argument, NULL, OPTION_DWARF},
+  {"dwarf-check", no_argument, 0, OPTION_DWARF_CHECK},
+  {"dwarf-depth", required_argument, 0, OPTION_DWARF_DEPTH},
+  {"dwarf-start", required_argument, 0, OPTION_DWARF_START},
   {"dynamic-reloc", no_argument, NULL, 'R'},
   {"dynamic-syms", no_argument, NULL, 'T'},
   {"endian", required_argument, NULL, OPTION_ENDIAN},
@@ -440,16 +461,23 @@ static struct option long_options[]=
   {"full-contents", no_argument, NULL, 's'},
   {"headers", no_argument, NULL, 'h'},
   {"help", no_argument, NULL, 'H'},
+  {"include", required_argument, NULL, 'I'},
   {"info", no_argument, NULL, 'i'},
+  {"inlines", no_argument, 0, OPTION_INLINES},
+  {"insn-width", required_argument, NULL, OPTION_INSN_WIDTH},
   {"line-numbers", no_argument, NULL, 'l'},
-  {"no-show-raw-insn", no_argument, &show_raw_insn, -1},
   {"no-addresses", no_argument, &no_addresses, 1},
-  {"process-links", no_argument, &process_links, true},
+  {"no-recurse-limit", no_argument, NULL, OPTION_NO_RECURSE_LIMIT},
+  {"no-recursion-limit", no_argument, NULL, OPTION_NO_RECURSE_LIMIT},
+  {"no-show-raw-insn", no_argument, &show_raw_insn, -1},
+  {"prefix", required_argument, NULL, OPTION_PREFIX},
   {"prefix-addresses", no_argument, &prefix_addresses, 1},
+  {"prefix-strip", required_argument, NULL, OPTION_PREFIX_STRIP},
+  {"private", required_argument, NULL, 'P'},
+  {"private-headers", no_argument, NULL, 'p'},
+  {"process-links", no_argument, &process_links, true},
   {"recurse-limit", no_argument, NULL, OPTION_RECURSE_LIMIT},
   {"recursion-limit", no_argument, NULL, OPTION_RECURSE_LIMIT},
-  {"no-recurse-limit", no_argument, NULL, OPTION_NO_RECURSE_LIMIT},
-  {"no-recursion-limit", no_argument, NULL, OPTION_NO_RECURSE_LIMIT},
   {"reloc", no_argument, NULL, 'r'},
   {"section", required_argument, NULL, 'j'},
   {"section-headers", no_argument, NULL, 'h'},
@@ -457,28 +485,16 @@ static struct option long_options[]=
   {"source", no_argument, NULL, 'S'},
   {"source-comment", optional_argument, NULL, OPTION_SOURCE_COMMENT},
   {"special-syms", no_argument, &dump_special_syms, 1},
-  {"include", required_argument, NULL, 'I'},
-  {"dwarf", optional_argument, NULL, OPTION_DWARF},
-#ifdef ENABLE_LIBCTF
-  {"ctf", required_argument, NULL, OPTION_CTF},
-  {"ctf-parent", required_argument, NULL, OPTION_CTF_PARENT},
-#endif
   {"stabs", no_argument, NULL, 'G'},
   {"start-address", required_argument, NULL, OPTION_START_ADDRESS},
   {"stop-address", required_argument, NULL, OPTION_STOP_ADDRESS},
   {"syms", no_argument, NULL, 't'},
   {"target", required_argument, NULL, 'b'},
+  {"unicode", required_argument, NULL, 'U'},
   {"version", no_argument, NULL, 'V'},
-  {"wide", no_argument, NULL, 'w'},
-  {"prefix", required_argument, NULL, OPTION_PREFIX},
-  {"prefix-strip", required_argument, NULL, OPTION_PREFIX_STRIP},
-  {"insn-width", required_argument, NULL, OPTION_INSN_WIDTH},
-  {"dwarf-depth", required_argument, 0, OPTION_DWARF_DEPTH},
-  {"dwarf-start", required_argument, 0, OPTION_DWARF_START},
-  {"dwarf-check", no_argument, 0, OPTION_DWARF_CHECK},
-  {"inlines", no_argument, 0, OPTION_INLINES},
   {"visualize-jumps", optional_argument, 0, OPTION_VISUALIZE_JUMPS},
-  {0, no_argument, 0, 0}
+  {"wide", no_argument, NULL, 'w'},
+  {NULL, no_argument, NULL, 0}
 };
 
 static void
@@ -488,9 +504,121 @@ nonfatal (const char *msg)
   exit_status = 1;
 }
 
+/* Convert a potential UTF-8 encoded sequence in IN into characters in OUT.
+   The conversion format is controlled by the unicode_display variable.
+   Returns the number of characters added to OUT.
+   Returns the number of bytes consumed from IN in CONSUMED.
+   Always consumes at least one byte and displays at least one character.  */
+   
+static unsigned int
+display_utf8 (const unsigned char * in, char * out, unsigned int * consumed)
+{
+  char *        orig_out = out;
+  unsigned int  nchars = 0;
+  unsigned int j;
+
+  if (unicode_display == unicode_default)
+    goto invalid;
+
+  if (in[0] < 0xc0)
+    goto invalid;
+
+  if ((in[1] & 0xc0) != 0x80)
+    goto invalid;
+
+  if ((in[0] & 0x20) == 0)
+    {
+      nchars = 2;
+      goto valid;
+    }
+
+  if ((in[2] & 0xc0) != 0x80)
+    goto invalid;
+
+  if ((in[0] & 0x10) == 0)
+    {
+      nchars = 3;
+      goto valid;
+    }
+
+  if ((in[3] & 0xc0) != 0x80)
+    goto invalid;
+
+  nchars = 4;
+
+ valid:
+  switch (unicode_display)
+    {
+    case unicode_locale:
+      /* Copy the bytes into the output buffer as is.  */
+      memcpy (out, in, nchars);
+      out += nchars;
+      break;
+
+    case unicode_invalid:
+    case unicode_hex:
+      out += sprintf (out, "%c", unicode_display == unicode_hex ? '<' : '{');
+      out += sprintf (out, "0x");
+      for (j = 0; j < nchars; j++)
+	out += sprintf (out, "%02x", in [j]);
+      out += sprintf (out, "%c", unicode_display == unicode_hex ? '>' : '}');
+      break;
+      
+    case unicode_highlight:
+      if (isatty (1))
+	out += sprintf (out, "\x1B[31;47m"); /* Red.  */
+      /* Fall through.  */
+    case unicode_escape:
+      switch (nchars)
+	{
+	case 2:
+	  out += sprintf (out, "\\u%02x%02x",
+		  ((in[0] & 0x1c) >> 2), 
+		  ((in[0] & 0x03) << 6) | (in[1] & 0x3f));
+	  break;
+
+	case 3:
+	  out += sprintf (out, "\\u%02x%02x",
+		  ((in[0] & 0x0f) << 4) | ((in[1] & 0x3c) >> 2),
+		  ((in[1] & 0x03) << 6) | ((in[2] & 0x3f)));
+	  break;
+
+	case 4:
+	  out += sprintf (out, "\\u%02x%02x%02x",
+		  ((in[0] & 0x07) << 6) | ((in[1] & 0x3c) >> 2),
+		  ((in[1] & 0x03) << 6) | ((in[2] & 0x3c) >> 2),
+		  ((in[2] & 0x03) << 6) | ((in[3] & 0x3f)));
+	  break;
+	default:
+	  /* URG.  */
+	  break;
+	}
+
+      if (unicode_display == unicode_highlight && isatty (1))
+	out += sprintf (out, "\033[0m"); /* Default colour.  */
+      break;
+
+    default:
+      /* URG */
+      break;
+    }
+
+  * consumed = nchars;
+  return out - orig_out;
+
+ invalid:
+  /* Not a valid UTF-8 sequence.  */
+  *out = *in;
+  * consumed = 1;
+  return 1;
+}
+
 /* Returns a version of IN with any control characters
    replaced by escape sequences.  Uses a static buffer
-   if necessary.  */
+   if necessary.
+
+   If unicode display is enabled, then also handles the
+   conversion of unicode characters.  */
 
 static const char *
 sanitize_string (const char * in)
@@ -508,40 +636,50 @@ sanitize_string (const char * in)
      of cases it will not be needed.  */
   do
     {
-      char c = *in++;
+      unsigned char c = *in++;
 
       if (c == 0)
 	return original;
 
       if (ISCNTRL (c))
 	break;
+
+      if (unicode_display != unicode_default && c >= 0xc0)
+	break;
     }
   while (1);
 
   /* Copy the input, translating as needed.  */
   in = original;
-  if (buffer_len < (strlen (in) * 2))
+  if (buffer_len < (strlen (in) * 9))
     {
       free ((void *) buffer);
-      buffer_len = strlen (in) * 2;
+      buffer_len = strlen (in) * 9;
       buffer = xmalloc (buffer_len + 1);
     }
 
   out = buffer;
   do
     {
-      char c = *in++;
+      unsigned char c = *in++;
 
       if (c == 0)
 	break;
 
-      if (!ISCNTRL (c))
-	*out++ = c;
-      else
+      if (ISCNTRL (c))
 	{
 	  *out++ = '^';
 	  *out++ = c + 0x40;
 	}
+      else if (unicode_display != unicode_default && c >= 0xc0)
+	{
+	  unsigned int num_consumed;
+
+	  out += display_utf8 ((const unsigned char *)(in - 1), out, & num_consumed);
+	  in += num_consumed - 1;
+	}
+      else
+	*out++ = c;
     }
   while (1);
 
@@ -4529,6 +4667,24 @@ dump_symbols (bfd *abfd ATTRIBUTE_UNUSED
 		  free (alloc);
 		}
 	    }
+	  else if (unicode_display != unicode_default
+		   && name != NULL && *name != '\0')
+	    {
+	      const char * sanitized_name;
+
+	      /* If we want to sanitize the name, we do it here, and
+		 temporarily clobber it while calling bfd_print_symbol.
+		 FIXME: This is a gross hack.  */
+	      sanitized_name = sanitize_string (name);
+	      if (sanitized_name != name)
+		(*current)->name = sanitized_name;
+	      else
+		sanitized_name = NULL;
+	      bfd_print_symbol (cur_bfd, stdout, *current,
+				bfd_print_symbol_all);
+	      if (sanitized_name != NULL)
+		(*current)->name = name;
+	    }
 	  else
 	    bfd_print_symbol (cur_bfd, stdout, *current,
 			      bfd_print_symbol_all);
@@ -5212,7 +5368,7 @@ main (int argc, char **argv)
   set_default_bfd_target ();
 
   while ((c = getopt_long (argc, argv,
-			   "pP:ib:m:M:VvCdDlfFaHhrRtTxsSI:j:wE:zgeGW::",
+			   "pP:ib:m:M:VvCdDlfFaHhrRtTU:xsSI:j:wE:zgeGW::",
 			   long_options, (int *) 0))
 	 != EOF)
     {
@@ -5495,6 +5651,23 @@ main (int argc, char **argv)
 	  seenflag = true;
 	  break;
 
+	case 'U':
+	  if (streq (optarg, "default") || streq (optarg, "d"))
+	    unicode_display = unicode_default;
+	  else if (streq (optarg, "locale") || streq (optarg, "l"))
+	    unicode_display = unicode_locale;
+	  else if (streq (optarg, "escape") || streq (optarg, "e"))
+	    unicode_display = unicode_escape;
+	  else if (streq (optarg, "invalid") || streq (optarg, "i"))
+	    unicode_display = unicode_invalid;
+	  else if (streq (optarg, "hex") || streq (optarg, "x"))
+	    unicode_display = unicode_hex;
+	  else if (streq (optarg, "highlight") || streq (optarg, "h"))
+	    unicode_display = unicode_highlight;
+	  else
+	    fatal (_("invalid argument to -U/--unicode: %s"), optarg);
+	  break;
+
 	case 'H':
 	  usage (stdout, 0);
 	  /* No need to set seenflag or to break - usage() does not return.  */
diff -rupN binutils.orig/binutils/objdump.c.orig binutils-2.37/binutils/objdump.c.orig
--- binutils.orig/binutils/objdump.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.37/binutils/objdump.c.orig	2021-07-08 12:37:19.000000000 +0100
@@ -0,0 +1,5534 @@
+/* objdump.c -- dump information about an object file.
+   Copyright (C) 1990-2021 Free Software Foundation, Inc.
+
+   This file is part of GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+
+/* Objdump overview.
+
+   Objdump displays information about one or more object files, either on
+   their own, or inside libraries.  It is commonly used as a disassembler,
+   but it can also display information about file headers, symbol tables,
+   relocations, debugging directives and more.
+
+   The flow of execution is as follows:
+
+   1. Command line arguments are checked for control switches and the
+      information to be displayed is selected.
+
+   2. Any remaining arguments are assumed to be object files, and they are
+      processed in order by display_bfd().  If the file is an archive each
+      of its elements is processed in turn.
+
+   3. The file's target architecture and binary file format are determined
+      by bfd_check_format().  If they are recognised, then dump_bfd() is
+      called.
+
+   4. dump_bfd() in turn calls separate functions to display the requested
+      item(s) of information(s).  For example disassemble_data() is called if
+      a disassembly has been requested.
+
+   When disassembling the code loops through blocks of instructions bounded
+   by symbols, calling disassemble_bytes() on each block.  The actual
+   disassembling is done by the libopcodes library, via a function pointer
+   supplied by the disassembler() function.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "elf-bfd.h"
+#include "coff-bfd.h"
+#include "progress.h"
+#include "bucomm.h"
+#include "elfcomm.h"
+#include "dwarf.h"
+#include "ctf-api.h"
+#include "getopt.h"
+#include "safe-ctype.h"
+#include "dis-asm.h"
+#include "libiberty.h"
+#include "demangle.h"
+#include "filenames.h"
+#include "debug.h"
+#include "budbg.h"
+#include "objdump.h"
+
+#ifdef HAVE_MMAP
+#include <sys/mman.h>
+#endif
+
+/* Internal headers for the ELF .stab-dump code - sorry.  */
+#define	BYTES_IN_WORD	32
+#include "aout/aout64.h"
+
+/* Exit status.  */
+static int exit_status = 0;
+
+static char *default_target = NULL;	/* Default at runtime.  */
+
+/* The following variables are set based on arguments passed on the
+   command line.  */
+static int show_version = 0;		/* Show the version number.  */
+static int dump_section_contents;	/* -s */
+static int dump_section_headers;	/* -h */
+static bool dump_file_header;		/* -f */
+static int dump_symtab;			/* -t */
+static int dump_dynamic_symtab;		/* -T */
+static int dump_reloc_info;		/* -r */
+static int dump_dynamic_reloc_info;	/* -R */
+static int dump_ar_hdrs;		/* -a */
+static int dump_private_headers;	/* -p */
+static char *dump_private_options;	/* -P */
+static int no_addresses;		/* --no-addresses */
+static int prefix_addresses;		/* --prefix-addresses */
+static int with_line_numbers;		/* -l */
+static bool with_source_code;		/* -S */
+static int show_raw_insn;		/* --show-raw-insn */
+static int dump_dwarf_section_info;	/* --dwarf */
+static int dump_stab_section_info;	/* --stabs */
+static int dump_ctf_section_info;       /* --ctf */
+static char *dump_ctf_section_name;
+static char *dump_ctf_parent_name;	/* --ctf-parent */
+static int do_demangle;			/* -C, --demangle */
+static bool disassemble;		/* -d */
+static bool disassemble_all;		/* -D */
+static int disassemble_zeroes;		/* --disassemble-zeroes */
+static bool formats_info;		/* -i */
+static int wide_output;			/* -w */
+static int insn_width;			/* --insn-width */
+static bfd_vma start_address = (bfd_vma) -1; /* --start-address */
+static bfd_vma stop_address = (bfd_vma) -1;  /* --stop-address */
+static int dump_debugging;		/* --debugging */
+static int dump_debugging_tags;		/* --debugging-tags */
+static int suppress_bfd_header;
+static int dump_special_syms = 0;	/* --special-syms */
+static bfd_vma adjust_section_vma = 0;	/* --adjust-vma */
+static int file_start_context = 0;      /* --file-start-context */
+static bool display_file_offsets;	/* -F */
+static const char *prefix;		/* --prefix */
+static int prefix_strip;		/* --prefix-strip */
+static size_t prefix_length;
+static bool unwind_inlines;		/* --inlines.  */
+static const char * disasm_sym;		/* Disassembly start symbol.  */
+static const char * source_comment;     /* --source_comment.  */
+static bool visualize_jumps = false;	/* --visualize-jumps.  */
+static bool color_output = false;	/* --visualize-jumps=color.  */
+static bool extended_color_output = false; /* --visualize-jumps=extended-color.  */
+static int process_links = false;       /* --process-links.  */
+
+static int demangle_flags = DMGL_ANSI | DMGL_PARAMS;
+
+/* A structure to record the sections mentioned in -j switches.  */
+struct only
+{
+  const char *name; /* The name of the section.  */
+  bool seen; /* A flag to indicate that the section has been found in one or more input files.  */
+  struct only *next; /* Pointer to the next structure in the list.  */
+};
+/* Pointer to an array of 'only' structures.
+   This pointer is NULL if the -j switch has not been used.  */
+static struct only * only_list = NULL;
+
+/* Variables for handling include file path table.  */
+static const char **include_paths;
+static int include_path_count;
+
+/* Extra info to pass to the section disassembler and address printing
+   function.  */
+struct objdump_disasm_info
+{
+  bfd *abfd;
+  bool require_sec;
+  disassembler_ftype disassemble_fn;
+  arelent *reloc;
+  const char *symbol;
+};
+
+/* Architecture to disassemble for, or default if NULL.  */
+static char *machine = NULL;
+
+/* Target specific options to the disassembler.  */
+static char *disassembler_options = NULL;
+
+/* Endianness to disassemble for, or default if BFD_ENDIAN_UNKNOWN.  */
+static enum bfd_endian endian = BFD_ENDIAN_UNKNOWN;
+
+/* The symbol table.  */
+static asymbol **syms;
+
+/* Number of symbols in `syms'.  */
+static long symcount = 0;
+
+/* The sorted symbol table.  */
+static asymbol **sorted_syms;
+
+/* Number of symbols in `sorted_syms'.  */
+static long sorted_symcount = 0;
+
+/* The dynamic symbol table.  */
+static asymbol **dynsyms;
+
+/* The synthetic symbol table.  */
+static asymbol *synthsyms;
+static long synthcount = 0;
+
+/* Number of symbols in `dynsyms'.  */
+static long dynsymcount = 0;
+
+static bfd_byte *stabs;
+static bfd_size_type stab_size;
+
+static bfd_byte *strtab;
+static bfd_size_type stabstr_size;
+
+/* Handlers for -P/--private.  */
+static const struct objdump_private_desc * const objdump_private_vectors[] =
+  {
+    OBJDUMP_PRIVATE_VECTORS
+    NULL
+  };
+
+/* The list of detected jumps inside a function.  */
+static struct jump_info *detected_jumps = NULL;
+
+static void usage (FILE *, int) ATTRIBUTE_NORETURN;
+static void
+usage (FILE *stream, int status)
+{
+  fprintf (stream, _("Usage: %s <option(s)> <file(s)>\n"), program_name);
+  fprintf (stream, _(" Display information from object <file(s)>.\n"));
+  fprintf (stream, _(" At least one of the following switches must be given:\n"));
+  fprintf (stream, _("\
+  -a, --archive-headers    Display archive header information\n"));
+  fprintf (stream, _("\
+  -f, --file-headers       Display the contents of the overall file header\n"));
+  fprintf (stream, _("\
+  -p, --private-headers    Display object format specific file header contents\n"));
+  fprintf (stream, _("\
+  -P, --private=OPT,OPT... Display object format specific contents\n"));
+  fprintf (stream, _("\
+  -h, --[section-]headers  Display the contents of the section headers\n"));
+  fprintf (stream, _("\
+  -x, --all-headers        Display the contents of all headers\n"));
+  fprintf (stream, _("\
+  -d, --disassemble        Display assembler contents of executable sections\n"));
+  fprintf (stream, _("\
+  -D, --disassemble-all    Display assembler contents of all sections\n"));
+  fprintf (stream, _("\
+      --disassemble=<sym>  Display assembler contents from <sym>\n"));
+  fprintf (stream, _("\
+  -S, --source             Intermix source code with disassembly\n"));
+  fprintf (stream, _("\
+      --source-comment[=<txt>] Prefix lines of source code with <txt>\n"));
+  fprintf (stream, _("\
+  -s, --full-contents      Display the full contents of all sections requested\n"));
+  fprintf (stream, _("\
+  -g, --debugging          Display debug information in object file\n"));
+  fprintf (stream, _("\
+  -e, --debugging-tags     Display debug information using ctags style\n"));
+  fprintf (stream, _("\
+  -G, --stabs              Display (in raw form) any STABS info in the file\n"));
+  fprintf (stream, _("\
+  -W, --dwarf[a/=abbrev, A/=addr, r/=aranges, c/=cu_index, L/=decodedline,\n\
+              f/=frames, F/=frames-interp, g/=gdb_index, i/=info, o/=loc,\n\
+              m/=macro, p/=pubnames, t/=pubtypes, R/=Ranges, l/=rawline,\n\
+              s/=str, O/=str-offsets, u/=trace_abbrev, T/=trace_aranges,\n\
+              U/=trace_info]\n\
+                           Display the contents of DWARF debug sections\n"));
+  fprintf (stream, _("\
+  -Wk,--dwarf=links        Display the contents of sections that link to\n\
+                            separate debuginfo files\n"));
+#if DEFAULT_FOR_FOLLOW_LINKS
+  fprintf (stream, _("\
+  -WK,--dwarf=follow-links\n\
+                           Follow links to separate debug info files (default)\n"));
+  fprintf (stream, _("\
+  -WN,--dwarf=no-follow-links\n\
+                           Do not follow links to separate debug info files\n"));
+#else
+  fprintf (stream, _("\
+  -WK,--dwarf=follow-links\n\
+                           Follow links to separate debug info files\n"));
+  fprintf (stream, _("\
+  -WN,--dwarf=no-follow-links\n\
+                           Do not follow links to separate debug info files\n\
+                            (default)\n"));
+#endif
+  fprintf (stream, _("\
+  -L, --process-links      Display the contents of non-debug sections in\n\
+                            separate debuginfo files.  (Implies -WK)\n"));
+#ifdef ENABLE_LIBCTF
+  fprintf (stream, _("\
+      --ctf=SECTION        Display CTF info from SECTION\n"));
+#endif
+  fprintf (stream, _("\
+  -t, --syms               Display the contents of the symbol table(s)\n"));
+  fprintf (stream, _("\
+  -T, --dynamic-syms       Display the contents of the dynamic symbol table\n"));
+  fprintf (stream, _("\
+  -r, --reloc              Display the relocation entries in the file\n"));
+  fprintf (stream, _("\
+  -R, --dynamic-reloc      Display the dynamic relocation entries in the file\n"));
+  fprintf (stream, _("\
+  @<file>                  Read options from <file>\n"));
+  fprintf (stream, _("\
+  -v, --version            Display this program's version number\n"));
+  fprintf (stream, _("\
+  -i, --info               List object formats and architectures supported\n"));
+  fprintf (stream, _("\
+  -H, --help               Display this information\n"));
+
+  if (status != 2)
+    {
+      const struct objdump_private_desc * const *desc;
+
+      fprintf (stream, _("\n The following switches are optional:\n"));
+      fprintf (stream, _("\
+  -b, --target=BFDNAME           Specify the target object format as BFDNAME\n"));
+      fprintf (stream, _("\
+  -m, --architecture=MACHINE     Specify the target architecture as MACHINE\n"));
+      fprintf (stream, _("\
+  -j, --section=NAME             Only display information for section NAME\n"));
+      fprintf (stream, _("\
+  -M, --disassembler-options=OPT Pass text OPT on to the disassembler\n"));
+      fprintf (stream, _("\
+  -EB --endian=big               Assume big endian format when disassembling\n"));
+      fprintf (stream, _("\
+  -EL --endian=little            Assume little endian format when disassembling\n"));
+      fprintf (stream, _("\
+      --file-start-context       Include context from start of file (with -S)\n"));
+      fprintf (stream, _("\
+  -I, --include=DIR              Add DIR to search list for source files\n"));
+      fprintf (stream, _("\
+  -l, --line-numbers             Include line numbers and filenames in output\n"));
+      fprintf (stream, _("\
+  -F, --file-offsets             Include file offsets when displaying information\n"));
+      fprintf (stream, _("\
+  -C, --demangle[=STYLE]         Decode mangled/processed symbol names\n\
+                                  The STYLE, if specified, can be `auto', `gnu',\n\
+                                  `lucid', `arm', `hp', `edg', `gnu-v3', `java'\n\
+                                  or `gnat'\n"));
+      fprintf (stream, _("\
+      --recurse-limit            Enable a limit on recursion whilst demangling\n\
+                                  (default)\n"));
+      fprintf (stream, _("\
+      --no-recurse-limit         Disable a limit on recursion whilst demangling\n"));
+      fprintf (stream, _("\
+  -w, --wide                     Format output for more than 80 columns\n"));
+      fprintf (stream, _("\
+  -z, --disassemble-zeroes       Do not skip blocks of zeroes when disassembling\n"));
+      fprintf (stream, _("\
+      --start-address=ADDR       Only process data whose address is >= ADDR\n"));
+      fprintf (stream, _("\
+      --stop-address=ADDR        Only process data whose address is < ADDR\n"));
+      fprintf (stream, _("\
+      --no-addresses             Do not print address alongside disassembly\n"));
+      fprintf (stream, _("\
+      --prefix-addresses         Print complete address alongside disassembly\n"));
+      fprintf (stream, _("\
+      --[no-]show-raw-insn       Display hex alongside symbolic disassembly\n"));
+      fprintf (stream, _("\
+      --insn-width=WIDTH         Display WIDTH bytes on a single line for -d\n"));
+      fprintf (stream, _("\
+      --adjust-vma=OFFSET        Add OFFSET to all displayed section addresses\n"));
+      fprintf (stream, _("\
+      --special-syms             Include special symbols in symbol dumps\n"));
+      fprintf (stream, _("\
+      --inlines                  Print all inlines for source line (with -l)\n"));
+      fprintf (stream, _("\
+      --prefix=PREFIX            Add PREFIX to absolute paths for -S\n"));
+      fprintf (stream, _("\
+      --prefix-strip=LEVEL       Strip initial directory names for -S\n"));
+      fprintf (stream, _("\
+      --dwarf-depth=N            Do not display DIEs at depth N or greater\n"));
+      fprintf (stream, _("\
+      --dwarf-start=N            Display DIEs starting at offset N\n"));
+      fprintf (stream, _("\
+      --dwarf-check              Make additional dwarf consistency checks.\n"));
+#ifdef ENABLE_LIBCTF
+      fprintf (stream, _("\
+      --ctf-parent=SECTION       Use SECTION as the CTF parent\n"));
+#endif
+      fprintf (stream, _("\
+      --visualize-jumps          Visualize jumps by drawing ASCII art lines\n"));
+      fprintf (stream, _("\
+      --visualize-jumps=color    Use colors in the ASCII art\n"));
+      fprintf (stream, _("\
+      --visualize-jumps=extended-color\n\
+                                 Use extended 8-bit color codes\n"));
+      fprintf (stream, _("\
+      --visualize-jumps=off      Disable jump visualization\n\n"));
+
+      list_supported_targets (program_name, stream);
+      list_supported_architectures (program_name, stream);
+
+      disassembler_usage (stream);
+
+      if (objdump_private_vectors[0] != NULL)
+        {
+          fprintf (stream,
+                   _("\nOptions supported for -P/--private switch:\n"));
+          for (desc = objdump_private_vectors; *desc != NULL; desc++)
+            (*desc)->help (stream);
+        }
+    }
+  if (REPORT_BUGS_TO[0] && status == 0)
+    fprintf (stream, _("Report bugs to %s.\n"), REPORT_BUGS_TO);
+  exit (status);
+}
+
+/* 150 isn't special; it's just an arbitrary non-ASCII char value.  */
+enum option_values
+  {
+    OPTION_ENDIAN=150,
+    OPTION_START_ADDRESS,
+    OPTION_STOP_ADDRESS,
+    OPTION_DWARF,
+    OPTION_PREFIX,
+    OPTION_PREFIX_STRIP,
+    OPTION_INSN_WIDTH,
+    OPTION_ADJUST_VMA,
+    OPTION_DWARF_DEPTH,
+    OPTION_DWARF_CHECK,
+    OPTION_DWARF_START,
+    OPTION_RECURSE_LIMIT,
+    OPTION_NO_RECURSE_LIMIT,
+    OPTION_INLINES,
+    OPTION_SOURCE_COMMENT,
+#ifdef ENABLE_LIBCTF
+    OPTION_CTF,
+    OPTION_CTF_PARENT,
+#endif
+    OPTION_VISUALIZE_JUMPS
+  };
+
+static struct option long_options[]=
+{
+  {"adjust-vma", required_argument, NULL, OPTION_ADJUST_VMA},
+  {"all-headers", no_argument, NULL, 'x'},
+  {"private-headers", no_argument, NULL, 'p'},
+  {"private", required_argument, NULL, 'P'},
+  {"architecture", required_argument, NULL, 'm'},
+  {"archive-headers", no_argument, NULL, 'a'},
+  {"debugging", no_argument, NULL, 'g'},
+  {"debugging-tags", no_argument, NULL, 'e'},
+  {"demangle", optional_argument, NULL, 'C'},
+  {"disassemble", optional_argument, NULL, 'd'},
+  {"disassemble-all", no_argument, NULL, 'D'},
+  {"disassembler-options", required_argument, NULL, 'M'},
+  {"disassemble-zeroes", no_argument, NULL, 'z'},
+  {"dynamic-reloc", no_argument, NULL, 'R'},
+  {"dynamic-syms", no_argument, NULL, 'T'},
+  {"endian", required_argument, NULL, OPTION_ENDIAN},
+  {"file-headers", no_argument, NULL, 'f'},
+  {"file-offsets", no_argument, NULL, 'F'},
+  {"file-start-context", no_argument, &file_start_context, 1},
+  {"full-contents", no_argument, NULL, 's'},
+  {"headers", no_argument, NULL, 'h'},
+  {"help", no_argument, NULL, 'H'},
+  {"info", no_argument, NULL, 'i'},
+  {"line-numbers", no_argument, NULL, 'l'},
+  {"no-show-raw-insn", no_argument, &show_raw_insn, -1},
+  {"no-addresses", no_argument, &no_addresses, 1},
+  {"process-links", no_argument, &process_links, true},
+  {"prefix-addresses", no_argument, &prefix_addresses, 1},
+  {"recurse-limit", no_argument, NULL, OPTION_RECURSE_LIMIT},
+  {"recursion-limit", no_argument, NULL, OPTION_RECURSE_LIMIT},
+  {"no-recurse-limit", no_argument, NULL, OPTION_NO_RECURSE_LIMIT},
+  {"no-recursion-limit", no_argument, NULL, OPTION_NO_RECURSE_LIMIT},
+  {"reloc", no_argument, NULL, 'r'},
+  {"section", required_argument, NULL, 'j'},
+  {"section-headers", no_argument, NULL, 'h'},
+  {"show-raw-insn", no_argument, &show_raw_insn, 1},
+  {"source", no_argument, NULL, 'S'},
+  {"source-comment", optional_argument, NULL, OPTION_SOURCE_COMMENT},
+  {"special-syms", no_argument, &dump_special_syms, 1},
+  {"include", required_argument, NULL, 'I'},
+  {"dwarf", optional_argument, NULL, OPTION_DWARF},
+#ifdef ENABLE_LIBCTF
+  {"ctf", required_argument, NULL, OPTION_CTF},
+  {"ctf-parent", required_argument, NULL, OPTION_CTF_PARENT},
+#endif
+  {"stabs", no_argument, NULL, 'G'},
+  {"start-address", required_argument, NULL, OPTION_START_ADDRESS},
+  {"stop-address", required_argument, NULL, OPTION_STOP_ADDRESS},
+  {"syms", no_argument, NULL, 't'},
+  {"target", required_argument, NULL, 'b'},
+  {"version", no_argument, NULL, 'V'},
+  {"wide", no_argument, NULL, 'w'},
+  {"prefix", required_argument, NULL, OPTION_PREFIX},
+  {"prefix-strip", required_argument, NULL, OPTION_PREFIX_STRIP},
+  {"insn-width", required_argument, NULL, OPTION_INSN_WIDTH},
+  {"dwarf-depth", required_argument, 0, OPTION_DWARF_DEPTH},
+  {"dwarf-start", required_argument, 0, OPTION_DWARF_START},
+  {"dwarf-check", no_argument, 0, OPTION_DWARF_CHECK},
+  {"inlines", no_argument, 0, OPTION_INLINES},
+  {"visualize-jumps", optional_argument, 0, OPTION_VISUALIZE_JUMPS},
+  {0, no_argument, 0, 0}
+};
+
+static void
+nonfatal (const char *msg)
+{
+  bfd_nonfatal (msg);
+  exit_status = 1;
+}
+
+/* Returns a version of IN with any control characters
+   replaced by escape sequences.  Uses a static buffer
+   if necessary.  */
+
+static const char *
+sanitize_string (const char * in)
+{
+  static char *  buffer = NULL;
+  static size_t  buffer_len = 0;
+  const char *   original = in;
+  char *         out;
+
+  /* Paranoia.  */
+  if (in == NULL)
+    return "";
+
+  /* See if any conversion is necessary.  In the majority
+     of cases it will not be needed.  */
+  do
+    {
+      char c = *in++;
+
+      if (c == 0)
+	return original;
+
+      if (ISCNTRL (c))
+	break;
+    }
+  while (1);
+
+  /* Copy the input, translating as needed.  */
+  in = original;
+  if (buffer_len < (strlen (in) * 2))
+    {
+      free ((void *) buffer);
+      buffer_len = strlen (in) * 2;
+      buffer = xmalloc (buffer_len + 1);
+    }
+
+  out = buffer;
+  do
+    {
+      char c = *in++;
+
+      if (c == 0)
+	break;
+
+      if (!ISCNTRL (c))
+	*out++ = c;
+      else
+	{
+	  *out++ = '^';
+	  *out++ = c + 0x40;
+	}
+    }
+  while (1);
+
+  *out = 0;
+  return buffer;
+}
+
+
+/* Returns TRUE if the specified section should be dumped.  */
+
+static bool
+process_section_p (asection * section)
+{
+  struct only * only;
+
+  if (only_list == NULL)
+    return true;
+
+  for (only = only_list; only; only = only->next)
+    if (strcmp (only->name, section->name) == 0)
+      {
+	only->seen = true;
+	return true;
+      }
+
+  return false;
+}
+
+/* Add an entry to the 'only' list.  */
+
+static void
+add_only (char * name)
+{
+  struct only * only;
+
+  /* First check to make sure that we do not
+     already have an entry for this name.  */
+  for (only = only_list; only; only = only->next)
+    if (strcmp (only->name, name) == 0)
+      return;
+
+  only = xmalloc (sizeof * only);
+  only->name = name;
+  only->seen = false;
+  only->next = only_list;
+  only_list = only;
+}
+
+/* Release the memory used by the 'only' list.
+   PR 11225: Issue a warning message for unseen sections.
+   Only do this if none of the sections were seen.  This is mainly to support
+   tools like the GAS testsuite where an object file is dumped with a list of
+   generic section names known to be present in a range of different file
+   formats.  */
+
+static void
+free_only_list (void)
+{
+  bool at_least_one_seen = false;
+  struct only * only;
+  struct only * next;
+
+  if (only_list == NULL)
+    return;
+
+  for (only = only_list; only; only = only->next)
+    if (only->seen)
+      {
+	at_least_one_seen = true;
+	break;
+      }
+
+  for (only = only_list; only; only = next)
+    {
+      if (! at_least_one_seen)
+	{
+	  non_fatal (_("section '%s' mentioned in a -j option, "
+		       "but not found in any input file"),
+		     only->name);
+	  exit_status = 1;
+	}
+      next = only->next;
+      free (only);
+    }
+}
+
+
+static void
+dump_section_header (bfd *abfd, asection *section, void *data)
+{
+  char *comma = "";
+  unsigned int opb = bfd_octets_per_byte (abfd, section);
+  int longest_section_name = *((int *) data);
+
+  /* Ignore linker created section.  See elfNN_ia64_object_p in
+     bfd/elfxx-ia64.c.  */
+  if (section->flags & SEC_LINKER_CREATED)
+    return;
+
+  /* PR 10413: Skip sections that we are ignoring.  */
+  if (! process_section_p (section))
+    return;
+
+  printf ("%3d %-*s %08lx  ", section->index, longest_section_name,
+	  sanitize_string (bfd_section_name (section)),
+	  (unsigned long) bfd_section_size (section) / opb);
+  bfd_printf_vma (abfd, bfd_section_vma (section));
+  printf ("  ");
+  bfd_printf_vma (abfd, section->lma);
+  printf ("  %08lx  2**%u", (unsigned long) section->filepos,
+	  bfd_section_alignment (section));
+  if (! wide_output)
+    printf ("\n                ");
+  printf ("  ");
+
+#define PF(x, y) \
+  if (section->flags & x) { printf ("%s%s", comma, y); comma = ", "; }
+
+  PF (SEC_HAS_CONTENTS, "CONTENTS");
+  PF (SEC_ALLOC, "ALLOC");
+  PF (SEC_CONSTRUCTOR, "CONSTRUCTOR");
+  PF (SEC_LOAD, "LOAD");
+  PF (SEC_RELOC, "RELOC");
+  PF (SEC_READONLY, "READONLY");
+  PF (SEC_CODE, "CODE");
+  PF (SEC_DATA, "DATA");
+  PF (SEC_ROM, "ROM");
+  PF (SEC_DEBUGGING, "DEBUGGING");
+  PF (SEC_NEVER_LOAD, "NEVER_LOAD");
+  PF (SEC_EXCLUDE, "EXCLUDE");
+  PF (SEC_SORT_ENTRIES, "SORT_ENTRIES");
+  if (bfd_get_arch (abfd) == bfd_arch_tic54x)
+    {
+      PF (SEC_TIC54X_BLOCK, "BLOCK");
+      PF (SEC_TIC54X_CLINK, "CLINK");
+    }
+  PF (SEC_SMALL_DATA, "SMALL_DATA");
+  if (bfd_get_flavour (abfd) == bfd_target_coff_flavour)
+    {
+      PF (SEC_COFF_SHARED, "SHARED");
+      PF (SEC_COFF_NOREAD, "NOREAD");
+    }
+  else if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
+    {
+      PF (SEC_ELF_OCTETS, "OCTETS");
+      PF (SEC_ELF_PURECODE, "PURECODE");
+    }
+  PF (SEC_THREAD_LOCAL, "THREAD_LOCAL");
+  PF (SEC_GROUP, "GROUP");
+  if (bfd_get_arch (abfd) == bfd_arch_mep)
+    {
+      PF (SEC_MEP_VLIW, "VLIW");
+    }
+
+  if ((section->flags & SEC_LINK_ONCE) != 0)
+    {
+      const char *ls;
+      struct coff_comdat_info *comdat;
+
+      switch (section->flags & SEC_LINK_DUPLICATES)
+	{
+	default:
+	  abort ();
+	case SEC_LINK_DUPLICATES_DISCARD:
+	  ls = "LINK_ONCE_DISCARD";
+	  break;
+	case SEC_LINK_DUPLICATES_ONE_ONLY:
+	  ls = "LINK_ONCE_ONE_ONLY";
+	  break;
+	case SEC_LINK_DUPLICATES_SAME_SIZE:
+	  ls = "LINK_ONCE_SAME_SIZE";
+	  break;
+	case SEC_LINK_DUPLICATES_SAME_CONTENTS:
+	  ls = "LINK_ONCE_SAME_CONTENTS";
+	  break;
+	}
+      printf ("%s%s", comma, ls);
+
+      comdat = bfd_coff_get_comdat_section (abfd, section);
+      if (comdat != NULL)
+	printf (" (COMDAT %s %ld)", comdat->name, comdat->symbol);
+
+      comma = ", ";
+    }
+
+  printf ("\n");
+#undef PF
+}
+
+/* Called on each SECTION in ABFD, update the int variable pointed to by
+   DATA which contains the string length of the longest section name.  */
+
+static void
+find_longest_section_name (bfd *abfd ATTRIBUTE_UNUSED,
+			   asection *section, void *data)
+{
+  int *longest_so_far = (int *) data;
+  const char *name;
+  int len;
+
+  /* Ignore linker created section.  */
+  if (section->flags & SEC_LINKER_CREATED)
+    return;
+
+  /* Skip sections that we are ignoring.  */
+  if (! process_section_p (section))
+    return;
+
+  name = bfd_section_name (section);
+  len = (int) strlen (name);
+  if (len > *longest_so_far)
+    *longest_so_far = len;
+}
+
+static void
+dump_headers (bfd *abfd)
+{
+  /* The default width of 13 is just an arbitrary choice.  */
+  int max_section_name_length = 13;
+  int bfd_vma_width;
+
+#ifndef BFD64
+  bfd_vma_width = 10;
+#else
+  /* With BFD64, non-ELF returns -1 and wants always 64 bit addresses.  */
+  if (bfd_get_arch_size (abfd) == 32)
+    bfd_vma_width = 10;
+  else
+    bfd_vma_width = 18;
+#endif
+
+  printf (_("Sections:\n"));
+
+  if (wide_output)
+    bfd_map_over_sections (abfd, find_longest_section_name,
+                           &max_section_name_length);
+
+  printf (_("Idx %-*s Size      %-*s%-*sFile off  Algn"),
+	  max_section_name_length, "Name",
+	  bfd_vma_width, "VMA",
+	  bfd_vma_width, "LMA");
+
+  if (wide_output)
+    printf (_("  Flags"));
+  printf ("\n");
+
+  bfd_map_over_sections (abfd, dump_section_header,
+                         &max_section_name_length);
+}
+
+static asymbol **
+slurp_symtab (bfd *abfd)
+{
+  asymbol **sy = NULL;
+  long storage;
+
+  if (!(bfd_get_file_flags (abfd) & HAS_SYMS))
+    {
+      symcount = 0;
+      return NULL;
+    }
+
+  storage = bfd_get_symtab_upper_bound (abfd);
+  if (storage < 0)
+    {
+      non_fatal (_("failed to read symbol table from: %s"), bfd_get_filename (abfd));
+      bfd_fatal (_("error message was"));
+    }
+
+  if (storage)
+    {
+      off_t filesize = bfd_get_file_size (abfd);
+
+      /* qv PR 24707.  */
+      if (filesize > 0
+	  && filesize < storage
+	  /* The MMO file format supports its own special compression
+	     technique, so its sections can be larger than the file size.  */
+	  && bfd_get_flavour (abfd) != bfd_target_mmo_flavour)
+	{
+	  bfd_nonfatal_message (bfd_get_filename (abfd), abfd, NULL,
+				_("error: symbol table size (%#lx) "
+				  "is larger than filesize (%#lx)"),
+				storage, (long) filesize);
+	  exit_status = 1;
+	  symcount = 0;
+	  return NULL;
+	}
+
+      sy = (asymbol **) xmalloc (storage);
+    }
+
+  symcount = bfd_canonicalize_symtab (abfd, sy);
+  if (symcount < 0)
+    bfd_fatal (bfd_get_filename (abfd));
+  return sy;
+}
+
+/* Read in the dynamic symbols.  */
+
+static asymbol **
+slurp_dynamic_symtab (bfd *abfd)
+{
+  asymbol **sy = NULL;
+  long storage;
+
+  storage = bfd_get_dynamic_symtab_upper_bound (abfd);
+  if (storage < 0)
+    {
+      if (!(bfd_get_file_flags (abfd) & DYNAMIC))
+	{
+	  non_fatal (_("%s: not a dynamic object"), bfd_get_filename (abfd));
+	  exit_status = 1;
+	  dynsymcount = 0;
+	  return NULL;
+	}
+
+      bfd_fatal (bfd_get_filename (abfd));
+    }
+
+  if (storage)
+    sy = (asymbol **) xmalloc (storage);
+
+  dynsymcount = bfd_canonicalize_dynamic_symtab (abfd, sy);
+  if (dynsymcount < 0)
+    bfd_fatal (bfd_get_filename (abfd));
+  return sy;
+}
+
+/* Some symbol names are significant and should be kept in the
+   table of sorted symbol names, even if they are marked as
+   debugging/section symbols.  */
+
+static bool
+is_significant_symbol_name (const char * name)
+{
+  return startswith (name, ".plt") || startswith (name, ".got");
+}
+
+/* Filter out (in place) symbols that are useless for disassembly.
+   COUNT is the number of elements in SYMBOLS.
+   Return the number of useful symbols.  */
+
+static long
+remove_useless_symbols (asymbol **symbols, long count)
+{
+  asymbol **in_ptr = symbols, **out_ptr = symbols;
+
+  while (--count >= 0)
+    {
+      asymbol *sym = *in_ptr++;
+
+      if (sym->name == NULL || sym->name[0] == '\0')
+	continue;
+      if ((sym->flags & (BSF_DEBUGGING | BSF_SECTION_SYM))
+	  && ! is_significant_symbol_name (sym->name))
+	continue;
+      if (bfd_is_und_section (sym->section)
+	  || bfd_is_com_section (sym->section))
+	continue;
+
+      *out_ptr++ = sym;
+    }
+  return out_ptr - symbols;
+}
+
+static const asection *compare_section;
+
+/* Sort symbols into value order.  */
+
+static int
+compare_symbols (const void *ap, const void *bp)
+{
+  const asymbol *a = * (const asymbol **) ap;
+  const asymbol *b = * (const asymbol **) bp;
+  const char *an;
+  const char *bn;
+  size_t anl;
+  size_t bnl;
+  bool as, af, bs, bf;
+  flagword aflags;
+  flagword bflags;
+
+  if (bfd_asymbol_value (a) > bfd_asymbol_value (b))
+    return 1;
+  else if (bfd_asymbol_value (a) < bfd_asymbol_value (b))
+    return -1;
+
+  /* Prefer symbols from the section currently being disassembled.
+     Don't sort symbols from other sections by section, since there
+     isn't much reason to prefer one section over another otherwise.
+     See sym_ok comment for why we compare by section name.  */
+  as = strcmp (compare_section->name, a->section->name) == 0;
+  bs = strcmp (compare_section->name, b->section->name) == 0;
+  if (as && !bs)
+    return -1;
+  if (!as && bs)
+    return 1;
+
+  an = bfd_asymbol_name (a);
+  bn = bfd_asymbol_name (b);
+  anl = strlen (an);
+  bnl = strlen (bn);
+
+  /* The symbols gnu_compiled and gcc2_compiled convey no real
+     information, so put them after other symbols with the same value.  */
+  af = (strstr (an, "gnu_compiled") != NULL
+	|| strstr (an, "gcc2_compiled") != NULL);
+  bf = (strstr (bn, "gnu_compiled") != NULL
+	|| strstr (bn, "gcc2_compiled") != NULL);
+
+  if (af && ! bf)
+    return 1;
+  if (! af && bf)
+    return -1;
+
+  /* We use a heuristic for the file name, to try to sort it after
+     more useful symbols.  It may not work on non Unix systems, but it
+     doesn't really matter; the only difference is precisely which
+     symbol names get printed.  */
+
+#define file_symbol(s, sn, snl)			\
+  (((s)->flags & BSF_FILE) != 0			\
+   || ((snl) > 2				\
+       && (sn)[(snl) - 2] == '.'		\
+       && ((sn)[(snl) - 1] == 'o'		\
+	   || (sn)[(snl) - 1] == 'a')))
+
+  af = file_symbol (a, an, anl);
+  bf = file_symbol (b, bn, bnl);
+
+  if (af && ! bf)
+    return 1;
+  if (! af && bf)
+    return -1;
+
+  /* Sort function and object symbols before global symbols before
+     local symbols before section symbols before debugging symbols.  */
+
+  aflags = a->flags;
+  bflags = b->flags;
+
+  if ((aflags & BSF_DEBUGGING) != (bflags & BSF_DEBUGGING))
+    {
+      if ((aflags & BSF_DEBUGGING) != 0)
+	return 1;
+      else
+	return -1;
+    }
+  if ((aflags & BSF_SECTION_SYM) != (bflags & BSF_SECTION_SYM))
+    {
+      if ((aflags & BSF_SECTION_SYM) != 0)
+	return 1;
+      else
+	return -1;
+    }
+  if ((aflags & BSF_FUNCTION) != (bflags & BSF_FUNCTION))
+    {
+      if ((aflags & BSF_FUNCTION) != 0)
+	return -1;
+      else
+	return 1;
+    }
+  if ((aflags & BSF_OBJECT) != (bflags & BSF_OBJECT))
+    {
+      if ((aflags & BSF_OBJECT) != 0)
+	return -1;
+      else
+	return 1;
+    }
+  if ((aflags & BSF_LOCAL) != (bflags & BSF_LOCAL))
+    {
+      if ((aflags & BSF_LOCAL) != 0)
+	return 1;
+      else
+	return -1;
+    }
+  if ((aflags & BSF_GLOBAL) != (bflags & BSF_GLOBAL))
+    {
+      if ((aflags & BSF_GLOBAL) != 0)
+	return -1;
+      else
+	return 1;
+    }
+
+  if (bfd_get_flavour (bfd_asymbol_bfd (a)) == bfd_target_elf_flavour
+      && bfd_get_flavour (bfd_asymbol_bfd (b)) == bfd_target_elf_flavour)
+    {
+      bfd_vma asz, bsz;
+
+      asz = 0;
+      if ((a->flags & (BSF_SECTION_SYM | BSF_SYNTHETIC)) == 0)
+	asz = ((elf_symbol_type *) a)->internal_elf_sym.st_size;
+      bsz = 0;
+      if ((b->flags & (BSF_SECTION_SYM | BSF_SYNTHETIC)) == 0)
+	bsz = ((elf_symbol_type *) b)->internal_elf_sym.st_size;
+      if (asz != bsz)
+	return asz > bsz ? -1 : 1;
+    }
+
+  /* Symbols that start with '.' might be section names, so sort them
+     after symbols that don't start with '.'.  */
+  if (an[0] == '.' && bn[0] != '.')
+    return 1;
+  if (an[0] != '.' && bn[0] == '.')
+    return -1;
+
+  /* Finally, if we can't distinguish them in any other way, try to
+     get consistent results by sorting the symbols by name.  */
+  return strcmp (an, bn);
+}
+
+/* Sort relocs into address order.  */
+
+static int
+compare_relocs (const void *ap, const void *bp)
+{
+  const arelent *a = * (const arelent **) ap;
+  const arelent *b = * (const arelent **) bp;
+
+  if (a->address > b->address)
+    return 1;
+  else if (a->address < b->address)
+    return -1;
+
+  /* So that associated relocations tied to the same address show up
+     in the correct order, we don't do any further sorting.  */
+  if (a > b)
+    return 1;
+  else if (a < b)
+    return -1;
+  else
+    return 0;
+}
+
+/* Print an address (VMA) to the output stream in INFO.
+   If SKIP_ZEROES is TRUE, omit leading zeroes.  */
+
+static void
+objdump_print_value (bfd_vma vma, struct disassemble_info *inf,
+		     bool skip_zeroes)
+{
+  char buf[30];
+  char *p;
+  struct objdump_disasm_info *aux;
+
+  aux = (struct objdump_disasm_info *) inf->application_data;
+  bfd_sprintf_vma (aux->abfd, buf, vma);
+  if (! skip_zeroes)
+    p = buf;
+  else
+    {
+      for (p = buf; *p == '0'; ++p)
+	;
+      if (*p == '\0')
+	--p;
+    }
+  (*inf->fprintf_func) (inf->stream, "%s", p);
+}
+
+/* Print the name of a symbol.  */
+
+static void
+objdump_print_symname (bfd *abfd, struct disassemble_info *inf,
+		       asymbol *sym)
+{
+  char *alloc;
+  const char *name, *version_string = NULL;
+  bool hidden = false;
+
+  alloc = NULL;
+  name = bfd_asymbol_name (sym);
+  if (do_demangle && name[0] != '\0')
+    {
+      /* Demangle the name.  */
+      alloc = bfd_demangle (abfd, name, demangle_flags);
+      if (alloc != NULL)
+	name = alloc;
+    }
+
+  if ((sym->flags & (BSF_SECTION_SYM | BSF_SYNTHETIC)) == 0)
+    version_string = bfd_get_symbol_version_string (abfd, sym, true,
+						    &hidden);
+
+  if (bfd_is_und_section (bfd_asymbol_section (sym)))
+    hidden = true;
+
+  name = sanitize_string (name);
+
+  if (inf != NULL)
+    {
+      (*inf->fprintf_func) (inf->stream, "%s", name);
+      if (version_string && *version_string != '\0')
+	(*inf->fprintf_func) (inf->stream, hidden ? "@%s" : "@@%s",
+			      version_string);
+    }
+  else
+    {
+      printf ("%s", name);
+      if (version_string && *version_string != '\0')
+	printf (hidden ? "@%s" : "@@%s", version_string);
+    }
+
+  if (alloc != NULL)
+    free (alloc);
+}
+
+static inline bool
+sym_ok (bool want_section,
+	bfd *abfd ATTRIBUTE_UNUSED,
+	long place,
+	asection *sec,
+	struct disassemble_info *inf)
+{
+  if (want_section)
+    {
+      /* NB: An object file can have different sections with the same
+         section name.  Compare compare section pointers if they have
+	 the same owner.  */
+      if (sorted_syms[place]->section->owner == sec->owner
+	  && sorted_syms[place]->section != sec)
+	return false;
+
+      /* Note - we cannot just compare section pointers because they could
+	 be different, but the same...  Ie the symbol that we are trying to
+	 find could have come from a separate debug info file.  Under such
+	 circumstances the symbol will be associated with a section in the
+	 debug info file, whilst the section we want is in a normal file.
+	 So the section pointers will be different, but the section names
+	 will be the same.  */
+      if (strcmp (bfd_section_name (sorted_syms[place]->section),
+		  bfd_section_name (sec)) != 0)
+	return false;
+    }
+
+  return inf->symbol_is_valid (sorted_syms[place], inf);
+}
+
+/* Locate a symbol given a bfd and a section (from INFO->application_data),
+   and a VMA.  If INFO->application_data->require_sec is TRUE, then always
+   require the symbol to be in the section.  Returns NULL if there is no
+   suitable symbol.  If PLACE is not NULL, then *PLACE is set to the index
+   of the symbol in sorted_syms.  */
+
+static asymbol *
+find_symbol_for_address (bfd_vma vma,
+			 struct disassemble_info *inf,
+			 long *place)
+{
+  /* @@ Would it speed things up to cache the last two symbols returned,
+     and maybe their address ranges?  For many processors, only one memory
+     operand can be present at a time, so the 2-entry cache wouldn't be
+     constantly churned by code doing heavy memory accesses.  */
+
+  /* Indices in `sorted_syms'.  */
+  long min = 0;
+  long max_count = sorted_symcount;
+  long thisplace;
+  struct objdump_disasm_info *aux;
+  bfd *abfd;
+  asection *sec;
+  unsigned int opb;
+  bool want_section;
+  long rel_count;
+
+  if (sorted_symcount < 1)
+    return NULL;
+
+  aux = (struct objdump_disasm_info *) inf->application_data;
+  abfd = aux->abfd;
+  sec = inf->section;
+  opb = inf->octets_per_byte;
+
+  /* Perform a binary search looking for the closest symbol to the
+     required value.  We are searching the range (min, max_count].  */
+  while (min + 1 < max_count)
+    {
+      asymbol *sym;
+
+      thisplace = (max_count + min) / 2;
+      sym = sorted_syms[thisplace];
+
+      if (bfd_asymbol_value (sym) > vma)
+	max_count = thisplace;
+      else if (bfd_asymbol_value (sym) < vma)
+	min = thisplace;
+      else
+	{
+	  min = thisplace;
+	  break;
+	}
+    }
+
+  /* The symbol we want is now in min, the low end of the range we
+     were searching.  If there are several symbols with the same
+     value, we want the first one.  */
+  thisplace = min;
+  while (thisplace > 0
+	 && (bfd_asymbol_value (sorted_syms[thisplace])
+	     == bfd_asymbol_value (sorted_syms[thisplace - 1])))
+    --thisplace;
+
+  /* Prefer a symbol in the current section if we have multple symbols
+     with the same value, as can occur with overlays or zero size
+     sections.  */
+  min = thisplace;
+  while (min < max_count
+	 && (bfd_asymbol_value (sorted_syms[min])
+	     == bfd_asymbol_value (sorted_syms[thisplace])))
+    {
+      if (sym_ok (true, abfd, min, sec, inf))
+	{
+	  thisplace = min;
+
+	  if (place != NULL)
+	    *place = thisplace;
+
+	  return sorted_syms[thisplace];
+	}
+      ++min;
+    }
+
+  /* If the file is relocatable, and the symbol could be from this
+     section, prefer a symbol from this section over symbols from
+     others, even if the other symbol's value might be closer.
+
+     Note that this may be wrong for some symbol references if the
+     sections have overlapping memory ranges, but in that case there's
+     no way to tell what's desired without looking at the relocation
+     table.
+
+     Also give the target a chance to reject symbols.  */
+  want_section = (aux->require_sec
+		  || ((abfd->flags & HAS_RELOC) != 0
+		      && vma >= bfd_section_vma (sec)
+		      && vma < (bfd_section_vma (sec)
+				+ bfd_section_size (sec) / opb)));
+  
+  if (! sym_ok (want_section, abfd, thisplace, sec, inf))
+    {
+      long i;
+      long newplace = sorted_symcount;
+
+      for (i = min - 1; i >= 0; i--)
+	{
+	  if (sym_ok (want_section, abfd, i, sec, inf))
+	    {
+	      if (newplace == sorted_symcount)
+		newplace = i;
+
+	      if (bfd_asymbol_value (sorted_syms[i])
+		  != bfd_asymbol_value (sorted_syms[newplace]))
+		break;
+
+	      /* Remember this symbol and keep searching until we reach
+		 an earlier address.  */
+	      newplace = i;
+	    }
+	}
+
+      if (newplace != sorted_symcount)
+	thisplace = newplace;
+      else
+	{
+	  /* We didn't find a good symbol with a smaller value.
+	     Look for one with a larger value.  */
+	  for (i = thisplace + 1; i < sorted_symcount; i++)
+	    {
+	      if (sym_ok (want_section, abfd, i, sec, inf))
+		{
+		  thisplace = i;
+		  break;
+		}
+	    }
+	}
+
+      if (! sym_ok (want_section, abfd, thisplace, sec, inf))
+	/* There is no suitable symbol.  */
+	return NULL;
+    }
+
+  /* If we have not found an exact match for the specified address
+     and we have dynamic relocations available, then we can produce
+     a better result by matching a relocation to the address and
+     using the symbol associated with that relocation.  */
+  rel_count = inf->dynrelcount;
+  if (!want_section
+      && sorted_syms[thisplace]->value != vma
+      && rel_count > 0
+      && inf->dynrelbuf != NULL
+      && inf->dynrelbuf[0]->address <= vma
+      && inf->dynrelbuf[rel_count - 1]->address >= vma
+      /* If we have matched a synthetic symbol, then stick with that.  */
+      && (sorted_syms[thisplace]->flags & BSF_SYNTHETIC) == 0)
+    {
+      arelent **  rel_low;
+      arelent **  rel_high;
+
+      rel_low = inf->dynrelbuf;
+      rel_high = rel_low + rel_count - 1;
+      while (rel_low <= rel_high)
+	{
+	  arelent **rel_mid = &rel_low[(rel_high - rel_low) / 2];
+	  arelent * rel = *rel_mid;
+
+	  if (rel->address == vma)
+	    {
+	      /* Absolute relocations do not provide a more helpful
+	         symbolic address.  Find a non-absolute relocation
+		 with the same address.  */
+	      arelent **rel_vma = rel_mid;
+	      for (rel_mid--;
+		   rel_mid >= rel_low && rel_mid[0]->address == vma;
+		   rel_mid--)
+		rel_vma = rel_mid;
+
+	      for (; rel_vma <= rel_high && rel_vma[0]->address == vma;
+		   rel_vma++)
+		{
+		  rel = *rel_vma;
+		  if (rel->sym_ptr_ptr != NULL
+		      && ! bfd_is_abs_section ((* rel->sym_ptr_ptr)->section))
+		    {
+		      if (place != NULL)
+			* place = thisplace;
+		      return * rel->sym_ptr_ptr;
+		    }
+		}
+	      break;
+	    }
+
+	  if (vma < rel->address)
+	    rel_high = rel_mid;
+	  else if (vma >= rel_mid[1]->address)
+	    rel_low = rel_mid + 1;
+	  else
+	    break;
+	}
+    }
+
+  if (place != NULL)
+    *place = thisplace;
+
+  return sorted_syms[thisplace];
+}
+
+/* Print an address and the offset to the nearest symbol.  */
+
+static void
+objdump_print_addr_with_sym (bfd *abfd, asection *sec, asymbol *sym,
+			     bfd_vma vma, struct disassemble_info *inf,
+			     bool skip_zeroes)
+{
+  if (!no_addresses)
+    {
+      objdump_print_value (vma, inf, skip_zeroes);
+      (*inf->fprintf_func) (inf->stream, " ");
+    }
+
+  if (sym == NULL)
+    {
+      bfd_vma secaddr;
+
+      (*inf->fprintf_func) (inf->stream, "<%s",
+			    sanitize_string (bfd_section_name (sec)));
+      secaddr = bfd_section_vma (sec);
+      if (vma < secaddr)
+	{
+	  (*inf->fprintf_func) (inf->stream, "-0x");
+	  objdump_print_value (secaddr - vma, inf, true);
+	}
+      else if (vma > secaddr)
+	{
+	  (*inf->fprintf_func) (inf->stream, "+0x");
+	  objdump_print_value (vma - secaddr, inf, true);
+	}
+      (*inf->fprintf_func) (inf->stream, ">");
+    }
+  else
+    {
+      (*inf->fprintf_func) (inf->stream, "<");
+
+      objdump_print_symname (abfd, inf, sym);
+
+      if (bfd_asymbol_value (sym) == vma)
+	;
+      /* Undefined symbols in an executables and dynamic objects do not have
+	 a value associated with them, so it does not make sense to display
+	 an offset relative to them.  Normally we would not be provided with
+	 this kind of symbol, but the target backend might choose to do so,
+	 and the code in find_symbol_for_address might return an as yet
+	 unresolved symbol associated with a dynamic reloc.  */
+      else if ((bfd_get_file_flags (abfd) & (EXEC_P | DYNAMIC))
+	       && bfd_is_und_section (sym->section))
+	;
+      else if (bfd_asymbol_value (sym) > vma)
+	{
+	  (*inf->fprintf_func) (inf->stream, "-0x");
+	  objdump_print_value (bfd_asymbol_value (sym) - vma, inf, true);
+	}
+      else if (vma > bfd_asymbol_value (sym))
+	{
+	  (*inf->fprintf_func) (inf->stream, "+0x");
+	  objdump_print_value (vma - bfd_asymbol_value (sym), inf, true);
+	}
+
+      (*inf->fprintf_func) (inf->stream, ">");
+    }
+
+  if (display_file_offsets)
+    inf->fprintf_func (inf->stream, _(" (File Offset: 0x%lx)"),
+			(long int)(sec->filepos + (vma - sec->vma)));
+}
+
+/* Print an address (VMA), symbolically if possible.
+   If SKIP_ZEROES is TRUE, don't output leading zeroes.  */
+
+static void
+objdump_print_addr (bfd_vma vma,
+		    struct disassemble_info *inf,
+		    bool skip_zeroes)
+{
+  struct objdump_disasm_info *aux;
+  asymbol *sym = NULL;
+  bool skip_find = false;
+
+  aux = (struct objdump_disasm_info *) inf->application_data;
+
+  if (sorted_symcount < 1)
+    {
+      if (!no_addresses)
+	{
+	  (*inf->fprintf_func) (inf->stream, "0x");
+	  objdump_print_value (vma, inf, skip_zeroes);
+	}
+
+      if (display_file_offsets)
+	inf->fprintf_func (inf->stream, _(" (File Offset: 0x%lx)"),
+			   (long int) (inf->section->filepos
+				       + (vma - inf->section->vma)));
+      return;
+    }
+
+  if (aux->reloc != NULL
+      && aux->reloc->sym_ptr_ptr != NULL
+      && * aux->reloc->sym_ptr_ptr != NULL)
+    {
+      sym = * aux->reloc->sym_ptr_ptr;
+
+      /* Adjust the vma to the reloc.  */
+      vma += bfd_asymbol_value (sym);
+
+      if (bfd_is_und_section (bfd_asymbol_section (sym)))
+	skip_find = true;
+    }
+
+  if (!skip_find)
+    sym = find_symbol_for_address (vma, inf, NULL);
+
+  objdump_print_addr_with_sym (aux->abfd, inf->section, sym, vma, inf,
+			       skip_zeroes);
+}
+
+/* Print VMA to INFO.  This function is passed to the disassembler
+   routine.  */
+
+static void
+objdump_print_address (bfd_vma vma, struct disassemble_info *inf)
+{
+  objdump_print_addr (vma, inf, ! prefix_addresses);
+}
+
+/* Determine if the given address has a symbol associated with it.  */
+
+static asymbol *
+objdump_symbol_at_address (bfd_vma vma, struct disassemble_info * inf)
+{
+  asymbol * sym;
+
+  sym = find_symbol_for_address (vma, inf, NULL);
+  if (sym != NULL && bfd_asymbol_value (sym) == vma)
+    return sym;
+
+  return NULL;
+}
+
+/* Hold the last function name and the last line number we displayed
+   in a disassembly.  */
+
+static char *prev_functionname;
+static unsigned int prev_line;
+static unsigned int prev_discriminator;
+
+/* We keep a list of all files that we have seen when doing a
+   disassembly with source, so that we know how much of the file to
+   display.  This can be important for inlined functions.  */
+
+struct print_file_list
+{
+  struct print_file_list *next;
+  const char *filename;
+  const char *modname;
+  const char *map;
+  size_t mapsize;
+  const char **linemap;
+  unsigned maxline;
+  unsigned last_line;
+  unsigned max_printed;
+  int first;
+};
+
+static struct print_file_list *print_files;
+
+/* The number of preceding context lines to show when we start
+   displaying a file for the first time.  */
+
+#define SHOW_PRECEDING_CONTEXT_LINES (5)
+
+/* Read a complete file into memory.  */
+
+static const char *
+slurp_file (const char *fn, size_t *size, struct stat *fst)
+{
+#ifdef HAVE_MMAP
+  int ps = getpagesize ();
+  size_t msize;
+#endif
+  const char *map;
+  int fd = open (fn, O_RDONLY | O_BINARY);
+
+  if (fd < 0)
+    return NULL;
+  if (fstat (fd, fst) < 0)
+    {
+      close (fd);
+      return NULL;
+    }
+  *size = fst->st_size;
+#ifdef HAVE_MMAP
+  msize = (*size + ps - 1) & ~(ps - 1);
+  map = mmap (NULL, msize, PROT_READ, MAP_SHARED, fd, 0);
+  if (map != (char *) -1L)
+    {
+      close (fd);
+      return map;
+    }
+#endif
+  map = (const char *) malloc (*size);
+  if (!map || (size_t) read (fd, (char *) map, *size) != *size)
+    {
+      free ((void *) map);
+      map = NULL;
+    }
+  close (fd);
+  return map;
+}
+
+#define line_map_decrease 5
+
+/* Precompute array of lines for a mapped file. */
+
+static const char **
+index_file (const char *map, size_t size, unsigned int *maxline)
+{
+  const char *p, *lstart, *end;
+  int chars_per_line = 45; /* First iteration will use 40.  */
+  unsigned int lineno;
+  const char **linemap = NULL;
+  unsigned long line_map_size = 0;
+
+  lineno = 0;
+  lstart = map;
+  end = map + size;
+
+  for (p = map; p < end; p++)
+    {
+      if (*p == '\n')
+	{
+	  if (p + 1 < end && p[1] == '\r')
+	    p++;
+	}
+      else if (*p == '\r')
+	{
+	  if (p + 1 < end && p[1] == '\n')
+	    p++;
+	}
+      else
+	continue;
+
+      /* End of line found.  */
+
+      if (linemap == NULL || line_map_size < lineno + 1)
+	{
+	  unsigned long newsize;
+
+	  chars_per_line -= line_map_decrease;
+	  if (chars_per_line <= 1)
+	    chars_per_line = 1;
+	  line_map_size = size / chars_per_line + 1;
+	  if (line_map_size < lineno + 1)
+	    line_map_size = lineno + 1;
+	  newsize = line_map_size * sizeof (char *);
+	  linemap = (const char **) xrealloc (linemap, newsize);
+	}
+
+      linemap[lineno++] = lstart;
+      lstart = p + 1;
+    }
+
+  *maxline = lineno;
+  return linemap;
+}
+
+/* Tries to open MODNAME, and if successful adds a node to print_files
+   linked list and returns that node.  Returns NULL on failure.  */
+
+static struct print_file_list *
+try_print_file_open (const char *origname, const char *modname, struct stat *fst)
+{
+  struct print_file_list *p;
+
+  p = (struct print_file_list *) xmalloc (sizeof (struct print_file_list));
+
+  p->map = slurp_file (modname, &p->mapsize, fst);
+  if (p->map == NULL)
+    {
+      free (p);
+      return NULL;
+    }
+
+  p->linemap = index_file (p->map, p->mapsize, &p->maxline);
+  p->last_line = 0;
+  p->max_printed = 0;
+  p->filename = origname;
+  p->modname = modname;
+  p->next = print_files;
+  p->first = 1;
+  print_files = p;
+  return p;
+}
+
+/* If the source file, as described in the symtab, is not found
+   try to locate it in one of the paths specified with -I
+   If found, add location to print_files linked list.  */
+
+static struct print_file_list *
+update_source_path (const char *filename, bfd *abfd)
+{
+  struct print_file_list *p;
+  const char *fname;
+  struct stat fst;
+  int i;
+
+  p = try_print_file_open (filename, filename, &fst);
+  if (p == NULL)
+    {
+      if (include_path_count == 0)
+	return NULL;
+
+      /* Get the name of the file.  */
+      fname = lbasename (filename);
+
+      /* If file exists under a new path, we need to add it to the list
+	 so that show_line knows about it.  */
+      for (i = 0; i < include_path_count; i++)
+	{
+	  char *modname = concat (include_paths[i], "/", fname,
+				  (const char *) 0);
+
+	  p = try_print_file_open (filename, modname, &fst);
+	  if (p)
+	    break;
+
+	  free (modname);
+	}
+    }
+
+  if (p != NULL)
+    {
+      long mtime = bfd_get_mtime (abfd);
+
+      if (fst.st_mtime > mtime)
+	warn (_("source file %s is more recent than object file\n"),
+	      filename);
+    }
+
+  return p;
+}
+
+/* Print a source file line.  */
+
+static void
+print_line (struct print_file_list *p, unsigned int linenum)
+{
+  const char *l;
+  size_t len;
+
+  --linenum;
+  if (linenum >= p->maxline)
+    return;
+  l = p->linemap [linenum];
+  if (source_comment != NULL && strlen (l) > 0)
+    printf ("%s", source_comment);
+  len = strcspn (l, "\n\r");
+  /* Test fwrite return value to quiet glibc warning.  */
+  if (len == 0 || fwrite (l, len, 1, stdout) == 1)
+    putchar ('\n');
+}
+
+/* Print a range of source code lines. */
+
+static void
+dump_lines (struct print_file_list *p, unsigned int start, unsigned int end)
+{
+  if (p->map == NULL)
+    return;
+  while (start <= end)
+    {
+      print_line (p, start);
+      start++;
+    }
+}
+
+/* Show the line number, or the source line, in a disassembly
+   listing.  */
+
+static void
+show_line (bfd *abfd, asection *section, bfd_vma addr_offset)
+{
+  const char *filename;
+  const char *functionname;
+  unsigned int linenumber;
+  unsigned int discriminator;
+  bool reloc;
+  char *path = NULL;
+
+  if (! with_line_numbers && ! with_source_code)
+    return;
+
+  if (! bfd_find_nearest_line_discriminator (abfd, section, syms, addr_offset,
+					     &filename, &functionname,
+					     &linenumber, &discriminator))
+    return;
+
+  if (filename != NULL && *filename == '\0')
+    filename = NULL;
+  if (functionname != NULL && *functionname == '\0')
+    functionname = NULL;
+
+  if (filename
+      && IS_ABSOLUTE_PATH (filename)
+      && prefix)
+    {
+      char *path_up;
+      const char *fname = filename;
+
+      path = xmalloc (prefix_length + 1 + strlen (filename));
+
+      if (prefix_length)
+	memcpy (path, prefix, prefix_length);
+      path_up = path + prefix_length;
+
+      /* Build relocated filename, stripping off leading directories
+	 from the initial filename if requested.  */
+      if (prefix_strip > 0)
+	{
+	  int level = 0;
+	  const char *s;
+
+	  /* Skip selected directory levels.  */
+	  for (s = fname + 1; *s != '\0' && level < prefix_strip; s++)
+	    if (IS_DIR_SEPARATOR (*s))
+	      {
+		fname = s;
+		level++;
+	      }
+	}
+
+      /* Update complete filename.  */
+      strcpy (path_up, fname);
+
+      filename = path;
+      reloc = true;
+    }
+  else
+    reloc = false;
+
+  if (with_line_numbers)
+    {
+      if (functionname != NULL
+	  && (prev_functionname == NULL
+	      || strcmp (functionname, prev_functionname) != 0))
+	{
+	  char *demangle_alloc = NULL;
+	  if (do_demangle && functionname[0] != '\0')
+	    {
+	      /* Demangle the name.  */
+	      demangle_alloc = bfd_demangle (abfd, functionname,
+	                                          demangle_flags);
+	    }
+
+	  /* Demangling adds trailing parens, so don't print those.  */
+	  if (demangle_alloc != NULL)
+	    printf ("%s:\n", sanitize_string (demangle_alloc));
+	  else
+	    printf ("%s():\n", sanitize_string (functionname));
+
+	  prev_line = -1;
+	  free (demangle_alloc);
+	}
+      if (linenumber > 0
+	  && (linenumber != prev_line
+	      || discriminator != prev_discriminator))
+	{
+	  if (discriminator > 0)
+	    printf ("%s:%u (discriminator %u)\n",
+		    filename == NULL ? "???" : sanitize_string (filename),
+		    linenumber, discriminator);
+	  else
+	    printf ("%s:%u\n", filename == NULL
+		    ? "???" : sanitize_string (filename),
+		    linenumber);
+	}
+      if (unwind_inlines)
+	{
+	  const char *filename2;
+	  const char *functionname2;
+	  unsigned line2;
+
+	  while (bfd_find_inliner_info (abfd, &filename2, &functionname2,
+					&line2))
+	    {
+	      printf ("inlined by %s:%u",
+		      sanitize_string (filename2), line2);
+	      printf (" (%s)\n", sanitize_string (functionname2));
+	    }
+	}
+    }
+
+  if (with_source_code
+      && filename != NULL
+      && linenumber > 0)
+    {
+      struct print_file_list **pp, *p;
+      unsigned l;
+
+      for (pp = &print_files; *pp != NULL; pp = &(*pp)->next)
+	if (filename_cmp ((*pp)->filename, filename) == 0)
+	  break;
+      p = *pp;
+
+      if (p == NULL)
+	{
+	  if (reloc)
+	    filename = xstrdup (filename);
+	  p = update_source_path (filename, abfd);
+	}
+
+      if (p != NULL && linenumber != p->last_line)
+	{
+	  if (file_start_context && p->first)
+	    l = 1;
+	  else
+	    {
+	      l = linenumber - SHOW_PRECEDING_CONTEXT_LINES;
+	      if (l >= linenumber)
+		l = 1;
+	      if (p->max_printed >= l)
+		{
+		  if (p->max_printed < linenumber)
+		    l = p->max_printed + 1;
+		  else
+		    l = linenumber;
+		}
+	    }
+	  dump_lines (p, l, linenumber);
+	  if (p->max_printed < linenumber)
+	    p->max_printed = linenumber;
+	  p->last_line = linenumber;
+	  p->first = 0;
+	}
+    }
+
+  if (functionname != NULL
+      && (prev_functionname == NULL
+	  || strcmp (functionname, prev_functionname) != 0))
+    {
+      if (prev_functionname != NULL)
+	free (prev_functionname);
+      prev_functionname = (char *) xmalloc (strlen (functionname) + 1);
+      strcpy (prev_functionname, functionname);
+    }
+
+  if (linenumber > 0 && linenumber != prev_line)
+    prev_line = linenumber;
+
+  if (discriminator != prev_discriminator)
+    prev_discriminator = discriminator;
+
+  if (path)
+    free (path);
+}
+
+/* Pseudo FILE object for strings.  */
+typedef struct
+{
+  char *buffer;
+  size_t pos;
+  size_t alloc;
+} SFILE;
+
+/* sprintf to a "stream".  */
+
+static int ATTRIBUTE_PRINTF_2
+objdump_sprintf (SFILE *f, const char *format, ...)
+{
+  size_t n;
+  va_list args;
+
+  while (1)
+    {
+      size_t space = f->alloc - f->pos;
+
+      va_start (args, format);
+      n = vsnprintf (f->buffer + f->pos, space, format, args);
+      va_end (args);
+
+      if (space > n)
+	break;
+
+      f->alloc = (f->alloc + n) * 2;
+      f->buffer = (char *) xrealloc (f->buffer, f->alloc);
+    }
+  f->pos += n;
+
+  return n;
+}
+
+/* Code for generating (colored) diagrams of control flow start and end
+   points.  */
+
+/* Structure used to store the properties of a jump.  */
+
+struct jump_info
+{
+  /* The next jump, or NULL if this is the last object.  */
+  struct jump_info *next;
+  /* The previous jump, or NULL if this is the first object.  */
+  struct jump_info *prev;
+  /* The start addresses of the jump.  */
+  struct
+    {
+      /* The list of start addresses.  */
+      bfd_vma *addresses;
+      /* The number of elements.  */
+      size_t count;
+      /* The maximum number of elements that fit into the array.  */
+      size_t max_count;
+    } start;
+  /* The end address of the jump.  */
+  bfd_vma end;
+  /* The drawing level of the jump.  */
+  int level;
+};
+
+/* Construct a jump object for a jump from start
+   to end with the corresponding level.  */
+
+static struct jump_info *
+jump_info_new (bfd_vma start, bfd_vma end, int level)
+{
+  struct jump_info *result = xmalloc (sizeof (struct jump_info));
+
+  result->next = NULL;
+  result->prev = NULL;
+  result->start.addresses = xmalloc (sizeof (bfd_vma *) * 2);
+  result->start.addresses[0] = start;
+  result->start.count = 1;
+  result->start.max_count = 2;
+  result->end = end;
+  result->level = level;
+
+  return result;
+}
+
+/* Free a jump object and return the next object
+   or NULL if this was the last one.  */
+
+static struct jump_info *
+jump_info_free (struct jump_info *ji)
+{
+  struct jump_info *result = NULL;
+
+  if (ji)
+    {
+      result = ji->next;
+      if (ji->start.addresses)
+	free (ji->start.addresses);
+      free (ji);
+    }
+
+  return result;
+}
+
+/* Get the smallest value of all start and end addresses.  */
+
+static bfd_vma
+jump_info_min_address (const struct jump_info *ji)
+{
+  bfd_vma min_address = ji->end;
+  size_t i;
+
+  for (i = ji->start.count; i-- > 0;)
+    if (ji->start.addresses[i] < min_address)
+      min_address = ji->start.addresses[i];
+  return min_address;
+}
+
+/* Get the largest value of all start and end addresses.  */
+
+static bfd_vma
+jump_info_max_address (const struct jump_info *ji)
+{
+  bfd_vma max_address = ji->end;
+  size_t i;
+
+  for (i = ji->start.count; i-- > 0;)
+    if (ji->start.addresses[i] > max_address)
+      max_address = ji->start.addresses[i];
+  return max_address;
+}
+
+/* Get the target address of a jump.  */
+
+static bfd_vma
+jump_info_end_address (const struct jump_info *ji)
+{
+  return ji->end;
+}
+
+/* Test if an address is one of the start addresses of a jump.  */
+
+static bool
+jump_info_is_start_address (const struct jump_info *ji, bfd_vma address)
+{
+  bool result = false;
+  size_t i;
+
+  for (i = ji->start.count; i-- > 0;)
+    if (address == ji->start.addresses[i])
+      {
+	result = true;
+	break;
+      }
+
+  return result;
+}
+
+/* Test if an address is the target address of a jump.  */
+
+static bool
+jump_info_is_end_address (const struct jump_info *ji, bfd_vma address)
+{
+  return (address == ji->end);
+}
+
+/* Get the difference between the smallest and largest address of a jump.  */
+
+static bfd_vma
+jump_info_size (const struct jump_info *ji)
+{
+  return jump_info_max_address (ji) - jump_info_min_address (ji);
+}
+
+/* Unlink a jump object from a list.  */
+
+static void
+jump_info_unlink (struct jump_info *node,
+		  struct jump_info **base)
+{
+  if (node->next)
+    node->next->prev = node->prev;
+  if (node->prev)
+    node->prev->next = node->next;
+  else
+    *base = node->next;
+  node->next = NULL;
+  node->prev = NULL;
+}
+
+/* Insert unlinked jump info node into a list.  */
+
+static void
+jump_info_insert (struct jump_info *node,
+		  struct jump_info *target,
+		  struct jump_info **base)
+{
+  node->next = target;
+  node->prev = target->prev;
+  target->prev = node;
+  if (node->prev)
+    node->prev->next = node;
+  else
+    *base = node;
+}
+
+/* Add unlinked node to the front of a list.  */
+
+static void
+jump_info_add_front (struct jump_info *node,
+		     struct jump_info **base)
+{
+  node->next = *base;
+  if (node->next)
+    node->next->prev = node;
+  node->prev = NULL;
+  *base = node;
+}
+
+/* Move linked node to target position.  */
+
+static void
+jump_info_move_linked (struct jump_info *node,
+		       struct jump_info *target,
+		       struct jump_info **base)
+{
+  /* Unlink node.  */
+  jump_info_unlink (node, base);
+  /* Insert node at target position.  */
+  jump_info_insert (node, target, base);
+}
+
+/* Test if two jumps intersect.  */
+
+static bool
+jump_info_intersect (const struct jump_info *a,
+		     const struct jump_info *b)
+{
+  return ((jump_info_max_address (a) >= jump_info_min_address (b))
+	  && (jump_info_min_address (a) <= jump_info_max_address (b)));
+}
+
+/* Merge two compatible jump info objects.  */
+
+static void
+jump_info_merge (struct jump_info **base)
+{
+  struct jump_info *a;
+
+  for (a = *base; a; a = a->next)
+    {
+      struct jump_info *b;
+
+      for (b = a->next; b; b = b->next)
+	{
+	  /* Merge both jumps into one.  */
+	  if (a->end == b->end)
+	    {
+	      /* Reallocate addresses.  */
+	      size_t needed_size = a->start.count + b->start.count;
+	      size_t i;
+
+	      if (needed_size > a->start.max_count)
+		{
+		  a->start.max_count += b->start.max_count;
+		  a->start.addresses =
+		    xrealloc (a->start.addresses,
+			      a->start.max_count * sizeof (bfd_vma *));
+		}
+
+	      /* Append start addresses.  */
+	      for (i = 0; i < b->start.count; ++i)
+		a->start.addresses[a->start.count++] =
+		  b->start.addresses[i];
+
+	      /* Remove and delete jump.  */
+	      struct jump_info *tmp = b->prev;
+	      jump_info_unlink (b, base);
+	      jump_info_free (b);
+	      b = tmp;
+	    }
+	}
+    }
+}
+
+/* Sort jumps by their size and starting point using a stable
+   minsort. This could be improved if sorting performance is
+   an issue, for example by using mergesort.  */
+
+static void
+jump_info_sort (struct jump_info **base)
+{
+  struct jump_info *current_element = *base;
+
+  while (current_element)
+    {
+      struct jump_info *best_match = current_element;
+      struct jump_info *runner = current_element->next;
+      bfd_vma best_size = jump_info_size (best_match);
+
+      while (runner)
+	{
+	  bfd_vma runner_size = jump_info_size (runner);
+
+	  if ((runner_size < best_size)
+	      || ((runner_size == best_size)
+		  && (jump_info_min_address (runner)
+		      < jump_info_min_address (best_match))))
+	    {
+	      best_match = runner;
+	      best_size = runner_size;
+	    }
+
+	  runner = runner->next;
+	}
+
+      if (best_match == current_element)
+	current_element = current_element->next;
+      else
+	jump_info_move_linked (best_match, current_element, base);
+    }
+}
+
+/* Visualize all jumps at a given address.  */
+
+static void
+jump_info_visualize_address (bfd_vma address,
+			     int max_level,
+			     char *line_buffer,
+			     uint8_t *color_buffer)
+{
+  struct jump_info *ji = detected_jumps;
+  size_t len = (max_level + 1) * 3;
+
+  /* Clear line buffer.  */
+  memset (line_buffer, ' ', len);
+  memset (color_buffer, 0, len);
+
+  /* Iterate over jumps and add their ASCII art.  */
+  while (ji)
+    {
+      /* Discard jumps that are never needed again.  */
+      if (jump_info_max_address (ji) < address)
+	{
+	  struct jump_info *tmp = ji;
+
+	  ji = ji->next;
+	  jump_info_unlink (tmp, &detected_jumps);
+	  jump_info_free (tmp);
+	  continue;
+	}
+
+      /* This jump intersects with the current address.  */
+      if (jump_info_min_address (ji) <= address)
+	{
+	  /* Hash target address to get an even
+	     distribution between all values.  */
+	  bfd_vma hash_address = jump_info_end_address (ji);
+	  uint8_t color = iterative_hash_object (hash_address, 0);
+	  /* Fetch line offset.  */
+	  int offset = (max_level - ji->level) * 3;
+
+	  /* Draw start line.  */
+	  if (jump_info_is_start_address (ji, address))
+	    {
+	      size_t i = offset + 1;
+
+	      for (; i < len - 1; ++i)
+		if (line_buffer[i] == ' ')
+		  {
+		    line_buffer[i] = '-';
+		    color_buffer[i] = color;
+		  }
+
+	      if (line_buffer[i] == ' ')
+		{
+		  line_buffer[i] = '-';
+		  color_buffer[i] = color;
+		}
+	      else if (line_buffer[i] == '>')
+		{
+		  line_buffer[i] = 'X';
+		  color_buffer[i] = color;
+		}
+
+	      if (line_buffer[offset] == ' ')
+		{
+		  if (address <= ji->end)
+		    line_buffer[offset] =
+		      (jump_info_min_address (ji) == address) ? '/': '+';
+		  else
+		    line_buffer[offset] =
+		      (jump_info_max_address (ji) == address) ? '\\': '+';
+		  color_buffer[offset] = color;
+		}
+	    }
+	  /* Draw jump target.  */
+	  else if (jump_info_is_end_address (ji, address))
+	    {
+	      size_t i = offset + 1;
+
+	      for (; i < len - 1; ++i)
+		if (line_buffer[i] == ' ')
+		  {
+		    line_buffer[i] = '-';
+		    color_buffer[i] = color;
+		  }
+
+	      if (line_buffer[i] == ' ')
+		{
+		  line_buffer[i] = '>';
+		  color_buffer[i] = color;
+		}
+	      else if (line_buffer[i] == '-')
+		{
+		  line_buffer[i] = 'X';
+		  color_buffer[i] = color;
+		}
+
+	      if (line_buffer[offset] == ' ')
+		{
+		  if (jump_info_min_address (ji) < address)
+		    line_buffer[offset] =
+		      (jump_info_max_address (ji) > address) ? '>' : '\\';
+		  else
+		    line_buffer[offset] = '/';
+		  color_buffer[offset] = color;
+		}
+	    }
+	  /* Draw intermediate line segment.  */
+	  else if (line_buffer[offset] == ' ')
+	    {
+	      line_buffer[offset] = '|';
+	      color_buffer[offset] = color;
+	    }
+	}
+
+      ji = ji->next;
+    }
+}
+
+/* Clone of disassemble_bytes to detect jumps inside a function.  */
+/* FIXME: is this correct? Can we strip it down even further?  */
+
+static struct jump_info *
+disassemble_jumps (struct disassemble_info * inf,
+		   disassembler_ftype        disassemble_fn,
+		   bfd_vma                   start_offset,
+		   bfd_vma                   stop_offset,
+		   bfd_vma		     rel_offset,
+		   arelent ***               relppp,
+		   arelent **                relppend)
+{
+  struct objdump_disasm_info *aux;
+  struct jump_info *jumps = NULL;
+  asection *section;
+  bfd_vma addr_offset;
+  unsigned int opb = inf->octets_per_byte;
+  int octets = opb;
+  SFILE sfile;
+
+  aux = (struct objdump_disasm_info *) inf->application_data;
+  section = inf->section;
+
+  sfile.alloc = 120;
+  sfile.buffer = (char *) xmalloc (sfile.alloc);
+  sfile.pos = 0;
+
+  inf->insn_info_valid = 0;
+  inf->fprintf_func = (fprintf_ftype) objdump_sprintf;
+  inf->stream = &sfile;
+
+  addr_offset = start_offset;
+  while (addr_offset < stop_offset)
+    {
+      int previous_octets;
+
+      /* Remember the length of the previous instruction.  */
+      previous_octets = octets;
+      octets = 0;
+
+      sfile.pos = 0;
+      inf->bytes_per_line = 0;
+      inf->bytes_per_chunk = 0;
+      inf->flags = ((disassemble_all ? DISASSEMBLE_DATA : 0)
+        | (wide_output ? WIDE_OUTPUT : 0));
+      if (machine)
+	inf->flags |= USER_SPECIFIED_MACHINE_TYPE;
+
+      if (inf->disassembler_needs_relocs
+	  && (bfd_get_file_flags (aux->abfd) & EXEC_P) == 0
+	  && (bfd_get_file_flags (aux->abfd) & DYNAMIC) == 0
+	  && *relppp < relppend)
+	{
+	  bfd_signed_vma distance_to_rel;
+
+	  distance_to_rel = (**relppp)->address - (rel_offset + addr_offset);
+
+	  /* Check to see if the current reloc is associated with
+	     the instruction that we are about to disassemble.  */
+	  if (distance_to_rel == 0
+	      /* FIXME: This is wrong.  We are trying to catch
+		 relocs that are addressed part way through the
+		 current instruction, as might happen with a packed
+		 VLIW instruction.  Unfortunately we do not know the
+		 length of the current instruction since we have not
+		 disassembled it yet.  Instead we take a guess based
+		 upon the length of the previous instruction.  The
+		 proper solution is to have a new target-specific
+		 disassembler function which just returns the length
+		 of an instruction at a given address without trying
+		 to display its disassembly. */
+	      || (distance_to_rel > 0
+		&& distance_to_rel < (bfd_signed_vma) (previous_octets/ opb)))
+	    {
+	      inf->flags |= INSN_HAS_RELOC;
+	    }
+	}
+
+      if (! disassemble_all
+	  && (section->flags & (SEC_CODE | SEC_HAS_CONTENTS))
+	  == (SEC_CODE | SEC_HAS_CONTENTS))
+	/* Set a stop_vma so that the disassembler will not read
+	   beyond the next symbol.  We assume that symbols appear on
+	   the boundaries between instructions.  We only do this when
+	   disassembling code of course, and when -D is in effect.  */
+	inf->stop_vma = section->vma + stop_offset;
+
+      inf->stop_offset = stop_offset;
+
+      /* Extract jump information.  */
+      inf->insn_info_valid = 0;
+      octets = (*disassemble_fn) (section->vma + addr_offset, inf);
+      /* Test if a jump was detected.  */
+      if (inf->insn_info_valid
+	  && ((inf->insn_type == dis_branch)
+	      || (inf->insn_type == dis_condbranch)
+	      || (inf->insn_type == dis_jsr)
+	      || (inf->insn_type == dis_condjsr))
+	  && (inf->target >= section->vma + start_offset)
+	  && (inf->target < section->vma + stop_offset))
+	{
+	  struct jump_info *ji =
+	    jump_info_new (section->vma + addr_offset, inf->target, -1);
+	  jump_info_add_front (ji, &jumps);
+	}
+
+      inf->stop_vma = 0;
+
+      addr_offset += octets / opb;
+    }
+
+  inf->fprintf_func = (fprintf_ftype) fprintf;
+  inf->stream = stdout;
+
+  free (sfile.buffer);
+
+  /* Merge jumps.  */
+  jump_info_merge (&jumps);
+  /* Process jumps.  */
+  jump_info_sort (&jumps);
+
+  /* Group jumps by level.  */
+  struct jump_info *last_jump = jumps;
+  int max_level = -1;
+
+  while (last_jump)
+    {
+      /* The last jump is part of the next group.  */
+      struct jump_info *base = last_jump;
+      /* Increment level.  */
+      base->level = ++max_level;
+
+      /* Find jumps that can be combined on the same
+	 level, with the largest jumps tested first.
+	 This has the advantage that large jumps are on
+	 lower levels and do not intersect with small
+	 jumps that get grouped on higher levels.  */
+      struct jump_info *exchange_item = last_jump->next;
+      struct jump_info *it = exchange_item;
+
+      for (; it; it = it->next)
+	{
+	  /* Test if the jump intersects with any
+	     jump from current group.  */
+	  bool ok = true;
+	  struct jump_info *it_collision;
+
+	  for (it_collision = base;
+	       it_collision != exchange_item;
+	       it_collision = it_collision->next)
+	    {
+	      /* This jump intersects so we leave it out.  */
+	      if (jump_info_intersect (it_collision, it))
+		{
+		  ok = false;
+		  break;
+		}
+	    }
+
+	  /* Add jump to group.  */
+	  if (ok)
+	    {
+	      /* Move current element to the front.  */
+	      if (it != exchange_item)
+		{
+		  struct jump_info *save = it->prev;
+		  jump_info_move_linked (it, exchange_item, &jumps);
+		  last_jump = it;
+		  it = save;
+		}
+	      else
+		{
+		  last_jump = exchange_item;
+		  exchange_item = exchange_item->next;
+		}
+	      last_jump->level = max_level;
+	    }
+	}
+
+      /* Move to next group.  */
+      last_jump = exchange_item;
+    }
+
+  return jumps;
+}
+
+/* The number of zeroes we want to see before we start skipping them.
+   The number is arbitrarily chosen.  */
+
+#define DEFAULT_SKIP_ZEROES 8
+
+/* The number of zeroes to skip at the end of a section.  If the
+   number of zeroes at the end is between SKIP_ZEROES_AT_END and
+   SKIP_ZEROES, they will be disassembled.  If there are fewer than
+   SKIP_ZEROES_AT_END, they will be skipped.  This is a heuristic
+   attempt to avoid disassembling zeroes inserted by section
+   alignment.  */
+
+#define DEFAULT_SKIP_ZEROES_AT_END 3
+
+static int
+null_print (const void * stream ATTRIBUTE_UNUSED, const char * format ATTRIBUTE_UNUSED, ...)
+{
+  return 1;
+}
+
+/* Print out jump visualization.  */
+
+static void
+print_jump_visualisation (bfd_vma addr, int max_level, char *line_buffer,
+			  uint8_t *color_buffer)
+{
+  if (!line_buffer)
+    return;
+
+  jump_info_visualize_address (addr, max_level, line_buffer, color_buffer);
+
+  size_t line_buffer_size = strlen (line_buffer);
+  char last_color = 0;
+  size_t i;
+
+  for (i = 0; i <= line_buffer_size; ++i)
+    {
+      if (color_output)
+	{
+	  uint8_t color = (i < line_buffer_size) ? color_buffer[i]: 0;
+
+	  if (color != last_color)
+	    {
+	      if (color)
+		if (extended_color_output)
+		  /* Use extended 8bit color, but
+		     do not choose dark colors.  */
+		  printf ("\033[38;5;%dm", 124 + (color % 108));
+		else
+		  /* Use simple terminal colors.  */
+		  printf ("\033[%dm", 31 + (color % 7));
+	      else
+		/* Clear color.  */
+		printf ("\033[0m");
+	      last_color = color;
+	    }
+	}
+      putchar ((i < line_buffer_size) ? line_buffer[i]: ' ');
+    }
+}
+
+/* Disassemble some data in memory between given values.  */
+
+static void
+disassemble_bytes (struct disassemble_info *inf,
+		   disassembler_ftype disassemble_fn,
+		   bool insns,
+		   bfd_byte *data,
+		   bfd_vma start_offset,
+		   bfd_vma stop_offset,
+		   bfd_vma rel_offset,
+		   arelent ***relppp,
+		   arelent **relppend)
+{
+  struct objdump_disasm_info *aux;
+  asection *section;
+  unsigned int octets_per_line;
+  unsigned int skip_addr_chars;
+  bfd_vma addr_offset;
+  unsigned int opb = inf->octets_per_byte;
+  unsigned int skip_zeroes = inf->skip_zeroes;
+  unsigned int skip_zeroes_at_end = inf->skip_zeroes_at_end;
+  size_t octets;
+  SFILE sfile;
+
+  aux = (struct objdump_disasm_info *) inf->application_data;
+  section = inf->section;
+
+  sfile.alloc = 120;
+  sfile.buffer = (char *) xmalloc (sfile.alloc);
+  sfile.pos = 0;
+
+  if (insn_width)
+    octets_per_line = insn_width;
+  else if (insns)
+    octets_per_line = 4;
+  else
+    octets_per_line = 16;
+
+  /* Figure out how many characters to skip at the start of an
+     address, to make the disassembly look nicer.  We discard leading
+     zeroes in chunks of 4, ensuring that there is always a leading
+     zero remaining.  */
+  skip_addr_chars = 0;
+  if (!no_addresses && !prefix_addresses)
+    {
+      char buf[30];
+
+      bfd_sprintf_vma (aux->abfd, buf, section->vma + section->size / opb);
+
+      while (buf[skip_addr_chars] == '0')
+	++skip_addr_chars;
+
+      /* Don't discard zeros on overflow.  */
+      if (buf[skip_addr_chars] == '\0' && section->vma != 0)
+	skip_addr_chars = 0;
+
+      if (skip_addr_chars != 0)
+	skip_addr_chars = (skip_addr_chars - 1) & -4;
+    }
+
+  inf->insn_info_valid = 0;
+
+  /* Determine maximum level. */
+  uint8_t *color_buffer = NULL;
+  char *line_buffer = NULL;
+  int max_level = -1;
+
+  /* Some jumps were detected.  */
+  if (detected_jumps)
+    {
+      struct jump_info *ji;
+
+      /* Find maximum jump level.  */
+      for (ji = detected_jumps; ji; ji = ji->next)
+	{
+	  if (ji->level > max_level)
+	    max_level = ji->level;
+	}
+
+      /* Allocate buffers.  */
+      size_t len = (max_level + 1) * 3 + 1;
+      line_buffer = xmalloc (len);
+      line_buffer[len - 1] = 0;
+      color_buffer = xmalloc (len);
+      color_buffer[len - 1] = 0;
+    }
+
+  addr_offset = start_offset;
+  while (addr_offset < stop_offset)
+    {
+      bool need_nl = false;
+
+      octets = 0;
+
+      /* Make sure we don't use relocs from previous instructions.  */
+      aux->reloc = NULL;
+
+      /* If we see more than SKIP_ZEROES octets of zeroes, we just
+	 print `...'.  */
+      if (! disassemble_zeroes)
+	for (; addr_offset * opb + octets < stop_offset * opb; octets++)
+	  if (data[addr_offset * opb + octets] != 0)
+	    break;
+      if (! disassemble_zeroes
+	  && (inf->insn_info_valid == 0
+	      || inf->branch_delay_insns == 0)
+	  && (octets >= skip_zeroes
+	      || (addr_offset * opb + octets == stop_offset * opb
+		  && octets < skip_zeroes_at_end)))
+	{
+	  /* If there are more nonzero octets to follow, we only skip
+	     zeroes in multiples of 4, to try to avoid running over
+	     the start of an instruction which happens to start with
+	     zero.  */
+	  if (addr_offset * opb + octets != stop_offset * opb)
+	    octets &= ~3;
+
+	  /* If we are going to display more data, and we are displaying
+	     file offsets, then tell the user how many zeroes we skip
+	     and the file offset from where we resume dumping.  */
+	  if (display_file_offsets
+	      && addr_offset + octets / opb < stop_offset)
+	    printf (_("\t... (skipping %lu zeroes, "
+		      "resuming at file offset: 0x%lx)\n"),
+		    (unsigned long) (octets / opb),
+		    (unsigned long) (section->filepos
+				     + addr_offset + octets / opb));
+	  else
+	    printf ("\t...\n");
+	}
+      else
+	{
+	  char buf[50];
+	  unsigned int bpc = 0;
+	  unsigned int pb = 0;
+
+	  if (with_line_numbers || with_source_code)
+	    show_line (aux->abfd, section, addr_offset);
+
+	  if (no_addresses)
+	    printf ("\t");
+	  else if (!prefix_addresses)
+	    {
+	      char *s;
+
+	      bfd_sprintf_vma (aux->abfd, buf, section->vma + addr_offset);
+	      for (s = buf + skip_addr_chars; *s == '0'; s++)
+		*s = ' ';
+	      if (*s == '\0')
+		*--s = '0';
+	      printf ("%s:\t", buf + skip_addr_chars);
+	    }
+	  else
+	    {
+	      aux->require_sec = true;
+	      objdump_print_address (section->vma + addr_offset, inf);
+	      aux->require_sec = false;
+	      putchar (' ');
+	    }
+
+	  print_jump_visualisation (section->vma + addr_offset,
+				    max_level, line_buffer,
+				    color_buffer);
+
+	  if (insns)
+	    {
+	      int insn_size;
+
+	      sfile.pos = 0;
+	      inf->fprintf_func = (fprintf_ftype) objdump_sprintf;
+	      inf->stream = &sfile;
+	      inf->bytes_per_line = 0;
+	      inf->bytes_per_chunk = 0;
+	      inf->flags = ((disassemble_all ? DISASSEMBLE_DATA : 0)
+			    | (wide_output ? WIDE_OUTPUT : 0));
+	      if (machine)
+		inf->flags |= USER_SPECIFIED_MACHINE_TYPE;
+
+	      if (inf->disassembler_needs_relocs
+		  && (bfd_get_file_flags (aux->abfd) & EXEC_P) == 0
+		  && (bfd_get_file_flags (aux->abfd) & DYNAMIC) == 0
+		  && *relppp < relppend)
+		{
+		  bfd_signed_vma distance_to_rel;
+		  int max_reloc_offset
+		    = aux->abfd->arch_info->max_reloc_offset_into_insn;
+
+		  distance_to_rel = ((**relppp)->address - rel_offset
+				     - addr_offset);
+
+		  insn_size = 0;
+		  if (distance_to_rel > 0
+		      && (max_reloc_offset < 0
+			  || distance_to_rel <= max_reloc_offset))
+		    {
+		      /* This reloc *might* apply to the current insn,
+			 starting somewhere inside it.  Discover the length
+			 of the current insn so that the check below will
+			 work.  */
+		      if (insn_width)
+			insn_size = insn_width;
+		      else
+			{
+			  /* We find the length by calling the dissassembler
+			     function with a dummy print handler.  This should
+			     work unless the disassembler is not expecting to
+			     be called multiple times for the same address.
+
+			     This does mean disassembling the instruction
+			     twice, but we only do this when there is a high
+			     probability that there is a reloc that will
+			     affect the instruction.  */
+			  inf->fprintf_func = (fprintf_ftype) null_print;
+			  insn_size = disassemble_fn (section->vma
+						      + addr_offset, inf);
+			  inf->fprintf_func = (fprintf_ftype) objdump_sprintf;
+			}
+		    }
+
+		  /* Check to see if the current reloc is associated with
+		     the instruction that we are about to disassemble.  */
+		  if (distance_to_rel == 0
+		      || (distance_to_rel > 0
+			  && distance_to_rel < insn_size / (int) opb))
+		    {
+		      inf->flags |= INSN_HAS_RELOC;
+		      aux->reloc = **relppp;
+		    }
+		}
+
+	      if (! disassemble_all
+		  && ((section->flags & (SEC_CODE | SEC_HAS_CONTENTS))
+		      == (SEC_CODE | SEC_HAS_CONTENTS)))
+		/* Set a stop_vma so that the disassembler will not read
+		   beyond the next symbol.  We assume that symbols appear on
+		   the boundaries between instructions.  We only do this when
+		   disassembling code of course, and when -D is in effect.  */
+		inf->stop_vma = section->vma + stop_offset;
+
+	      inf->stop_offset = stop_offset;
+	      insn_size = (*disassemble_fn) (section->vma + addr_offset, inf);
+	      octets = insn_size;
+
+	      inf->stop_vma = 0;
+	      inf->fprintf_func = (fprintf_ftype) fprintf;
+	      inf->stream = stdout;
+	      if (insn_width == 0 && inf->bytes_per_line != 0)
+		octets_per_line = inf->bytes_per_line;
+	      if (insn_size < (int) opb)
+		{
+		  if (sfile.pos)
+		    printf ("%s\n", sfile.buffer);
+		  if (insn_size >= 0)
+		    {
+		      non_fatal (_("disassemble_fn returned length %d"),
+				 insn_size);
+		      exit_status = 1;
+		    }
+		  break;
+		}
+	    }
+	  else
+	    {
+	      bfd_vma j;
+
+	      octets = octets_per_line;
+	      if (addr_offset + octets / opb > stop_offset)
+		octets = (stop_offset - addr_offset) * opb;
+
+	      for (j = addr_offset * opb; j < addr_offset * opb + octets; ++j)
+		{
+		  if (ISPRINT (data[j]))
+		    buf[j - addr_offset * opb] = data[j];
+		  else
+		    buf[j - addr_offset * opb] = '.';
+		}
+	      buf[j - addr_offset * opb] = '\0';
+	    }
+
+	  if (prefix_addresses
+	      ? show_raw_insn > 0
+	      : show_raw_insn >= 0)
+	    {
+	      bfd_vma j;
+
+	      /* If ! prefix_addresses and ! wide_output, we print
+		 octets_per_line octets per line.  */
+	      pb = octets;
+	      if (pb > octets_per_line && ! prefix_addresses && ! wide_output)
+		pb = octets_per_line;
+
+	      if (inf->bytes_per_chunk)
+		bpc = inf->bytes_per_chunk;
+	      else
+		bpc = 1;
+
+	      for (j = addr_offset * opb; j < addr_offset * opb + pb; j += bpc)
+		{
+		  /* PR 21580: Check for a buffer ending early.  */
+		  if (j + bpc <= stop_offset * opb)
+		    {
+		      unsigned int k;
+
+		      if (inf->display_endian == BFD_ENDIAN_LITTLE)
+			{
+			  for (k = bpc; k-- != 0; )
+			    printf ("%02x", (unsigned) data[j + k]);
+			}
+		      else
+			{
+			  for (k = 0; k < bpc; k++)
+			    printf ("%02x", (unsigned) data[j + k]);
+			}
+		    }
+		  putchar (' ');
+		}
+
+	      for (; pb < octets_per_line; pb += bpc)
+		{
+		  unsigned int k;
+
+		  for (k = 0; k < bpc; k++)
+		    printf ("  ");
+		  putchar (' ');
+		}
+
+	      /* Separate raw data from instruction by extra space.  */
+	      if (insns)
+		putchar ('\t');
+	      else
+		printf ("    ");
+	    }
+
+	  if (! insns)
+	    printf ("%s", buf);
+	  else if (sfile.pos)
+	    printf ("%s", sfile.buffer);
+
+	  if (prefix_addresses
+	      ? show_raw_insn > 0
+	      : show_raw_insn >= 0)
+	    {
+	      while (pb < octets)
+		{
+		  bfd_vma j;
+		  char *s;
+
+		  putchar ('\n');
+		  j = addr_offset * opb + pb;
+
+		  if (no_addresses)
+		    printf ("\t");
+		  else
+		    {
+		      bfd_sprintf_vma (aux->abfd, buf, section->vma + j / opb);
+		      for (s = buf + skip_addr_chars; *s == '0'; s++)
+			*s = ' ';
+		      if (*s == '\0')
+			*--s = '0';
+		      printf ("%s:\t", buf + skip_addr_chars);
+		    }
+
+		  print_jump_visualisation (section->vma + j / opb,
+					    max_level, line_buffer,
+					    color_buffer);
+
+		  pb += octets_per_line;
+		  if (pb > octets)
+		    pb = octets;
+		  for (; j < addr_offset * opb + pb; j += bpc)
+		    {
+		      /* PR 21619: Check for a buffer ending early.  */
+		      if (j + bpc <= stop_offset * opb)
+			{
+			  unsigned int k;
+
+			  if (inf->display_endian == BFD_ENDIAN_LITTLE)
+			    {
+			      for (k = bpc; k-- != 0; )
+				printf ("%02x", (unsigned) data[j + k]);
+			    }
+			  else
+			    {
+			      for (k = 0; k < bpc; k++)
+				printf ("%02x", (unsigned) data[j + k]);
+			    }
+			}
+		      putchar (' ');
+		    }
+		}
+	    }
+
+	  if (!wide_output)
+	    putchar ('\n');
+	  else
+	    need_nl = true;
+	}
+
+      while ((*relppp) < relppend
+	     && (**relppp)->address < rel_offset + addr_offset + octets / opb)
+	{
+	  if (dump_reloc_info || dump_dynamic_reloc_info)
+	    {
+	      arelent *q;
+
+	      q = **relppp;
+
+	      if (wide_output)
+		putchar ('\t');
+	      else
+		printf ("\t\t\t");
+
+	      if (!no_addresses)
+		{
+		  objdump_print_value (section->vma - rel_offset + q->address,
+				       inf, true);
+		  printf (": ");
+		}
+
+	      if (q->howto == NULL)
+		printf ("*unknown*\t");
+	      else if (q->howto->name)
+		printf ("%s\t", q->howto->name);
+	      else
+		printf ("%d\t", q->howto->type);
+
+	      if (q->sym_ptr_ptr == NULL || *q->sym_ptr_ptr == NULL)
+		printf ("*unknown*");
+	      else
+		{
+		  const char *sym_name;
+
+		  sym_name = bfd_asymbol_name (*q->sym_ptr_ptr);
+		  if (sym_name != NULL && *sym_name != '\0')
+		    objdump_print_symname (aux->abfd, inf, *q->sym_ptr_ptr);
+		  else
+		    {
+		      asection *sym_sec;
+
+		      sym_sec = bfd_asymbol_section (*q->sym_ptr_ptr);
+		      sym_name = bfd_section_name (sym_sec);
+		      if (sym_name == NULL || *sym_name == '\0')
+			sym_name = "*unknown*";
+		      printf ("%s", sanitize_string (sym_name));
+		    }
+		}
+
+	      if (q->addend)
+		{
+		  bfd_vma addend = q->addend;
+		  if ((bfd_signed_vma) addend < 0)
+		    {
+		      printf ("-0x");
+		      addend = -addend;
+		    }
+		  else
+		    printf ("+0x");
+		  objdump_print_value (addend, inf, true);
+		}
+
+	      printf ("\n");
+	      need_nl = false;
+	    }
+	  ++(*relppp);
+	}
+
+      if (need_nl)
+	printf ("\n");
+
+      addr_offset += octets / opb;
+    }
+
+  free (sfile.buffer);
+  free (line_buffer);
+  free (color_buffer);
+}
+
+static void
+disassemble_section (bfd *abfd, asection *section, void *inf)
+{
+  const struct elf_backend_data *bed;
+  bfd_vma sign_adjust = 0;
+  struct disassemble_info *pinfo = (struct disassemble_info *) inf;
+  struct objdump_disasm_info *paux;
+  unsigned int opb = pinfo->octets_per_byte;
+  bfd_byte *data = NULL;
+  bfd_size_type datasize = 0;
+  arelent **rel_pp = NULL;
+  arelent **rel_ppstart = NULL;
+  arelent **rel_ppend;
+  bfd_vma stop_offset;
+  asymbol *sym = NULL;
+  long place = 0;
+  long rel_count;
+  bfd_vma rel_offset;
+  unsigned long addr_offset;
+  bool do_print;
+  enum loop_control
+  {
+   stop_offset_reached,
+   function_sym,
+   next_sym
+  } loop_until;
+
+  /* Sections that do not contain machine
+     code are not normally disassembled.  */
+  if (! disassemble_all
+      && only_list == NULL
+      && ((section->flags & (SEC_CODE | SEC_HAS_CONTENTS))
+	  != (SEC_CODE | SEC_HAS_CONTENTS)))
+    return;
+
+  if (! process_section_p (section))
+    return;
+
+  datasize = bfd_section_size (section);
+  if (datasize == 0)
+    return;
+
+  if (start_address == (bfd_vma) -1
+      || start_address < section->vma)
+    addr_offset = 0;
+  else
+    addr_offset = start_address - section->vma;
+
+  if (stop_address == (bfd_vma) -1)
+    stop_offset = datasize / opb;
+  else
+    {
+      if (stop_address < section->vma)
+	stop_offset = 0;
+      else
+	stop_offset = stop_address - section->vma;
+      if (stop_offset > datasize / opb)
+	stop_offset = datasize / opb;
+    }
+
+  if (addr_offset >= stop_offset)
+    return;
+
+  /* Decide which set of relocs to use.  Load them if necessary.  */
+  paux = (struct objdump_disasm_info *) pinfo->application_data;
+  if (pinfo->dynrelbuf && dump_dynamic_reloc_info)
+    {
+      rel_pp = pinfo->dynrelbuf;
+      rel_count = pinfo->dynrelcount;
+      /* Dynamic reloc addresses are absolute, non-dynamic are section
+	 relative.  REL_OFFSET specifies the reloc address corresponding
+	 to the start of this section.  */
+      rel_offset = section->vma;
+    }
+  else
+    {
+      rel_count = 0;
+      rel_pp = NULL;
+      rel_offset = 0;
+
+      if ((section->flags & SEC_RELOC) != 0
+	  && (dump_reloc_info || pinfo->disassembler_needs_relocs))
+	{
+	  long relsize;
+
+	  relsize = bfd_get_reloc_upper_bound (abfd, section);
+	  if (relsize < 0)
+	    bfd_fatal (bfd_get_filename (abfd));
+
+	  if (relsize > 0)
+	    {
+	      rel_ppstart = rel_pp = (arelent **) xmalloc (relsize);
+	      rel_count = bfd_canonicalize_reloc (abfd, section, rel_pp, syms);
+	      if (rel_count < 0)
+		bfd_fatal (bfd_get_filename (abfd));
+
+	      /* Sort the relocs by address.  */
+	      qsort (rel_pp, rel_count, sizeof (arelent *), compare_relocs);
+	    }
+	}
+    }
+  rel_ppend = rel_pp + rel_count;
+
+  if (!bfd_malloc_and_get_section (abfd, section, &data))
+    {
+      non_fatal (_("Reading section %s failed because: %s"),
+		 section->name, bfd_errmsg (bfd_get_error ()));
+      return;
+    }
+
+  pinfo->buffer = data;
+  pinfo->buffer_vma = section->vma;
+  pinfo->buffer_length = datasize;
+  pinfo->section = section;
+
+  /* Sort the symbols into value and section order.  */
+  compare_section = section;
+  if (sorted_symcount > 1)
+    qsort (sorted_syms, sorted_symcount, sizeof (asymbol *), compare_symbols);
+
+  /* Skip over the relocs belonging to addresses below the
+     start address.  */
+  while (rel_pp < rel_ppend
+	 && (*rel_pp)->address < rel_offset + addr_offset)
+    ++rel_pp;
+
+  printf (_("\nDisassembly of section %s:\n"), sanitize_string (section->name));
+
+  /* Find the nearest symbol forwards from our current position.  */
+  paux->require_sec = true;
+  sym = (asymbol *) find_symbol_for_address (section->vma + addr_offset,
+                                             (struct disassemble_info *) inf,
+                                             &place);
+  paux->require_sec = false;
+
+  /* PR 9774: If the target used signed addresses then we must make
+     sure that we sign extend the value that we calculate for 'addr'
+     in the loop below.  */
+  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
+      && (bed = get_elf_backend_data (abfd)) != NULL
+      && bed->sign_extend_vma)
+    sign_adjust = (bfd_vma) 1 << (bed->s->arch_size - 1);
+
+  /* Disassemble a block of instructions up to the address associated with
+     the symbol we have just found.  Then print the symbol and find the
+     next symbol on.  Repeat until we have disassembled the entire section
+     or we have reached the end of the address range we are interested in.  */
+  do_print = paux->symbol == NULL;
+  loop_until = stop_offset_reached;
+
+  while (addr_offset < stop_offset)
+    {
+      bfd_vma addr;
+      asymbol *nextsym;
+      bfd_vma nextstop_offset;
+      bool insns;
+
+      addr = section->vma + addr_offset;
+      addr = ((addr & ((sign_adjust << 1) - 1)) ^ sign_adjust) - sign_adjust;
+
+      if (sym != NULL && bfd_asymbol_value (sym) <= addr)
+	{
+	  int x;
+
+	  for (x = place;
+	       (x < sorted_symcount
+		&& (bfd_asymbol_value (sorted_syms[x]) <= addr));
+	       ++x)
+	    continue;
+
+	  pinfo->symbols = sorted_syms + place;
+	  pinfo->num_symbols = x - place;
+	  pinfo->symtab_pos = place;
+	}
+      else
+	{
+	  pinfo->symbols = NULL;
+	  pinfo->num_symbols = 0;
+	  pinfo->symtab_pos = -1;
+	}
+
+      /* If we are only disassembling from a specific symbol,
+	 check to see if we should start or stop displaying.  */
+      if (sym && paux->symbol)
+	{
+	  if (do_print)
+	    {
+	      /* See if we should stop printing.  */
+	      switch (loop_until)
+		{
+		case function_sym:
+		  if (sym->flags & BSF_FUNCTION)
+		    do_print = false;
+		  break;
+
+		case stop_offset_reached:
+		  /* Handled by the while loop.  */
+		  break;
+
+		case next_sym:
+		  /* FIXME: There is an implicit assumption here
+		     that the name of sym is different from
+		     paux->symbol.  */
+		  if (! bfd_is_local_label (abfd, sym))
+		    do_print = false;
+		  break;
+		}
+	    }
+	  else
+	    {
+	      const char * name = bfd_asymbol_name (sym);
+	      char * alloc = NULL;
+
+	      if (do_demangle && name[0] != '\0')
+		{
+		  /* Demangle the name.  */
+		  alloc = bfd_demangle (abfd, name, demangle_flags);
+		  if (alloc != NULL)
+		    name = alloc;
+		}
+
+	      /* We are not currently printing.  Check to see
+		 if the current symbol matches the requested symbol.  */
+	      if (streq (name, paux->symbol))
+		{
+		  do_print = true;
+
+		  if (sym->flags & BSF_FUNCTION)
+		    {
+		      if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
+			  && ((elf_symbol_type *) sym)->internal_elf_sym.st_size > 0)
+			{
+			  /* Sym is a function symbol with a size associated
+			     with it.  Turn on automatic disassembly for the
+			     next VALUE bytes.  */
+			  stop_offset = addr_offset
+			    + ((elf_symbol_type *) sym)->internal_elf_sym.st_size;
+			  loop_until = stop_offset_reached;
+			}
+		      else
+			{
+			  /* Otherwise we need to tell the loop heuristic to
+			     loop until the next function symbol is encountered.  */
+			  loop_until = function_sym;
+			}
+		    }
+		  else
+		    {
+		      /* Otherwise loop until the next symbol is encountered.  */
+		      loop_until = next_sym;
+		    }
+		}
+
+	      free (alloc);
+	    }
+	}
+
+      if (! prefix_addresses && do_print)
+	{
+	  pinfo->fprintf_func (pinfo->stream, "\n");
+	  objdump_print_addr_with_sym (abfd, section, sym, addr,
+				       pinfo, false);
+	  pinfo->fprintf_func (pinfo->stream, ":\n");
+	}
+
+      if (sym != NULL && bfd_asymbol_value (sym) > addr)
+	nextsym = sym;
+      else if (sym == NULL)
+	nextsym = NULL;
+      else
+	{
+#define is_valid_next_sym(SYM) \
+  (strcmp (bfd_section_name ((SYM)->section), bfd_section_name (section)) == 0 \
+   && (bfd_asymbol_value (SYM) > bfd_asymbol_value (sym)) \
+   && pinfo->symbol_is_valid (SYM, pinfo))
+
+	  /* Search forward for the next appropriate symbol in
+	     SECTION.  Note that all the symbols are sorted
+	     together into one big array, and that some sections
+	     may have overlapping addresses.  */
+	  while (place < sorted_symcount
+		 && ! is_valid_next_sym (sorted_syms [place]))
+	    ++place;
+
+	  if (place >= sorted_symcount)
+	    nextsym = NULL;
+	  else
+	    nextsym = sorted_syms[place];
+	}
+
+      if (sym != NULL && bfd_asymbol_value (sym) > addr)
+	nextstop_offset = bfd_asymbol_value (sym) - section->vma;
+      else if (nextsym == NULL)
+	nextstop_offset = stop_offset;
+      else
+	nextstop_offset = bfd_asymbol_value (nextsym) - section->vma;
+
+      if (nextstop_offset > stop_offset
+	  || nextstop_offset <= addr_offset)
+	nextstop_offset = stop_offset;
+
+      /* If a symbol is explicitly marked as being an object
+	 rather than a function, just dump the bytes without
+	 disassembling them.  */
+      if (disassemble_all
+	  || sym == NULL
+	  || sym->section != section
+	  || bfd_asymbol_value (sym) > addr
+	  || ((sym->flags & BSF_OBJECT) == 0
+	      && (strstr (bfd_asymbol_name (sym), "gnu_compiled")
+		  == NULL)
+	      && (strstr (bfd_asymbol_name (sym), "gcc2_compiled")
+		  == NULL))
+	  || (sym->flags & BSF_FUNCTION) != 0)
+	insns = true;
+      else
+	insns = false;
+
+      if (do_print)
+	{
+	  /* Resolve symbol name.  */
+	  if (visualize_jumps && abfd && sym && sym->name)
+	    {
+	      struct disassemble_info di;
+	      SFILE sf;
+
+	      sf.alloc = strlen (sym->name) + 40;
+	      sf.buffer = (char*) xmalloc (sf.alloc);
+	      sf.pos = 0;
+	      di.fprintf_func = (fprintf_ftype) objdump_sprintf;
+	      di.stream = &sf;
+
+	      objdump_print_symname (abfd, &di, sym);
+
+	      /* Fetch jump information.  */
+	      detected_jumps = disassemble_jumps
+		(pinfo, paux->disassemble_fn,
+		 addr_offset, nextstop_offset,
+		 rel_offset, &rel_pp, rel_ppend);
+
+	      /* Free symbol name.  */
+	      free (sf.buffer);
+	    }
+
+	  /* Add jumps to output.  */
+	  disassemble_bytes (pinfo, paux->disassemble_fn, insns, data,
+			     addr_offset, nextstop_offset,
+			     rel_offset, &rel_pp, rel_ppend);
+
+	  /* Free jumps.  */
+	  while (detected_jumps)
+	    {
+	      detected_jumps = jump_info_free (detected_jumps);
+	    }
+	}
+
+      addr_offset = nextstop_offset;
+      sym = nextsym;
+    }
+
+  free (data);
+
+  if (rel_ppstart != NULL)
+    free (rel_ppstart);
+}
+
+/* Disassemble the contents of an object file.  */
+
+static void
+disassemble_data (bfd *abfd)
+{
+  struct disassemble_info disasm_info;
+  struct objdump_disasm_info aux;
+  long i;
+
+  print_files = NULL;
+  prev_functionname = NULL;
+  prev_line = -1;
+  prev_discriminator = 0;
+
+  /* We make a copy of syms to sort.  We don't want to sort syms
+     because that will screw up the relocs.  */
+  sorted_symcount = symcount ? symcount : dynsymcount;
+  sorted_syms = (asymbol **) xmalloc ((sorted_symcount + synthcount)
+                                      * sizeof (asymbol *));
+  if (sorted_symcount != 0)
+    {
+      memcpy (sorted_syms, symcount ? syms : dynsyms,
+	      sorted_symcount * sizeof (asymbol *));
+
+      sorted_symcount = remove_useless_symbols (sorted_syms, sorted_symcount);
+    }
+
+  for (i = 0; i < synthcount; ++i)
+    {
+      sorted_syms[sorted_symcount] = synthsyms + i;
+      ++sorted_symcount;
+    }
+
+  init_disassemble_info (&disasm_info, stdout, (fprintf_ftype) fprintf);
+
+  disasm_info.application_data = (void *) &aux;
+  aux.abfd = abfd;
+  aux.require_sec = false;
+  disasm_info.dynrelbuf = NULL;
+  disasm_info.dynrelcount = 0;
+  aux.reloc = NULL;
+  aux.symbol = disasm_sym;
+
+  disasm_info.print_address_func = objdump_print_address;
+  disasm_info.symbol_at_address_func = objdump_symbol_at_address;
+
+  if (machine != NULL)
+    {
+      const bfd_arch_info_type *inf = bfd_scan_arch (machine);
+
+      if (inf == NULL)
+	fatal (_("can't use supplied machine %s"), machine);
+
+      abfd->arch_info = inf;
+    }
+
+  if (endian != BFD_ENDIAN_UNKNOWN)
+    {
+      struct bfd_target *xvec;
+
+      xvec = (struct bfd_target *) xmalloc (sizeof (struct bfd_target));
+      memcpy (xvec, abfd->xvec, sizeof (struct bfd_target));
+      xvec->byteorder = endian;
+      abfd->xvec = xvec;
+    }
+
+  /* Use libopcodes to locate a suitable disassembler.  */
+  aux.disassemble_fn = disassembler (bfd_get_arch (abfd),
+				     bfd_big_endian (abfd),
+				     bfd_get_mach (abfd), abfd);
+  if (!aux.disassemble_fn)
+    {
+      non_fatal (_("can't disassemble for architecture %s\n"),
+		 bfd_printable_arch_mach (bfd_get_arch (abfd), 0));
+      exit_status = 1;
+      return;
+    }
+
+  disasm_info.flavour = bfd_get_flavour (abfd);
+  disasm_info.arch = bfd_get_arch (abfd);
+  disasm_info.mach = bfd_get_mach (abfd);
+  disasm_info.disassembler_options = disassembler_options;
+  disasm_info.octets_per_byte = bfd_octets_per_byte (abfd, NULL);
+  disasm_info.skip_zeroes = DEFAULT_SKIP_ZEROES;
+  disasm_info.skip_zeroes_at_end = DEFAULT_SKIP_ZEROES_AT_END;
+  disasm_info.disassembler_needs_relocs = false;
+
+  if (bfd_big_endian (abfd))
+    disasm_info.display_endian = disasm_info.endian = BFD_ENDIAN_BIG;
+  else if (bfd_little_endian (abfd))
+    disasm_info.display_endian = disasm_info.endian = BFD_ENDIAN_LITTLE;
+  else
+    /* ??? Aborting here seems too drastic.  We could default to big or little
+       instead.  */
+    disasm_info.endian = BFD_ENDIAN_UNKNOWN;
+
+  disasm_info.endian_code = disasm_info.endian;
+
+  /* Allow the target to customize the info structure.  */
+  disassemble_init_for_target (& disasm_info);
+
+  /* Pre-load the dynamic relocs as we may need them during the disassembly.  */
+  long relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
+
+  if (relsize < 0 && dump_dynamic_reloc_info)
+    bfd_fatal (bfd_get_filename (abfd));
+
+  if (relsize > 0)
+    {
+      disasm_info.dynrelbuf = (arelent **) xmalloc (relsize);
+      disasm_info.dynrelcount
+	= bfd_canonicalize_dynamic_reloc (abfd, disasm_info.dynrelbuf, dynsyms);
+      if (disasm_info.dynrelcount < 0)
+	bfd_fatal (bfd_get_filename (abfd));
+
+      /* Sort the relocs by address.  */
+      qsort (disasm_info.dynrelbuf, disasm_info.dynrelcount, sizeof (arelent *),
+	     compare_relocs);
+    }
+
+  disasm_info.symtab = sorted_syms;
+  disasm_info.symtab_size = sorted_symcount;
+
+  bfd_map_over_sections (abfd, disassemble_section, & disasm_info);
+
+  free (disasm_info.dynrelbuf);
+  disasm_info.dynrelbuf = NULL;
+  free (sorted_syms);
+  disassemble_free_target (&disasm_info);
+}
+
+static bool
+load_specific_debug_section (enum dwarf_section_display_enum debug,
+			     asection *sec, void *file)
+{
+  struct dwarf_section *section = &debug_displays [debug].section;
+  bfd *abfd = (bfd *) file;
+  bfd_byte *contents;
+  bfd_size_type amt;
+  size_t alloced;
+  bool ret;
+
+  if (section->start != NULL)
+    {
+      /* If it is already loaded, do nothing.  */
+      if (streq (section->filename, bfd_get_filename (abfd)))
+	return true;
+      free (section->start);
+    }
+
+  section->filename = bfd_get_filename (abfd);
+  section->reloc_info = NULL;
+  section->num_relocs = 0;
+  section->address = bfd_section_vma (sec);
+  section->size = bfd_section_size (sec);
+  /* PR 24360: On 32-bit hosts sizeof (size_t) < sizeof (bfd_size_type). */
+  alloced = amt = section->size + 1;
+  if (alloced != amt || alloced == 0)
+    {
+      section->start = NULL;
+      free_debug_section (debug);
+      printf (_("\nSection '%s' has an invalid size: %#llx.\n"),
+	      sanitize_string (section->name),
+	      (unsigned long long) section->size);
+      return false;
+    }
+
+  section->start = contents = xmalloc (alloced);
+  /* Ensure any string section has a terminating NUL.  */
+  section->start[section->size] = 0;
+
+  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0
+      && debug_displays [debug].relocate)
+    {
+      ret = bfd_simple_get_relocated_section_contents (abfd,
+						       sec,
+						       section->start,
+						       syms) != NULL;
+      if (ret)
+	{
+	  long reloc_size = bfd_get_reloc_upper_bound (abfd, sec);
+
+	  if (reloc_size > 0)
+	    {
+	      unsigned long reloc_count;
+	      arelent **relocs;
+
+	      relocs = (arelent **) xmalloc (reloc_size);
+
+	      reloc_count = bfd_canonicalize_reloc (abfd, sec, relocs, NULL);
+	      if (reloc_count == 0)
+		free (relocs);
+	      else
+		{
+		  section->reloc_info = relocs;
+		  section->num_relocs = reloc_count;
+		}
+	    }
+	}
+    }
+  else
+    ret = bfd_get_full_section_contents (abfd, sec, &contents);
+
+  if (!ret)
+    {
+      free_debug_section (debug);
+      printf (_("\nCan't get contents for section '%s'.\n"),
+	      sanitize_string (section->name));
+      return false;
+    }
+
+  return true;
+}
+
+bool
+reloc_at (struct dwarf_section * dsec, dwarf_vma offset)
+{
+  arelent ** relocs;
+  arelent * rp;
+
+  if (dsec == NULL || dsec->reloc_info == NULL)
+    return false;
+
+  relocs = (arelent **) dsec->reloc_info;
+
+  for (; (rp = * relocs) != NULL; ++ relocs)
+    if (rp->address == offset)
+      return true;
+
+  return false;
+}
+
+bool
+load_debug_section (enum dwarf_section_display_enum debug, void *file)
+{
+  struct dwarf_section *section = &debug_displays [debug].section;
+  bfd *abfd = (bfd *) file;
+  asection *sec;
+
+  /* If it is already loaded, do nothing.  */
+  if (section->start != NULL)
+    {
+      if (streq (section->filename, bfd_get_filename (abfd)))
+	return true;
+    }
+
+  /* Locate the debug section.  */
+  sec = bfd_get_section_by_name (abfd, section->uncompressed_name);
+  if (sec != NULL)
+    section->name = section->uncompressed_name;
+  else
+    {
+      sec = bfd_get_section_by_name (abfd, section->compressed_name);
+      if (sec != NULL)
+        section->name = section->compressed_name;
+    }
+  if (sec == NULL)
+    return false;
+
+  return load_specific_debug_section (debug, sec, file);
+}
+
+void
+free_debug_section (enum dwarf_section_display_enum debug)
+{
+  struct dwarf_section *section = &debug_displays [debug].section;
+
+  free ((char *) section->start);
+  section->start = NULL;
+  section->address = 0;
+  section->size = 0;
+}
+
+void
+close_debug_file (void * file)
+{
+  bfd * abfd = (bfd *) file;
+
+  bfd_close (abfd);
+}
+
+void *
+open_debug_file (const char * pathname)
+{
+  bfd * data;
+
+  data = bfd_openr (pathname, NULL);
+  if (data == NULL)
+    return NULL;
+
+  if (! bfd_check_format (data, bfd_object))
+    return NULL;
+  
+  return data;
+}
+
+#if HAVE_LIBDEBUGINFOD
+/* Return a hex string represention of the build-id.  */
+
+unsigned char *
+get_build_id (void * data)
+{
+  unsigned i;
+  char * build_id_str;
+  bfd * abfd = (bfd *) data;
+  const struct bfd_build_id * build_id;
+
+  build_id = abfd->build_id;
+  if (build_id == NULL)
+    return NULL;
+
+  build_id_str = malloc (build_id->size * 2 + 1);
+  if (build_id_str == NULL)
+    return NULL;
+
+  for (i = 0; i < build_id->size; i++)
+    sprintf (build_id_str + (i * 2), "%02x", build_id->data[i]);
+  build_id_str[build_id->size * 2] = '\0';
+
+  return (unsigned char *)build_id_str;
+}
+#endif /* HAVE_LIBDEBUGINFOD */
+
+static void
+dump_dwarf_section (bfd *abfd, asection *section,
+		    void *arg ATTRIBUTE_UNUSED)
+{
+  const char *name = bfd_section_name (section);
+  const char *match;
+  int i;
+
+  if (startswith (name, ".gnu.linkonce.wi."))
+    match = ".debug_info";
+  else
+    match = name;
+
+  for (i = 0; i < max; i++)
+    if ((strcmp (debug_displays [i].section.uncompressed_name, match) == 0
+	 || strcmp (debug_displays [i].section.compressed_name, match) == 0)
+	&& debug_displays [i].enabled != NULL
+	&& *debug_displays [i].enabled)
+      {
+	struct dwarf_section *sec = &debug_displays [i].section;
+
+	if (strcmp (sec->uncompressed_name, match) == 0)
+	  sec->name = sec->uncompressed_name;
+	else
+	  sec->name = sec->compressed_name;
+	if (load_specific_debug_section ((enum dwarf_section_display_enum) i,
+                                         section, abfd))
+	  {
+	    debug_displays [i].display (sec, abfd);
+
+	    if (i != info && i != abbrev)
+	      free_debug_section ((enum dwarf_section_display_enum) i);
+	  }
+	break;
+      }
+}
+
+/* Dump the dwarf debugging information.  */
+
+static void
+dump_dwarf (bfd *abfd)
+{
+  /* The byte_get pointer should have been set at the start of dump_bfd().  */
+  if (byte_get == NULL)
+    {
+      warn (_("File %s does not contain any dwarf debug information\n"),
+	    bfd_get_filename (abfd));
+      return;
+    }
+
+  switch (bfd_get_arch (abfd))
+    {
+    case bfd_arch_s12z:
+      /* S12Z has a 24 bit address space.  But the only known
+	 producer of dwarf_info encodes addresses into 32 bits.  */
+      eh_addr_size = 4;
+      break;
+
+    default:
+      eh_addr_size = bfd_arch_bits_per_address (abfd) / 8;
+      break;
+    }
+
+  init_dwarf_regnames_by_bfd_arch_and_mach (bfd_get_arch (abfd),
+					    bfd_get_mach (abfd));
+
+  bfd_map_over_sections (abfd, dump_dwarf_section, NULL);
+}
+
+/* Read ABFD's stabs section STABSECT_NAME, and return a pointer to
+   it.  Return NULL on failure.   */
+
+static bfd_byte *
+read_section_stabs (bfd *abfd, const char *sect_name, bfd_size_type *size_ptr,
+		    bfd_size_type *entsize_ptr)
+{
+  asection *stabsect;
+  bfd_byte *contents;
+
+  stabsect = bfd_get_section_by_name (abfd, sect_name);
+  if (stabsect == NULL)
+    {
+      printf (_("No %s section present\n\n"),
+	      sanitize_string (sect_name));
+      return false;
+    }
+
+  if (!bfd_malloc_and_get_section (abfd, stabsect, &contents))
+    {
+      non_fatal (_("reading %s section of %s failed: %s"),
+		 sect_name, bfd_get_filename (abfd),
+		 bfd_errmsg (bfd_get_error ()));
+      exit_status = 1;
+      free (contents);
+      return NULL;
+    }
+
+  *size_ptr = bfd_section_size (stabsect);
+  if (entsize_ptr)
+    *entsize_ptr = stabsect->entsize;
+
+  return contents;
+}
+
+/* Stabs entries use a 12 byte format:
+     4 byte string table index
+     1 byte stab type
+     1 byte stab other field
+     2 byte stab desc field
+     4 byte stab value
+   FIXME: This will have to change for a 64 bit object format.  */
+
+#define STRDXOFF  (0)
+#define TYPEOFF   (4)
+#define OTHEROFF  (5)
+#define DESCOFF   (6)
+#define VALOFF    (8)
+#define STABSIZE (12)
+
+/* Print ABFD's stabs section STABSECT_NAME (in `stabs'),
+   using string table section STRSECT_NAME (in `strtab').  */
+
+static void
+print_section_stabs (bfd *abfd,
+		     const char *stabsect_name,
+		     unsigned *string_offset_ptr)
+{
+  int i;
+  unsigned file_string_table_offset = 0;
+  unsigned next_file_string_table_offset = *string_offset_ptr;
+  bfd_byte *stabp, *stabs_end;
+
+  stabp = stabs;
+  stabs_end = stabp + stab_size;
+
+  printf (_("Contents of %s section:\n\n"), sanitize_string (stabsect_name));
+  printf ("Symnum n_type n_othr n_desc n_value  n_strx String\n");
+
+  /* Loop through all symbols and print them.
+
+     We start the index at -1 because there is a dummy symbol on
+     the front of stabs-in-{coff,elf} sections that supplies sizes.  */
+  for (i = -1; stabp <= stabs_end - STABSIZE; stabp += STABSIZE, i++)
+    {
+      const char *name;
+      unsigned long strx;
+      unsigned char type, other;
+      unsigned short desc;
+      bfd_vma value;
+
+      strx = bfd_h_get_32 (abfd, stabp + STRDXOFF);
+      type = bfd_h_get_8 (abfd, stabp + TYPEOFF);
+      other = bfd_h_get_8 (abfd, stabp + OTHEROFF);
+      desc = bfd_h_get_16 (abfd, stabp + DESCOFF);
+      value = bfd_h_get_32 (abfd, stabp + VALOFF);
+
+      printf ("\n%-6d ", i);
+      /* Either print the stab name, or, if unnamed, print its number
+	 again (makes consistent formatting for tools like awk).  */
+      name = bfd_get_stab_name (type);
+      if (name != NULL)
+	printf ("%-6s", sanitize_string (name));
+      else if (type == N_UNDF)
+	printf ("HdrSym");
+      else
+	printf ("%-6d", type);
+      printf (" %-6d %-6d ", other, desc);
+      bfd_printf_vma (abfd, value);
+      printf (" %-6lu", strx);
+
+      /* Symbols with type == 0 (N_UNDF) specify the length of the
+	 string table associated with this file.  We use that info
+	 to know how to relocate the *next* file's string table indices.  */
+      if (type == N_UNDF)
+	{
+	  file_string_table_offset = next_file_string_table_offset;
+	  next_file_string_table_offset += value;
+	}
+      else
+	{
+	  bfd_size_type amt = strx + file_string_table_offset;
+
+	  /* Using the (possibly updated) string table offset, print the
+	     string (if any) associated with this symbol.  */
+	  if (amt < stabstr_size)
+	    /* PR 17512: file: 079-79389-0.001:0.1.
+	       FIXME: May need to sanitize this string before displaying.  */
+	    printf (" %.*s", (int)(stabstr_size - amt), strtab + amt);
+	  else
+	    printf (" *");
+	}
+    }
+  printf ("\n\n");
+  *string_offset_ptr = next_file_string_table_offset;
+}
+
+typedef struct
+{
+  const char * section_name;
+  const char * string_section_name;
+  unsigned string_offset;
+}
+stab_section_names;
+
+static void
+find_stabs_section (bfd *abfd, asection *section, void *names)
+{
+  int len;
+  stab_section_names * sought = (stab_section_names *) names;
+
+  /* Check for section names for which stabsect_name is a prefix, to
+     handle .stab.N, etc.  */
+  len = strlen (sought->section_name);
+
+  /* If the prefix matches, and the files section name ends with a
+     nul or a digit, then we match.  I.e., we want either an exact
+     match or a section followed by a number.  */
+  if (strncmp (sought->section_name, section->name, len) == 0
+      && (section->name[len] == 0
+	  || (section->name[len] == '.' && ISDIGIT (section->name[len + 1]))))
+    {
+      if (strtab == NULL)
+	strtab = read_section_stabs (abfd, sought->string_section_name,
+				     &stabstr_size, NULL);
+
+      if (strtab)
+	{
+	  stabs = read_section_stabs (abfd, section->name, &stab_size, NULL);
+	  if (stabs)
+	    print_section_stabs (abfd, section->name, &sought->string_offset);
+	}
+    }
+}
+
+static void
+dump_stabs_section (bfd *abfd, char *stabsect_name, char *strsect_name)
+{
+  stab_section_names s;
+
+  s.section_name = stabsect_name;
+  s.string_section_name = strsect_name;
+  s.string_offset = 0;
+
+  bfd_map_over_sections (abfd, find_stabs_section, & s);
+
+  free (strtab);
+  strtab = NULL;
+}
+
+/* Dump the any sections containing stabs debugging information.  */
+
+static void
+dump_stabs (bfd *abfd)
+{
+  dump_stabs_section (abfd, ".stab", ".stabstr");
+  dump_stabs_section (abfd, ".stab.excl", ".stab.exclstr");
+  dump_stabs_section (abfd, ".stab.index", ".stab.indexstr");
+
+  /* For Darwin.  */
+  dump_stabs_section (abfd, "LC_SYMTAB.stabs", "LC_SYMTAB.stabstr");
+
+  dump_stabs_section (abfd, "$GDB_SYMBOLS$", "$GDB_STRINGS$");
+}
+
+static void
+dump_bfd_header (bfd *abfd)
+{
+  char *comma = "";
+
+  printf (_("architecture: %s, "),
+	  bfd_printable_arch_mach (bfd_get_arch (abfd),
+				   bfd_get_mach (abfd)));
+  printf (_("flags 0x%08x:\n"), abfd->flags & ~BFD_FLAGS_FOR_BFD_USE_MASK);
+
+#define PF(x, y)    if (abfd->flags & x) {printf ("%s%s", comma, y); comma=", ";}
+  PF (HAS_RELOC, "HAS_RELOC");
+  PF (EXEC_P, "EXEC_P");
+  PF (HAS_LINENO, "HAS_LINENO");
+  PF (HAS_DEBUG, "HAS_DEBUG");
+  PF (HAS_SYMS, "HAS_SYMS");
+  PF (HAS_LOCALS, "HAS_LOCALS");
+  PF (DYNAMIC, "DYNAMIC");
+  PF (WP_TEXT, "WP_TEXT");
+  PF (D_PAGED, "D_PAGED");
+  PF (BFD_IS_RELAXABLE, "BFD_IS_RELAXABLE");
+  printf (_("\nstart address 0x"));
+  bfd_printf_vma (abfd, abfd->start_address);
+  printf ("\n");
+}
+
+
+#ifdef ENABLE_LIBCTF
+/* Formatting callback function passed to ctf_dump.  Returns either the pointer
+   it is passed, or a pointer to newly-allocated storage, in which case
+   dump_ctf() will free it when it no longer needs it.  */
+
+static char *
+dump_ctf_indent_lines (ctf_sect_names_t sect ATTRIBUTE_UNUSED,
+		       char *s, void *arg)
+{
+  const char *blanks = arg;
+  char *new_s;
+
+  if (asprintf (&new_s, "%s%s", blanks, s) < 0)
+    return s;
+  return new_s;
+}
+
+/* Make a ctfsect suitable for ctf_bfdopen_ctfsect().  */
+static ctf_sect_t
+make_ctfsect (const char *name, bfd_byte *data,
+	      bfd_size_type size)
+{
+  ctf_sect_t ctfsect;
+
+  ctfsect.cts_name = name;
+  ctfsect.cts_entsize = 1;
+  ctfsect.cts_size = size;
+  ctfsect.cts_data = data;
+
+  return ctfsect;
+}
+
+/* Dump CTF errors/warnings.  */
+static void
+dump_ctf_errs (ctf_dict_t *fp)
+{
+  ctf_next_t *it = NULL;
+  char *errtext;
+  int is_warning;
+  int err;
+
+  /* Dump accumulated errors and warnings.  */
+  while ((errtext = ctf_errwarning_next (fp, &it, &is_warning, &err)) != NULL)
+    {
+      non_fatal (_("%s: %s"), is_warning ? _("warning"): _("error"),
+		 errtext);
+      free (errtext);
+    }
+  if (err != ECTF_NEXT_END)
+    {
+      non_fatal (_("CTF error: cannot get CTF errors: `%s'"),
+		 ctf_errmsg (err));
+    }
+}
+
+/* Dump one CTF archive member.  */
+
+static int
+dump_ctf_archive_member (ctf_dict_t *ctf, const char *name, void *arg)
+{
+  ctf_dict_t *parent = (ctf_dict_t *) arg;
+  const char *things[] = {"Header", "Labels", "Data objects",
+			  "Function objects", "Variables", "Types", "Strings",
+			  ""};
+  const char **thing;
+  size_t i;
+
+  /* Only print out the name of non-default-named archive members.
+     The name .ctf appears everywhere, even for things that aren't
+     really archives, so printing it out is liable to be confusing.
+
+     The parent, if there is one, is the default-owned archive member:
+     avoid importing it into itself.  (This does no harm, but looks
+     confusing.)  */
+
+  if (strcmp (name, ".ctf") != 0)
+    {
+      printf (_("\nCTF archive member: %s:\n"), sanitize_string (name));
+      ctf_import (ctf, parent);
+    }
+
+  for (i = 0, thing = things; *thing[0]; thing++, i++)
+    {
+      ctf_dump_state_t *s = NULL;
+      char *item;
+
+      printf ("\n  %s:\n", *thing);
+      while ((item = ctf_dump (ctf, &s, i, dump_ctf_indent_lines,
+			       (void *) "    ")) != NULL)
+	{
+	  printf ("%s\n", item);
+	  free (item);
+	}
+
+      if (ctf_errno (ctf))
+	{
+	  non_fatal (_("Iteration failed: %s, %s"), *thing,
+		   ctf_errmsg (ctf_errno (ctf)));
+	  break;
+	}
+    }
+
+  dump_ctf_errs (ctf);
+
+  return 0;
+}
+
+/* Dump the CTF debugging information.  */
+
+static void
+dump_ctf (bfd *abfd, const char *sect_name, const char *parent_name)
+{
+  ctf_archive_t *ctfa, *parenta = NULL, *lookparent;
+  bfd_byte *ctfdata, *parentdata = NULL;
+  bfd_size_type ctfsize, parentsize;
+  ctf_sect_t ctfsect;
+  ctf_dict_t *parent = NULL;
+  int err;
+
+  if ((ctfdata = read_section_stabs (abfd, sect_name, &ctfsize, NULL)) == NULL)
+      bfd_fatal (bfd_get_filename (abfd));
+
+  if (parent_name
+      && (parentdata = read_section_stabs (abfd, parent_name, &parentsize,
+					   NULL)) == NULL)
+      bfd_fatal (bfd_get_filename (abfd));
+
+  /* Load the CTF file and dump it.  */
+
+  ctfsect = make_ctfsect (sect_name, ctfdata, ctfsize);
+  if ((ctfa = ctf_bfdopen_ctfsect (abfd, &ctfsect, &err)) == NULL)
+    {
+      dump_ctf_errs (NULL);
+      non_fatal (_("CTF open failure: %s"), ctf_errmsg (err));
+      bfd_fatal (bfd_get_filename (abfd));
+    }
+
+  if (parentdata)
+    {
+      ctfsect = make_ctfsect (parent_name, parentdata, parentsize);
+      if ((parenta = ctf_bfdopen_ctfsect (abfd, &ctfsect, &err)) == NULL)
+	{
+	  dump_ctf_errs (NULL);
+	  non_fatal (_("CTF open failure: %s"), ctf_errmsg (err));
+	  bfd_fatal (bfd_get_filename (abfd));
+	}
+
+      lookparent = parenta;
+    }
+  else
+    lookparent = ctfa;
+
+  /* Assume that the applicable parent archive member is the default one.
+     (This is what all known implementations are expected to do, if they
+     put CTFs and their parents in archives together.)  */
+  if ((parent = ctf_dict_open (lookparent, NULL, &err)) == NULL)
+    {
+      dump_ctf_errs (NULL);
+      non_fatal (_("CTF open failure: %s"), ctf_errmsg (err));
+      bfd_fatal (bfd_get_filename (abfd));
+    }
+
+  printf (_("Contents of CTF section %s:\n"), sanitize_string (sect_name));
+
+  if ((err = ctf_archive_iter (ctfa, dump_ctf_archive_member, parent)) != 0)
+    {
+      dump_ctf_errs (NULL);
+      non_fatal (_("CTF archive member open failure: %s"), ctf_errmsg (err));
+      bfd_fatal (bfd_get_filename (abfd));
+    }
+  ctf_dict_close (parent);
+  ctf_close (ctfa);
+  ctf_close (parenta);
+  free (parentdata);
+  free (ctfdata);
+}
+#else
+static void
+dump_ctf (bfd *abfd ATTRIBUTE_UNUSED, const char *sect_name ATTRIBUTE_UNUSED,
+	  const char *parent_name ATTRIBUTE_UNUSED) {}
+#endif
+
+
+static void
+dump_bfd_private_header (bfd *abfd)
+{
+  if (!bfd_print_private_bfd_data (abfd, stdout))
+    non_fatal (_("warning: private headers incomplete: %s"),
+	       bfd_errmsg (bfd_get_error ()));
+}
+
+static void
+dump_target_specific (bfd *abfd)
+{
+  const struct objdump_private_desc * const *desc;
+  struct objdump_private_option *opt;
+  char *e, *b;
+
+  /* Find the desc.  */
+  for (desc = objdump_private_vectors; *desc != NULL; desc++)
+    if ((*desc)->filter (abfd))
+      break;
+
+  if (*desc == NULL)
+    {
+      non_fatal (_("option -P/--private not supported by this file"));
+      return;
+    }
+
+  /* Clear all options.  */
+  for (opt = (*desc)->options; opt->name; opt++)
+    opt->selected = false;
+
+  /* Decode options.  */
+  b = dump_private_options;
+  do
+    {
+      e = strchr (b, ',');
+
+      if (e)
+        *e = 0;
+
+      for (opt = (*desc)->options; opt->name; opt++)
+        if (strcmp (opt->name, b) == 0)
+          {
+            opt->selected = true;
+            break;
+          }
+      if (opt->name == NULL)
+        non_fatal (_("target specific dump '%s' not supported"), b);
+
+      if (e)
+        {
+          *e = ',';
+          b = e + 1;
+        }
+    }
+  while (e != NULL);
+
+  /* Dump.  */
+  (*desc)->dump (abfd);
+}
+
+/* Display a section in hexadecimal format with associated characters.
+   Each line prefixed by the zero padded address.  */
+
+static void
+dump_section (bfd *abfd, asection *section, void *dummy ATTRIBUTE_UNUSED)
+{
+  bfd_byte *data = NULL;
+  bfd_size_type datasize;
+  bfd_vma addr_offset;
+  bfd_vma start_offset;
+  bfd_vma stop_offset;
+  unsigned int opb = bfd_octets_per_byte (abfd, section);
+  /* Bytes per line.  */
+  const int onaline = 16;
+  char buf[64];
+  int count;
+  int width;
+
+  if (! process_section_p (section))
+    return;
+
+  if ((section->flags & SEC_HAS_CONTENTS) == 0)
+    return;
+
+  if ((datasize = bfd_section_size (section)) == 0)
+    return;
+
+  /* Compute the address range to display.  */
+  if (start_address == (bfd_vma) -1
+      || start_address < section->vma)
+    start_offset = 0;
+  else
+    start_offset = start_address - section->vma;
+
+  if (stop_address == (bfd_vma) -1)
+    stop_offset = datasize / opb;
+  else
+    {
+      if (stop_address < section->vma)
+	stop_offset = 0;
+      else
+	stop_offset = stop_address - section->vma;
+
+      if (stop_offset > datasize / opb)
+	stop_offset = datasize / opb;
+    }
+
+  if (start_offset >= stop_offset)
+    return;
+
+  printf (_("Contents of section %s:"), sanitize_string (section->name));
+  if (display_file_offsets)
+    printf (_("  (Starting at file offset: 0x%lx)"),
+	    (unsigned long) (section->filepos + start_offset));
+  printf ("\n");
+
+  if (!bfd_get_full_section_contents (abfd, section, &data))
+    {
+      non_fatal (_("Reading section %s failed because: %s"),
+		 section->name, bfd_errmsg (bfd_get_error ()));
+      return;
+    }
+
+  width = 4;
+
+  bfd_sprintf_vma (abfd, buf, start_offset + section->vma);
+  if (strlen (buf) >= sizeof (buf))
+    abort ();
+
+  count = 0;
+  while (buf[count] == '0' && buf[count+1] != '\0')
+    count++;
+  count = strlen (buf) - count;
+  if (count > width)
+    width = count;
+
+  bfd_sprintf_vma (abfd, buf, stop_offset + section->vma - 1);
+  if (strlen (buf) >= sizeof (buf))
+    abort ();
+
+  count = 0;
+  while (buf[count] == '0' && buf[count+1] != '\0')
+    count++;
+  count = strlen (buf) - count;
+  if (count > width)
+    width = count;
+
+  for (addr_offset = start_offset;
+       addr_offset < stop_offset; addr_offset += onaline / opb)
+    {
+      bfd_size_type j;
+
+      bfd_sprintf_vma (abfd, buf, (addr_offset + section->vma));
+      count = strlen (buf);
+      if ((size_t) count >= sizeof (buf))
+	abort ();
+
+      putchar (' ');
+      while (count < width)
+	{
+	  putchar ('0');
+	  count++;
+	}
+      fputs (buf + count - width, stdout);
+      putchar (' ');
+
+      for (j = addr_offset * opb;
+	   j < addr_offset * opb + onaline; j++)
+	{
+	  if (j < stop_offset * opb)
+	    printf ("%02x", (unsigned) (data[j]));
+	  else
+	    printf ("  ");
+	  if ((j & 3) == 3)
+	    printf (" ");
+	}
+
+      printf (" ");
+      for (j = addr_offset * opb;
+	   j < addr_offset * opb + onaline; j++)
+	{
+	  if (j >= stop_offset * opb)
+	    printf (" ");
+	  else
+	    printf ("%c", ISPRINT (data[j]) ? data[j] : '.');
+	}
+      putchar ('\n');
+    }
+  free (data);
+}
+
+/* Actually display the various requested regions.  */
+
+static void
+dump_data (bfd *abfd)
+{
+  bfd_map_over_sections (abfd, dump_section, NULL);
+}
+
+/* Should perhaps share code and display with nm?  */
+
+static void
+dump_symbols (bfd *abfd ATTRIBUTE_UNUSED, bool dynamic)
+{
+  asymbol **current;
+  long max_count;
+  long count;
+
+  if (dynamic)
+    {
+      current = dynsyms;
+      max_count = dynsymcount;
+      printf ("DYNAMIC SYMBOL TABLE:\n");
+    }
+  else
+    {
+      current = syms;
+      max_count = symcount;
+      printf ("SYMBOL TABLE:\n");
+    }
+
+  if (max_count == 0)
+    printf (_("no symbols\n"));
+
+  for (count = 0; count < max_count; count++)
+    {
+      bfd *cur_bfd;
+
+      if (*current == NULL)
+	printf (_("no information for symbol number %ld\n"), count);
+
+      else if ((cur_bfd = bfd_asymbol_bfd (*current)) == NULL)
+	printf (_("could not determine the type of symbol number %ld\n"),
+		count);
+
+      else if (process_section_p ((* current)->section)
+	       && (dump_special_syms
+		   || !bfd_is_target_special_symbol (cur_bfd, *current)))
+	{
+	  const char *name = (*current)->name;
+
+	  if (do_demangle && name != NULL && *name != '\0')
+	    {
+	      char *alloc;
+
+	      /* If we want to demangle the name, we demangle it
+		 here, and temporarily clobber it while calling
+		 bfd_print_symbol.  FIXME: This is a gross hack.  */
+	      alloc = bfd_demangle (cur_bfd, name, demangle_flags);
+	      if (alloc != NULL)
+		(*current)->name = alloc;
+	      bfd_print_symbol (cur_bfd, stdout, *current,
+				bfd_print_symbol_all);
+	      if (alloc != NULL)
+		{
+		  (*current)->name = name;
+		  free (alloc);
+		}
+	    }
+	  else
+	    bfd_print_symbol (cur_bfd, stdout, *current,
+			      bfd_print_symbol_all);
+	  printf ("\n");
+	}
+
+      current++;
+    }
+  printf ("\n\n");
+}
+
+static void
+dump_reloc_set (bfd *abfd, asection *sec, arelent **relpp, long relcount)
+{
+  arelent **p;
+  char *last_filename, *last_functionname;
+  unsigned int last_line;
+  unsigned int last_discriminator;
+
+  /* Get column headers lined up reasonably.  */
+  {
+    static int width;
+
+    if (width == 0)
+      {
+	char buf[30];
+
+	bfd_sprintf_vma (abfd, buf, (bfd_vma) -1);
+	width = strlen (buf) - 7;
+      }
+    printf ("OFFSET %*s TYPE %*s VALUE \n", width, "", 12, "");
+  }
+
+  last_filename = NULL;
+  last_functionname = NULL;
+  last_line = 0;
+  last_discriminator = 0;
+
+  for (p = relpp; relcount && *p != NULL; p++, relcount--)
+    {
+      arelent *q = *p;
+      const char *filename, *functionname;
+      unsigned int linenumber;
+      unsigned int discriminator;
+      const char *sym_name;
+      const char *section_name;
+      bfd_vma addend2 = 0;
+
+      if (start_address != (bfd_vma) -1
+	  && q->address < start_address)
+	continue;
+      if (stop_address != (bfd_vma) -1
+	  && q->address > stop_address)
+	continue;
+
+      if (with_line_numbers
+	  && sec != NULL
+	  && bfd_find_nearest_line_discriminator (abfd, sec, syms, q->address,
+                                                  &filename, &functionname,
+                                                  &linenumber, &discriminator))
+	{
+	  if (functionname != NULL
+	      && (last_functionname == NULL
+		  || strcmp (functionname, last_functionname) != 0))
+	    {
+	      printf ("%s():\n", sanitize_string (functionname));
+	      if (last_functionname != NULL)
+		free (last_functionname);
+	      last_functionname = xstrdup (functionname);
+	    }
+
+	  if (linenumber > 0
+	      && (linenumber != last_line
+		  || (filename != NULL
+		      && last_filename != NULL
+		      && filename_cmp (filename, last_filename) != 0)
+                  || (discriminator != last_discriminator)))
+	    {
+              if (discriminator > 0)
+                printf ("%s:%u\n", filename == NULL ? "???" :
+			sanitize_string (filename), linenumber);
+              else
+                printf ("%s:%u (discriminator %u)\n",
+			filename == NULL ? "???" : sanitize_string (filename),
+                        linenumber, discriminator);
+	      last_line = linenumber;
+	      last_discriminator = discriminator;
+	      if (last_filename != NULL)
+		free (last_filename);
+	      if (filename == NULL)
+		last_filename = NULL;
+	      else
+		last_filename = xstrdup (filename);
+	    }
+	}
+
+      if (q->sym_ptr_ptr && *q->sym_ptr_ptr)
+	{
+	  sym_name = (*(q->sym_ptr_ptr))->name;
+	  section_name = (*(q->sym_ptr_ptr))->section->name;
+	}
+      else
+	{
+	  sym_name = NULL;
+	  section_name = NULL;
+	}
+
+      bfd_printf_vma (abfd, q->address);
+      if (q->howto == NULL)
+	printf (" *unknown*         ");
+      else if (q->howto->name)
+	{
+	  const char *name = q->howto->name;
+
+	  /* R_SPARC_OLO10 relocations contain two addends.
+	     But because 'arelent' lacks enough storage to
+	     store them both, the 64-bit ELF Sparc backend
+	     records this as two relocations.  One R_SPARC_LO10
+	     and one R_SPARC_13, both pointing to the same
+	     address.  This is merely so that we have some
+	     place to store both addend fields.
+
+	     Undo this transformation, otherwise the output
+	     will be confusing.  */
+	  if (abfd->xvec->flavour == bfd_target_elf_flavour
+	      && elf_tdata (abfd)->elf_header->e_machine == EM_SPARCV9
+	      && relcount > 1
+	      && !strcmp (q->howto->name, "R_SPARC_LO10"))
+	    {
+	      arelent *q2 = *(p + 1);
+	      if (q2 != NULL
+		  && q2->howto
+		  && q->address == q2->address
+		  && !strcmp (q2->howto->name, "R_SPARC_13"))
+		{
+		  name = "R_SPARC_OLO10";
+		  addend2 = q2->addend;
+		  p++;
+		}
+	    }
+	  printf (" %-16s  ", name);
+	}
+      else
+	printf (" %-16d  ", q->howto->type);
+
+      if (sym_name)
+	{
+	  objdump_print_symname (abfd, NULL, *q->sym_ptr_ptr);
+	}
+      else
+	{
+	  if (section_name == NULL)
+	    section_name = "*unknown*";
+	  printf ("[%s]", sanitize_string (section_name));
+	}
+
+      if (q->addend)
+	{
+	  bfd_signed_vma addend = q->addend;
+	  if (addend < 0)
+	    {
+	      printf ("-0x");
+	      addend = -addend;
+	    }
+	  else
+	    printf ("+0x");
+	  bfd_printf_vma (abfd, addend);
+	}
+      if (addend2)
+	{
+	  printf ("+0x");
+	  bfd_printf_vma (abfd, addend2);
+	}
+
+      printf ("\n");
+    }
+
+  if (last_filename != NULL)
+    free (last_filename);
+  if (last_functionname != NULL)
+    free (last_functionname);
+}
+
+static void
+dump_relocs_in_section (bfd *abfd,
+			asection *section,
+			void *dummy ATTRIBUTE_UNUSED)
+{
+  arelent **relpp = NULL;
+  long relcount;
+  long relsize;
+
+  if (   bfd_is_abs_section (section)
+      || bfd_is_und_section (section)
+      || bfd_is_com_section (section)
+      || (! process_section_p (section))
+      || ((section->flags & SEC_RELOC) == 0))
+    return;
+
+  printf ("RELOCATION RECORDS FOR [%s]:", sanitize_string (section->name));
+
+  relsize = bfd_get_reloc_upper_bound (abfd, section);
+  if (relsize == 0)
+    {
+      printf (" (none)\n\n");
+      return;
+    }
+
+  if (relsize < 0)
+    relcount = relsize;
+  else
+    {
+      relpp = (arelent **) xmalloc (relsize);
+      relcount = bfd_canonicalize_reloc (abfd, section, relpp, syms);
+    }
+
+  if (relcount < 0)
+    {
+      printf ("\n");
+      non_fatal (_("failed to read relocs in: %s"),
+		 sanitize_string (bfd_get_filename (abfd)));
+      bfd_fatal (_("error message was"));
+    }
+  else if (relcount == 0)
+    printf (" (none)\n\n");
+  else
+    {
+      printf ("\n");
+      dump_reloc_set (abfd, section, relpp, relcount);
+      printf ("\n\n");
+    }
+  free (relpp);
+}
+
+static void
+dump_relocs (bfd *abfd)
+{
+  bfd_map_over_sections (abfd, dump_relocs_in_section, NULL);
+}
+
+static void
+dump_dynamic_relocs (bfd *abfd)
+{
+  long relsize;
+  arelent **relpp;
+  long relcount;
+
+  relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
+  if (relsize < 0)
+    bfd_fatal (bfd_get_filename (abfd));
+
+  printf ("DYNAMIC RELOCATION RECORDS");
+
+  if (relsize == 0)
+    printf (" (none)\n\n");
+  else
+    {
+      relpp = (arelent **) xmalloc (relsize);
+      relcount = bfd_canonicalize_dynamic_reloc (abfd, relpp, dynsyms);
+
+      if (relcount < 0)
+	bfd_fatal (bfd_get_filename (abfd));
+      else if (relcount == 0)
+	printf (" (none)\n\n");
+      else
+	{
+	  printf ("\n");
+	  dump_reloc_set (abfd, NULL, relpp, relcount);
+	  printf ("\n\n");
+	}
+      free (relpp);
+    }
+}
+
+/* Creates a table of paths, to search for source files.  */
+
+static void
+add_include_path (const char *path)
+{
+  if (path[0] == 0)
+    return;
+  include_path_count++;
+  include_paths = (const char **)
+      xrealloc (include_paths, include_path_count * sizeof (*include_paths));
+#ifdef HAVE_DOS_BASED_FILE_SYSTEM
+  if (path[1] == ':' && path[2] == 0)
+    path = concat (path, ".", (const char *) 0);
+#endif
+  include_paths[include_path_count - 1] = path;
+}
+
+static void
+adjust_addresses (bfd *abfd ATTRIBUTE_UNUSED,
+		  asection *section,
+		  void *arg)
+{
+  if ((section->flags & SEC_DEBUGGING) == 0)
+    {
+      bool *has_reloc_p = (bool *) arg;
+      section->vma += adjust_section_vma;
+      if (*has_reloc_p)
+	section->lma += adjust_section_vma;
+    }
+}
+
+/* Return the sign-extended form of an ARCH_SIZE sized VMA.  */
+
+static bfd_vma
+sign_extend_address (bfd *abfd ATTRIBUTE_UNUSED,
+		     bfd_vma vma,
+		     unsigned arch_size)
+{
+  bfd_vma mask;
+  mask = (bfd_vma) 1 << (arch_size - 1);
+  return (((vma & ((mask << 1) - 1)) ^ mask) - mask);
+}
+
+/* Dump selected contents of ABFD.  */
+
+static void
+dump_bfd (bfd *abfd, bool is_mainfile)
+{
+  const struct elf_backend_data * bed;
+
+  if (bfd_big_endian (abfd))
+    byte_get = byte_get_big_endian;
+  else if (bfd_little_endian (abfd))
+    byte_get = byte_get_little_endian;
+  else
+    byte_get = NULL;
+
+  /* Load any separate debug information files.
+     We do this now and without checking do_follow_links because separate
+     debug info files may contain symbol tables that we will need when
+     displaying information about the main file.  Any memory allocated by
+     load_separate_debug_files will be released when we call
+     free_debug_memory below.
+     
+     The test on is_mainfile is there because the chain of separate debug
+     info files is a global variable shared by all invocations of dump_bfd.  */
+  if (is_mainfile)
+    {
+      load_separate_debug_files (abfd, bfd_get_filename (abfd));
+
+      /* If asked to do so, recursively dump the separate files.  */
+      if (do_follow_links)
+	{
+	  separate_info * i;
+
+	  for (i = first_separate_info; i != NULL; i = i->next)
+	    dump_bfd (i->handle, false);
+	}
+    }
+
+  /* Adjust user-specified start and stop limits for targets that use
+     signed addresses.  */
+  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
+      && (bed = get_elf_backend_data (abfd)) != NULL
+      && bed->sign_extend_vma)
+    {
+      start_address = sign_extend_address (abfd, start_address,
+					   bed->s->arch_size);
+      stop_address = sign_extend_address (abfd, stop_address,
+					  bed->s->arch_size);
+    }
+
+  /* If we are adjusting section VMA's, change them all now.  Changing
+     the BFD information is a hack.  However, we must do it, or
+     bfd_find_nearest_line will not do the right thing.  */
+  if (adjust_section_vma != 0)
+    {
+      bool has_reloc = (abfd->flags & HAS_RELOC);
+      bfd_map_over_sections (abfd, adjust_addresses, &has_reloc);
+    }
+
+  if (! is_mainfile && ! process_links)
+    return;
+
+  if (! dump_debugging_tags && ! suppress_bfd_header)
+    printf (_("\n%s:     file format %s\n"),
+	    sanitize_string (bfd_get_filename (abfd)),
+	    abfd->xvec->name);
+  if (dump_ar_hdrs)
+    print_arelt_descr (stdout, abfd, true, false);
+  if (dump_file_header)
+    dump_bfd_header (abfd);
+  if (dump_private_headers)
+    dump_bfd_private_header (abfd);
+  if (dump_private_options != NULL)
+    dump_target_specific (abfd);
+  if (! dump_debugging_tags && ! suppress_bfd_header)
+    putchar ('\n');
+
+  if (dump_symtab
+      || dump_reloc_info
+      || disassemble
+      || dump_debugging
+      || dump_dwarf_section_info)
+    {
+      syms = slurp_symtab (abfd);
+
+      /* If following links, load any symbol tables from the linked files as well.  */
+      if (do_follow_links && is_mainfile)
+	{
+	  separate_info * i;
+
+	  for (i = first_separate_info; i != NULL; i = i->next)
+	    {
+	      asymbol **  extra_syms;
+	      long        old_symcount = symcount;
+	      
+	      extra_syms = slurp_symtab (i->handle);
+
+	      if (extra_syms)
+		{
+		  if (old_symcount == 0)
+		    {
+		      syms = extra_syms;
+		    }
+		  else
+		    {
+		      syms = xrealloc (syms, ((symcount + old_symcount + 1)
+					      * sizeof (asymbol *)));
+		      memcpy (syms + old_symcount,
+			      extra_syms,
+			      (symcount + 1) * sizeof (asymbol *));
+		    }
+		}
+
+	      symcount += old_symcount;
+	    }
+	}
+    }
+
+  if (dump_section_headers)
+    dump_headers (abfd);
+
+  if (dump_dynamic_symtab || dump_dynamic_reloc_info
+      || (disassemble && bfd_get_dynamic_symtab_upper_bound (abfd) > 0))
+    dynsyms = slurp_dynamic_symtab (abfd);
+
+  if (disassemble)
+    {
+      synthcount = bfd_get_synthetic_symtab (abfd, symcount, syms,
+					     dynsymcount, dynsyms, &synthsyms);
+      if (synthcount < 0)
+	synthcount = 0;
+    }
+
+  if (dump_symtab)
+    dump_symbols (abfd, false);
+  if (dump_dynamic_symtab)
+    dump_symbols (abfd, true);
+  if (dump_dwarf_section_info)
+    dump_dwarf (abfd);
+  if (dump_ctf_section_info)
+    dump_ctf (abfd, dump_ctf_section_name, dump_ctf_parent_name);
+  if (dump_stab_section_info)
+    dump_stabs (abfd);
+  if (dump_reloc_info && ! disassemble)
+    dump_relocs (abfd);
+  if (dump_dynamic_reloc_info && ! disassemble)
+    dump_dynamic_relocs (abfd);
+  if (dump_section_contents)
+    dump_data (abfd);
+  if (disassemble)
+    disassemble_data (abfd);
+
+  if (dump_debugging)
+    {
+      void *dhandle;
+
+      dhandle = read_debugging_info (abfd, syms, symcount, true);
+      if (dhandle != NULL)
+	{
+	  if (!print_debugging_info (stdout, dhandle, abfd, syms,
+				     bfd_demangle,
+				     dump_debugging_tags != 0))
+	    {
+	      non_fatal (_("%s: printing debugging information failed"),
+			 bfd_get_filename (abfd));
+	      exit_status = 1;
+	    }
+
+	  free (dhandle);
+	}
+      /* PR 6483: If there was no STABS debug info in the file, try
+	 DWARF instead.  */
+      else if (! dump_dwarf_section_info)
+	{
+	  dwarf_select_sections_all ();
+	  dump_dwarf (abfd);
+	}
+    }
+
+  if (syms)
+    {
+      free (syms);
+      syms = NULL;
+    }
+
+  if (dynsyms)
+    {
+      free (dynsyms);
+      dynsyms = NULL;
+    }
+
+  if (synthsyms)
+    {
+      free (synthsyms);
+      synthsyms = NULL;
+    }
+
+  symcount = 0;
+  dynsymcount = 0;
+  synthcount = 0;
+
+  if (is_mainfile)
+    free_debug_memory ();
+}
+
+static void
+display_object_bfd (bfd *abfd)
+{
+  char **matching;
+
+  if (bfd_check_format_matches (abfd, bfd_object, &matching))
+    {
+      dump_bfd (abfd, true);
+      return;
+    }
+
+  if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
+    {
+      nonfatal (bfd_get_filename (abfd));
+      list_matching_formats (matching);
+      free (matching);
+      return;
+    }
+
+  if (bfd_get_error () != bfd_error_file_not_recognized)
+    {
+      nonfatal (bfd_get_filename (abfd));
+      return;
+    }
+
+  if (bfd_check_format_matches (abfd, bfd_core, &matching))
+    {
+      dump_bfd (abfd, true);
+      return;
+    }
+
+  nonfatal (bfd_get_filename (abfd));
+
+  if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
+    {
+      list_matching_formats (matching);
+      free (matching);
+    }
+}
+
+static void
+display_any_bfd (bfd *file, int level)
+{
+  /* Decompress sections unless dumping the section contents.  */
+  if (!dump_section_contents)
+    file->flags |= BFD_DECOMPRESS;
+
+  /* If the file is an archive, process all of its elements.  */
+  if (bfd_check_format (file, bfd_archive))
+    {
+      bfd *arfile = NULL;
+      bfd *last_arfile = NULL;
+
+      if (level == 0)
+        printf (_("In archive %s:\n"), sanitize_string (bfd_get_filename (file)));
+      else if (level > 100)
+	{
+	  /* Prevent corrupted files from spinning us into an
+	     infinite loop.  100 is an arbitrary heuristic.  */
+	  fatal (_("Archive nesting is too deep"));
+	  return;
+	}
+      else
+        printf (_("In nested archive %s:\n"),
+		sanitize_string (bfd_get_filename (file)));
+
+      for (;;)
+	{
+	  bfd_set_error (bfd_error_no_error);
+
+	  arfile = bfd_openr_next_archived_file (file, arfile);
+	  if (arfile == NULL)
+	    {
+	      if (bfd_get_error () != bfd_error_no_more_archived_files)
+		nonfatal (bfd_get_filename (file));
+	      break;
+	    }
+
+	  display_any_bfd (arfile, level + 1);
+
+	  if (last_arfile != NULL)
+	    {
+	      bfd_close (last_arfile);
+	      /* PR 17512: file: ac585d01.  */
+	      if (arfile == last_arfile)
+		{
+		  last_arfile = NULL;
+		  break;
+		}
+	    }
+	  last_arfile = arfile;
+	}
+
+      if (last_arfile != NULL)
+	bfd_close (last_arfile);
+    }
+  else
+    display_object_bfd (file);
+}
+
+static void
+display_file (char *filename, char *target, bool last_file)
+{
+  bfd *file;
+
+  if (get_file_size (filename) < 1)
+    {
+      exit_status = 1;
+      return;
+    }
+
+  file = bfd_openr (filename, target);
+  if (file == NULL)
+    {
+      nonfatal (filename);
+      return;
+    }
+
+  display_any_bfd (file, 0);
+
+  /* This is an optimization to improve the speed of objdump, especially when
+     dumping a file with lots of associated debug informatiom.  Calling
+     bfd_close on such a file can take a non-trivial amount of time as there
+     are lots of lists to walk and buffers to free.  This is only really
+     necessary however if we are about to load another file and we need the
+     memory back.  Otherwise, if we are about to exit, then we can save (a lot
+     of) time by only doing a quick close, and allowing the OS to reclaim the
+     memory for us.  */
+  if (! last_file)
+    bfd_close (file);
+  else
+    bfd_close_all_done (file);
+}
+
+int
+main (int argc, char **argv)
+{
+  int c;
+  char *target = default_target;
+  bool seenflag = false;
+
+#ifdef HAVE_LC_MESSAGES
+  setlocale (LC_MESSAGES, "");
+#endif
+  setlocale (LC_CTYPE, "");
+
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+
+  program_name = *argv;
+  xmalloc_set_program_name (program_name);
+  bfd_set_error_program_name (program_name);
+
+  START_PROGRESS (program_name, 0);
+
+  expandargv (&argc, &argv);
+
+  if (bfd_init () != BFD_INIT_MAGIC)
+    fatal (_("fatal error: libbfd ABI mismatch"));
+  set_default_bfd_target ();
+
+  while ((c = getopt_long (argc, argv,
+			   "pP:ib:m:M:VvCdDlfFaHhrRtTxsSI:j:wE:zgeGW::",
+			   long_options, (int *) 0))
+	 != EOF)
+    {
+      switch (c)
+	{
+	case 0:
+	  break;		/* We've been given a long option.  */
+	case 'm':
+	  machine = optarg;
+	  break;
+	case 'M':
+	  {
+	    char *options;
+	    if (disassembler_options)
+	      /* Ignore potential memory leak for now.  */
+	      options = concat (disassembler_options, ",",
+				optarg, (const char *) NULL);
+	    else
+	      options = optarg;
+	    disassembler_options = remove_whitespace_and_extra_commas (options);
+	  }
+	  break;
+	case 'j':
+	  add_only (optarg);
+	  break;
+	case 'F':
+	  display_file_offsets = true;
+	  break;
+	case 'l':
+	  with_line_numbers = true;
+	  break;
+	case 'b':
+	  target = optarg;
+	  break;
+	case 'C':
+	  do_demangle = true;
+	  if (optarg != NULL)
+	    {
+	      enum demangling_styles style;
+
+	      style = cplus_demangle_name_to_style (optarg);
+	      if (style == unknown_demangling)
+		fatal (_("unknown demangling style `%s'"),
+		       optarg);
+
+	      cplus_demangle_set_style (style);
+	    }
+	  break;
+	case OPTION_RECURSE_LIMIT:
+	  demangle_flags &= ~ DMGL_NO_RECURSE_LIMIT;
+	  break;
+	case OPTION_NO_RECURSE_LIMIT:
+	  demangle_flags |= DMGL_NO_RECURSE_LIMIT;
+	  break;
+	case 'w':
+	  do_wide = wide_output = true;
+	  break;
+	case OPTION_ADJUST_VMA:
+	  adjust_section_vma = parse_vma (optarg, "--adjust-vma");
+	  break;
+	case OPTION_START_ADDRESS:
+	  start_address = parse_vma (optarg, "--start-address");
+	  if ((stop_address != (bfd_vma) -1) && stop_address <= start_address)
+	    fatal (_("error: the start address should be before the end address"));
+	  break;
+	case OPTION_STOP_ADDRESS:
+	  stop_address = parse_vma (optarg, "--stop-address");
+	  if ((start_address != (bfd_vma) -1) && stop_address <= start_address)
+	    fatal (_("error: the stop address should be after the start address"));
+	  break;
+	case OPTION_PREFIX:
+	  prefix = optarg;
+	  prefix_length = strlen (prefix);
+	  /* Remove an unnecessary trailing '/' */
+	  while (IS_DIR_SEPARATOR (prefix[prefix_length - 1]))
+	    prefix_length--;
+	  break;
+	case OPTION_PREFIX_STRIP:
+	  prefix_strip = atoi (optarg);
+	  if (prefix_strip < 0)
+	    fatal (_("error: prefix strip must be non-negative"));
+	  break;
+	case OPTION_INSN_WIDTH:
+	  insn_width = strtoul (optarg, NULL, 0);
+	  if (insn_width <= 0)
+	    fatal (_("error: instruction width must be positive"));
+	  break;
+	case OPTION_INLINES:
+	  unwind_inlines = true;
+	  break;
+	case OPTION_VISUALIZE_JUMPS:
+	  visualize_jumps = true;
+	  color_output = false;
+	  extended_color_output = false;
+	  if (optarg != NULL)
+	    {
+	      if (streq (optarg, "color"))
+		color_output = true;
+	      else if (streq (optarg, "extended-color"))
+		{
+		  color_output = true;
+		  extended_color_output = true;
+		}
+	      else if (streq (optarg, "off"))
+		visualize_jumps = false;
+	      else
+		nonfatal (_("unrecognized argument to --visualize-option"));
+	    }
+	  break;
+	case 'E':
+	  if (strcmp (optarg, "B") == 0)
+	    endian = BFD_ENDIAN_BIG;
+	  else if (strcmp (optarg, "L") == 0)
+	    endian = BFD_ENDIAN_LITTLE;
+	  else
+	    {
+	      nonfatal (_("unrecognized -E option"));
+	      usage (stderr, 1);
+	    }
+	  break;
+	case OPTION_ENDIAN:
+	  if (strncmp (optarg, "big", strlen (optarg)) == 0)
+	    endian = BFD_ENDIAN_BIG;
+	  else if (strncmp (optarg, "little", strlen (optarg)) == 0)
+	    endian = BFD_ENDIAN_LITTLE;
+	  else
+	    {
+	      non_fatal (_("unrecognized --endian type `%s'"), optarg);
+	      exit_status = 1;
+	      usage (stderr, 1);
+	    }
+	  break;
+
+	case 'f':
+	  dump_file_header = true;
+	  seenflag = true;
+	  break;
+	case 'i':
+	  formats_info = true;
+	  seenflag = true;
+	  break;
+	case 'I':
+	  add_include_path (optarg);
+	  break;
+	case 'p':
+	  dump_private_headers = true;
+	  seenflag = true;
+	  break;
+	case 'P':
+	  dump_private_options = optarg;
+	  seenflag = true;
+	  break;
+	case 'x':
+	  dump_private_headers = true;
+	  dump_symtab = true;
+	  dump_reloc_info = true;
+	  dump_file_header = true;
+	  dump_ar_hdrs = true;
+	  dump_section_headers = true;
+	  seenflag = true;
+	  break;
+	case 't':
+	  dump_symtab = true;
+	  seenflag = true;
+	  break;
+	case 'T':
+	  dump_dynamic_symtab = true;
+	  seenflag = true;
+	  break;
+	case 'd':
+	  disassemble = true;
+	  seenflag = true;
+	  disasm_sym = optarg;
+	  break;
+	case 'z':
+	  disassemble_zeroes = true;
+	  break;
+	case 'D':
+	  disassemble = true;
+	  disassemble_all = true;
+	  seenflag = true;
+	  break;
+	case 'S':
+	  disassemble = true;
+	  with_source_code = true;
+	  seenflag = true;
+	  break;
+	case OPTION_SOURCE_COMMENT:
+	  disassemble = true;
+	  with_source_code = true;
+	  seenflag = true;
+	  if (optarg)
+	    source_comment = xstrdup (sanitize_string (optarg));
+	  else
+	    source_comment = xstrdup ("# ");
+	  break;
+	case 'g':
+	  dump_debugging = 1;
+	  seenflag = true;
+	  break;
+	case 'e':
+	  dump_debugging = 1;
+	  dump_debugging_tags = 1;
+	  do_demangle = true;
+	  seenflag = true;
+	  break;
+	case 'L':
+	  process_links = true;
+	  do_follow_links = true;
+	  break;
+	case 'W':
+	  dump_dwarf_section_info = true;
+	  seenflag = true;
+	  if (optarg)
+	    dwarf_select_sections_by_letters (optarg);
+	  else
+	    dwarf_select_sections_all ();
+	  break;
+	case OPTION_DWARF:
+	  dump_dwarf_section_info = true;
+	  seenflag = true;
+	  if (optarg)
+	    dwarf_select_sections_by_names (optarg);
+	  else
+	    dwarf_select_sections_all ();
+	  break;
+	case OPTION_DWARF_DEPTH:
+	  {
+	    char *cp;
+	    dwarf_cutoff_level = strtoul (optarg, & cp, 0);
+	  }
+	  break;
+	case OPTION_DWARF_START:
+	  {
+	    char *cp;
+	    dwarf_start_die = strtoul (optarg, & cp, 0);
+	    suppress_bfd_header = 1;
+	  }
+	  break;
+	case OPTION_DWARF_CHECK:
+	  dwarf_check = true;
+	  break;
+#ifdef ENABLE_LIBCTF
+	case OPTION_CTF:
+	  dump_ctf_section_info = true;
+	  dump_ctf_section_name = xstrdup (optarg);
+	  seenflag = true;
+	  break;
+	case OPTION_CTF_PARENT:
+	  dump_ctf_parent_name = xstrdup (optarg);
+	  break;
+#endif
+	case 'G':
+	  dump_stab_section_info = true;
+	  seenflag = true;
+	  break;
+	case 's':
+	  dump_section_contents = true;
+	  seenflag = true;
+	  break;
+	case 'r':
+	  dump_reloc_info = true;
+	  seenflag = true;
+	  break;
+	case 'R':
+	  dump_dynamic_reloc_info = true;
+	  seenflag = true;
+	  break;
+	case 'a':
+	  dump_ar_hdrs = true;
+	  seenflag = true;
+	  break;
+	case 'h':
+	  dump_section_headers = true;
+	  seenflag = true;
+	  break;
+	case 'v':
+	case 'V':
+	  show_version = true;
+	  seenflag = true;
+	  break;
+
+	case 'H':
+	  usage (stdout, 0);
+	  /* No need to set seenflag or to break - usage() does not return.  */
+	default:
+	  usage (stderr, 1);
+	}
+    }
+
+  if (show_version)
+    print_version ("objdump");
+
+  if (!seenflag)
+    usage (stderr, 2);
+
+  if (formats_info)
+    exit_status = display_info ();
+  else
+    {
+      if (optind == argc)
+	display_file ("a.out", target, true);
+      else
+	for (; optind < argc;)
+	  {
+	    display_file (argv[optind], target, optind == argc - 1);
+	    optind++;
+	  }
+    }
+
+  free_only_list ();
+  free (dump_ctf_section_name);
+  free (dump_ctf_parent_name);
+  free ((void *) source_comment);
+
+  END_PROGRESS (program_name);
+
+  return exit_status;
+}
diff -rupN binutils.orig/binutils/objdump.c.rej binutils-2.37/binutils/objdump.c.rej
--- binutils.orig/binutils/objdump.c.rej	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.37/binutils/objdump.c.rej	2021-11-09 12:34:46.291643864 +0000
@@ -0,0 +1,43 @@
+--- binutils/objdump.c
++++ binutils/objdump.c
+@@ -487,28 +517,16 @@ static struct option long_options[]=
+   {"source", no_argument, NULL, 'S'},
+   {"source-comment", optional_argument, NULL, OPTION_SOURCE_COMMENT},
+   {"special-syms", no_argument, &dump_special_syms, 1},
+-  {"include", required_argument, NULL, 'I'},
+-  {"dwarf", optional_argument, NULL, OPTION_DWARF},
+-#ifdef ENABLE_LIBCTF
+-  {"ctf", optional_argument, NULL, OPTION_CTF},
+-  {"ctf-parent", required_argument, NULL, OPTION_CTF_PARENT},
+-#endif
+   {"stabs", no_argument, NULL, 'G'},
+   {"start-address", required_argument, NULL, OPTION_START_ADDRESS},
+   {"stop-address", required_argument, NULL, OPTION_STOP_ADDRESS},
+   {"syms", no_argument, NULL, 't'},
+   {"target", required_argument, NULL, 'b'},
++  {"unicode", required_argument, NULL, 'U'},
+   {"version", no_argument, NULL, 'V'},
+-  {"wide", no_argument, NULL, 'w'},
+-  {"prefix", required_argument, NULL, OPTION_PREFIX},
+-  {"prefix-strip", required_argument, NULL, OPTION_PREFIX_STRIP},
+-  {"insn-width", required_argument, NULL, OPTION_INSN_WIDTH},
+-  {"dwarf-depth", required_argument, 0, OPTION_DWARF_DEPTH},
+-  {"dwarf-start", required_argument, 0, OPTION_DWARF_START},
+-  {"dwarf-check", no_argument, 0, OPTION_DWARF_CHECK},
+-  {"inlines", no_argument, 0, OPTION_INLINES},
+   {"visualize-jumps", optional_argument, 0, OPTION_VISUALIZE_JUMPS},
+-  {0, no_argument, 0, 0}
++  {"wide", no_argument, NULL, 'w'},
++  {NULL, no_argument, NULL, 0}
+ };
+ 
+ static void
+@@ -5375,7 +5533,7 @@ main (int argc, char **argv)
+   set_default_bfd_target ();
+ 
+   while ((c = getopt_long (argc, argv,
+-			   "CDE:FGHI:LM:P:RSTVW::ab:defghij:lm:prstvwxz",
++			   "CDE:FGHI:LM:P:RSTU:VW::ab:defghij:lm:prstvwxz",
+ 			   long_options, (int *) 0))
+ 	 != EOF)
+     {
diff -rupN binutils.orig/binutils/readelf.c binutils-2.37/binutils/readelf.c
--- binutils.orig/binutils/readelf.c	2021-11-09 12:34:21.680802825 +0000
+++ binutils-2.37/binutils/readelf.c	2021-11-09 12:34:46.293643851 +0000
@@ -328,6 +328,19 @@ typedef enum print_mode
 }
 print_mode;
 
+typedef enum unicode_display_type
+{
+  unicode_default = 0,
+  unicode_locale,
+  unicode_escape,
+  unicode_hex,
+  unicode_highlight,
+  unicode_invalid
+} unicode_display_type;
+
+static unicode_display_type unicode_display = unicode_default;
+
+  
 /* Versioned symbol info.  */
 enum versioned_symbol_info
 {
@@ -632,11 +645,18 @@ print_symbol (signed int width, const ch
       if (c == 0)
 	break;
 
-      /* Do not print control characters directly as they can affect terminal
-	 settings.  Such characters usually appear in the names generated
-	 by the assembler for local labels.  */
-      if (ISCNTRL (c))
+      if (ISPRINT (c))
+	{
+	  putchar (c);
+	  width_remaining --;
+	  num_printed ++;
+	}
+      else if (ISCNTRL (c))
 	{
+	  /* Do not print control characters directly as they can affect terminal
+	     settings.  Such characters usually appear in the names generated
+	     by the assembler for local labels.  */
+
 	  if (width_remaining < 2)
 	    break;
 
@@ -644,11 +664,137 @@ print_symbol (signed int width, const ch
 	  width_remaining -= 2;
 	  num_printed += 2;
 	}
-      else if (ISPRINT (c))
+      else if (c == 0x7f)
 	{
-	  putchar (c);
-	  width_remaining --;
-	  num_printed ++;
+	  if (width_remaining < 5)
+	    break;
+	  printf ("<DEL>");
+	  width_remaining -= 5;
+	  num_printed += 5;
+	}
+      else if (unicode_display != unicode_locale
+	       && unicode_display != unicode_default)
+	{
+	  /* Display unicode characters as something else.  */
+	  unsigned char bytes[4];
+	  bool          is_utf8;
+	  uint          nbytes;
+
+	  bytes[0] = c;
+
+	  if (bytes[0] < 0xc0)
+	    {
+	      nbytes = 1;
+	      is_utf8 = false;
+	    }
+	  else
+	    {
+	      bytes[1] = *symbol++;
+
+	      if ((bytes[1] & 0xc0) != 0x80)
+		{
+		  is_utf8 = false;
+		  /* Do not consume this character.  It may only
+		     be the first byte in the sequence that was
+		     corrupt.  */
+		  --symbol;
+		  nbytes = 1;
+		}
+	      else if ((bytes[0] & 0x20) == 0)
+		{
+		  is_utf8 = true;
+		  nbytes = 2;
+		}
+	      else
+		{
+		  bytes[2] = *symbol++;
+
+		  if ((bytes[2] & 0xc0) != 0x80)
+		    {
+		      is_utf8 = false;
+		      symbol -= 2;
+		      nbytes = 1;
+		    }
+		  else if ((bytes[0] & 0x10) == 0)
+		    {
+		      is_utf8 = true;
+		      nbytes = 3;
+		    }
+		  else
+		    {
+		      bytes[3] = *symbol++;
+
+		      nbytes = 4;
+
+		      if ((bytes[3] & 0xc0) != 0x80)
+			{
+			  is_utf8 = false;
+			  symbol -= 3;
+			  nbytes = 1;
+			}
+		      else
+			is_utf8 = true;
+		    }
+		}
+	    }
+
+	  if (unicode_display == unicode_invalid)
+	    is_utf8 = false;
+
+	  if (unicode_display == unicode_hex || ! is_utf8)
+	    {
+	      uint i;
+
+	      if (width_remaining < (nbytes * 2) + 2)
+		break;
+	  
+	      putchar (is_utf8 ? '<' : '{');
+	      printf ("0x");
+	      for (i = 0; i < nbytes; i++)
+		printf ("%02x", bytes[i]);
+	      putchar (is_utf8 ? '>' : '}');
+	    }
+	  else
+	    {
+	      if (unicode_display == unicode_highlight && isatty (1))
+		printf ("\x1B[31;47m"); /* Red.  */
+	      
+	      switch (nbytes)
+		{
+		case 2:
+		  if (width_remaining < 6)
+		    break;
+		  printf ("\\u%02x%02x",
+			  (bytes[0] & 0x1c) >> 2, 
+			  ((bytes[0] & 0x03) << 6) | (bytes[1] & 0x3f));
+		  break;
+		case 3:
+		  if (width_remaining < 6)
+		    break;
+		  printf ("\\u%02x%02x",
+			  ((bytes[0] & 0x0f) << 4) | ((bytes[1] & 0x3c) >> 2),
+			  ((bytes[1] & 0x03) << 6) | (bytes[2] & 0x3f));
+		  break;
+		case 4:
+		  if (width_remaining < 8)
+		    break;
+		  printf ("\\u%02x%02x%02x",
+			  ((bytes[0] & 0x07) << 6) | ((bytes[1] & 0x3c) >> 2),
+			  ((bytes[1] & 0x03) << 6) | ((bytes[2] & 0x3c) >> 2),
+			  ((bytes[2] & 0x03) << 6) | (bytes[3] & 0x3f));
+		  
+		  break;
+		default:
+		  /* URG.  */
+		  break;
+		}
+
+	      if (unicode_display == unicode_highlight && isatty (1))
+		printf ("\033[0m"); /* Default colour.  */
+	    }
+	  
+	  if (bytes[nbytes - 1] == 0)
+	    break;
 	}
       else
 	{
@@ -4668,6 +4814,7 @@ static struct option options[] =
   {"syms",	       no_argument, 0, 's'},
   {"silent-truncation",no_argument, 0, 'T'},
   {"section-details",  no_argument, 0, 't'},
+  {"unicode",          required_argument, NULL, 'U'},
   {"unwind",	       no_argument, 0, 'u'},
   {"version-info",     no_argument, 0, 'V'},
   {"version",	       no_argument, 0, 'v'},
@@ -4744,6 +4891,12 @@ usage (FILE * stream)
   fprintf (stream, _("\
      --no-recurse-limit  Disable a demangling recursion limit\n"));
   fprintf (stream, _("\
+     -U[dlexhi] --unicode=[default|locale|escape|hex|highlight|invalid]\n\
+                         Display unicode characters as determined by the current locale\n\
+                          (default), escape sequences, \"<hex sequences>\", highlighted\n\
+                          escape sequences, or treat them as invalid and display as\n\
+                          \"{hex sequences}\"\n"));
+  fprintf (stream, _("\
   -n --notes             Display the core notes (if present)\n"));
   fprintf (stream, _("\
   -r --relocs            Display the relocations (if present)\n"));
@@ -4928,7 +5081,7 @@ parse_args (struct dump_data *dumpdata,
     usage (stderr);
 
   while ((c = getopt_long
-	  (argc, argv, "ACDHILNPR:STVWacdeghi:lnp:rstuvw::x:z", options, NULL)) != EOF)
+	  (argc, argv, "ACDHILNPR:STU:VWacdeghi:lnp:rstuvw::x:z", options, NULL)) != EOF)
     {
       switch (c)
 	{
@@ -5130,6 +5283,25 @@ parse_args (struct dump_data *dumpdata,
 	  /* Ignored for backward compatibility.  */
 	  break;
 
+	case 'U':
+	  if (optarg == NULL)
+	    error (_("Missing arg to -U/--unicode")); /* Can this happen ?  */
+	  else if (streq (optarg, "default") || streq (optarg, "d"))
+	    unicode_display = unicode_default;
+	  else if (streq (optarg, "locale") || streq (optarg, "l"))
+	    unicode_display = unicode_locale;
+	  else if (streq (optarg, "escape") || streq (optarg, "e"))
+	    unicode_display = unicode_escape;
+	  else if (streq (optarg, "invalid") || streq (optarg, "i"))
+	    unicode_display = unicode_invalid;
+	  else if (streq (optarg, "hex") || streq (optarg, "x"))
+	    unicode_display = unicode_hex;
+	  else if (streq (optarg, "highlight") || streq (optarg, "h"))
+	    unicode_display = unicode_highlight;
+	  else
+	    error (_("invalid argument to -U/--unicode: %s"), optarg);
+	  break;
+
 	case OPTION_SYM_BASE:
 	  sym_base = 0;
 	  if (optarg != NULL)
diff -rupN binutils.orig/binutils/readelf.c.orig binutils-2.37/binutils/readelf.c.orig
--- binutils.orig/binutils/readelf.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.37/binutils/readelf.c.orig	2021-11-09 12:34:05.099909925 +0000
@@ -0,0 +1,22045 @@
+/* readelf.c -- display contents of an ELF format file
+   Copyright (C) 1998-2021 Free Software Foundation, Inc.
+
+   Originally developed by Eric Youngdale <eric@andante.jic.com>
+   Modifications by Nick Clifton <nickc@redhat.com>
+
+   This file is part of GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+/* The difference between readelf and objdump:
+
+  Both programs are capable of displaying the contents of ELF format files,
+  so why does the binutils project have two file dumpers ?
+
+  The reason is that objdump sees an ELF file through a BFD filter of the
+  world; if BFD has a bug where, say, it disagrees about a machine constant
+  in e_flags, then the odds are good that it will remain internally
+  consistent.  The linker sees it the BFD way, objdump sees it the BFD way,
+  GAS sees it the BFD way.  There was need for a tool to go find out what
+  the file actually says.
+
+  This is why the readelf program does not link against the BFD library - it
+  exists as an independent program to help verify the correct working of BFD.
+
+  There is also the case that readelf can provide more information about an
+  ELF file than is provided by objdump.  In particular it can display DWARF
+  debugging information which (at the moment) objdump cannot.  */
+
+#include "sysdep.h"
+#include <assert.h>
+#include <time.h>
+#include <zlib.h>
+#include <wchar.h>
+
+#if __GNUC__ >= 2
+/* Define BFD64 here, even if our default architecture is 32 bit ELF
+   as this will allow us to read in and parse 64bit and 32bit ELF files.
+   Only do this if we believe that the compiler can support a 64 bit
+   data type.  For now we only rely on GCC being able to do this.  */
+#define BFD64
+#endif
+
+#include "bfd.h"
+#include "bucomm.h"
+#include "elfcomm.h"
+#include "dwarf.h"
+#include "ctf-api.h"
+#include "demangle.h"
+
+#include "elf/common.h"
+#include "elf/external.h"
+#include "elf/internal.h"
+
+
+/* Included here, before RELOC_MACROS_GEN_FUNC is defined, so that
+   we can obtain the H8 reloc numbers.  We need these for the
+   get_reloc_size() function.  We include h8.h again after defining
+   RELOC_MACROS_GEN_FUNC so that we get the naming function as well.  */
+
+#include "elf/h8.h"
+#undef _ELF_H8_H
+
+/* Undo the effects of #including reloc-macros.h.  */
+
+#undef START_RELOC_NUMBERS
+#undef RELOC_NUMBER
+#undef FAKE_RELOC
+#undef EMPTY_RELOC
+#undef END_RELOC_NUMBERS
+#undef _RELOC_MACROS_H
+
+/* The following headers use the elf/reloc-macros.h file to
+   automatically generate relocation recognition functions
+   such as elf_mips_reloc_type()  */
+
+#define RELOC_MACROS_GEN_FUNC
+
+#include "elf/aarch64.h"
+#include "elf/alpha.h"
+#include "elf/arc.h"
+#include "elf/arm.h"
+#include "elf/avr.h"
+#include "elf/bfin.h"
+#include "elf/cr16.h"
+#include "elf/cris.h"
+#include "elf/crx.h"
+#include "elf/csky.h"
+#include "elf/d10v.h"
+#include "elf/d30v.h"
+#include "elf/dlx.h"
+#include "elf/bpf.h"
+#include "elf/epiphany.h"
+#include "elf/fr30.h"
+#include "elf/frv.h"
+#include "elf/ft32.h"
+#include "elf/h8.h"
+#include "elf/hppa.h"
+#include "elf/i386.h"
+#include "elf/i370.h"
+#include "elf/i860.h"
+#include "elf/i960.h"
+#include "elf/ia64.h"
+#include "elf/ip2k.h"
+#include "elf/lm32.h"
+#include "elf/iq2000.h"
+#include "elf/m32c.h"
+#include "elf/m32r.h"
+#include "elf/m68k.h"
+#include "elf/m68hc11.h"
+#include "elf/s12z.h"
+#include "elf/mcore.h"
+#include "elf/mep.h"
+#include "elf/metag.h"
+#include "elf/microblaze.h"
+#include "elf/mips.h"
+#include "elf/mmix.h"
+#include "elf/mn10200.h"
+#include "elf/mn10300.h"
+#include "elf/moxie.h"
+#include "elf/mt.h"
+#include "elf/msp430.h"
+#include "elf/nds32.h"
+#include "elf/nfp.h"
+#include "elf/nios2.h"
+#include "elf/or1k.h"
+#include "elf/pj.h"
+#include "elf/ppc.h"
+#include "elf/ppc64.h"
+#include "elf/pru.h"
+#include "elf/riscv.h"
+#include "elf/rl78.h"
+#include "elf/rx.h"
+#include "elf/s390.h"
+#include "elf/score.h"
+#include "elf/sh.h"
+#include "elf/sparc.h"
+#include "elf/spu.h"
+#include "elf/tic6x.h"
+#include "elf/tilegx.h"
+#include "elf/tilepro.h"
+#include "elf/v850.h"
+#include "elf/vax.h"
+#include "elf/visium.h"
+#include "elf/wasm32.h"
+#include "elf/x86-64.h"
+#include "elf/xc16x.h"
+#include "elf/xgate.h"
+#include "elf/xstormy16.h"
+#include "elf/xtensa.h"
+#include "elf/z80.h"
+
+#include "getopt.h"
+#include "libiberty.h"
+#include "safe-ctype.h"
+#include "filenames.h"
+
+#ifndef offsetof
+#define offsetof(TYPE, MEMBER) ((size_t) &(((TYPE *) 0)->MEMBER))
+#endif
+
+typedef struct elf_section_list
+{
+  Elf_Internal_Shdr *        hdr;
+  struct elf_section_list *  next;
+} elf_section_list;
+
+/* Flag bits indicating particular types of dump.  */
+#define HEX_DUMP	(1 << 0)	/* The -x command line switch.  */
+#define DISASS_DUMP	(1 << 1)	/* The -i command line switch.  */
+#define DEBUG_DUMP	(1 << 2)	/* The -w command line switch.  */
+#define STRING_DUMP     (1 << 3)	/* The -p command line switch.  */
+#define RELOC_DUMP      (1 << 4)	/* The -R command line switch.  */
+#define CTF_DUMP	(1 << 5)	/* The --ctf command line switch.  */
+
+typedef unsigned char dump_type;
+
+/* A linked list of the section names for which dumps were requested.  */
+struct dump_list_entry
+{
+  char *                    name;
+  dump_type                 type;
+  struct dump_list_entry *  next;
+};
+
+/* A dynamic array of flags indicating for which sections a dump
+   has been requested via command line switches.  */
+struct dump_data
+{
+  dump_type *          dump_sects;
+  unsigned int         num_dump_sects;
+};
+
+static struct dump_data cmdline;
+
+static struct dump_list_entry * dump_sects_byname;
+
+char * program_name = "readelf";
+
+static bool show_name = false;
+static bool do_dynamic = false;
+static bool do_syms = false;
+static bool do_dyn_syms = false;
+static bool do_lto_syms = false;
+static bool do_reloc = false;
+static bool do_sections = false;
+static bool do_section_groups = false;
+static bool do_section_details = false;
+static bool do_segments = false;
+static bool do_unwind = false;
+static bool do_using_dynamic = false;
+static bool do_header = false;
+static bool do_dump = false;
+static bool do_version = false;
+static bool do_histogram = false;
+static bool do_debugging = false;
+static bool do_ctf = false;
+static bool do_arch = false;
+static bool do_notes = false;
+static bool do_archive_index = false;
+static bool check_all = false;
+static bool is_32bit_elf = false;
+static bool decompress_dumps = false;
+static bool do_not_show_symbol_truncation = false;
+static bool do_demangle = false;	/* Pretty print C++ symbol names.  */
+static bool process_links = false;
+static int demangle_flags = DMGL_ANSI | DMGL_PARAMS;
+static int sym_base = 0;
+
+static char *dump_ctf_parent_name;
+static char *dump_ctf_symtab_name;
+static char *dump_ctf_strtab_name;
+
+struct group_list
+{
+  struct group_list *  next;
+  unsigned int         section_index;
+};
+
+struct group
+{
+  struct group_list *  root;
+  unsigned int         group_index;
+};
+
+typedef struct filedata
+{
+  const char *         file_name;
+  bool                 is_separate;
+  FILE *               handle;
+  bfd_size_type        file_size;
+  Elf_Internal_Ehdr    file_header;
+  unsigned long        archive_file_offset;
+  unsigned long        archive_file_size;
+  /* Everything below this point is cleared out by free_filedata.  */
+  Elf_Internal_Shdr *  section_headers;
+  Elf_Internal_Phdr *  program_headers;
+  char *               string_table;
+  unsigned long        string_table_length;
+  unsigned long        dynamic_addr;
+  bfd_size_type        dynamic_size;
+  size_t               dynamic_nent;
+  Elf_Internal_Dyn *   dynamic_section;
+  Elf_Internal_Shdr *  dynamic_strtab_section;
+  char *               dynamic_strings;
+  unsigned long        dynamic_strings_length;
+  Elf_Internal_Shdr *  dynamic_symtab_section;
+  unsigned long        num_dynamic_syms;
+  Elf_Internal_Sym *   dynamic_symbols;
+  bfd_vma              version_info[16];
+  unsigned int         dynamic_syminfo_nent;
+  Elf_Internal_Syminfo * dynamic_syminfo;
+  unsigned long        dynamic_syminfo_offset;
+  bfd_size_type        nbuckets;
+  bfd_size_type        nchains;
+  bfd_vma *            buckets;
+  bfd_vma *            chains;
+  bfd_size_type        ngnubuckets;
+  bfd_size_type        ngnuchains;
+  bfd_vma *            gnubuckets;
+  bfd_vma *            gnuchains;
+  bfd_vma *            mipsxlat;
+  bfd_vma              gnusymidx;
+  char *               program_interpreter;
+  bfd_vma              dynamic_info[DT_ENCODING];
+  bfd_vma              dynamic_info_DT_GNU_HASH;
+  bfd_vma              dynamic_info_DT_MIPS_XHASH;
+  elf_section_list *   symtab_shndx_list;
+  size_t               group_count;
+  struct group *       section_groups;
+  struct group **      section_headers_groups;
+  /* A dynamic array of flags indicating for which sections a dump of
+     some kind has been requested.  It is reset on a per-object file
+     basis and then initialised from the cmdline_dump_sects array,
+     the results of interpreting the -w switch, and the
+     dump_sects_byname list.  */
+  struct dump_data     dump;
+} Filedata;
+
+/* How to print a vma value.  */
+typedef enum print_mode
+{
+  HEX,
+  HEX_5,
+  DEC,
+  DEC_5,
+  UNSIGNED,
+  UNSIGNED_5,
+  PREFIX_HEX,
+  PREFIX_HEX_5,
+  FULL_HEX,
+  LONG_HEX,
+  OCTAL,
+  OCTAL_5
+}
+print_mode;
+
+/* Versioned symbol info.  */
+enum versioned_symbol_info
+{
+  symbol_undefined,
+  symbol_hidden,
+  symbol_public
+};
+
+static const char * get_symbol_version_string
+  (Filedata *, bool, const char *, unsigned long, unsigned,
+   Elf_Internal_Sym *, enum versioned_symbol_info *, unsigned short *);
+
+#define UNKNOWN -1
+
+#define SECTION_NAME(X) \
+  (filedata->string_table + (X)->sh_name)
+
+#define SECTION_NAME_VALID(X) \
+  ((X) != NULL								\
+   && filedata->string_table != NULL					\
+   && (X)->sh_name < filedata->string_table_length)
+
+#define SECTION_NAME_PRINT(X) \
+  ((X) == NULL ? _("<none>")						\
+   : filedata->string_table == NULL ? _("<no-strings>")			\
+   : (X)->sh_name >= filedata->string_table_length ? _("<corrupt>")	\
+   : filedata->string_table + (X)->sh_name)
+
+#define DT_VERSIONTAGIDX(tag)	(DT_VERNEEDNUM - (tag))	/* Reverse order!  */
+
+#define VALID_SYMBOL_NAME(strtab, strtab_size, offset) \
+   (strtab != NULL && offset < strtab_size)
+#define VALID_DYNAMIC_NAME(filedata, offset) \
+  VALID_SYMBOL_NAME (filedata->dynamic_strings, \
+		     filedata->dynamic_strings_length, offset)
+/* GET_DYNAMIC_NAME asssumes that VALID_DYNAMIC_NAME has
+   already been called and verified that the string exists.  */
+#define GET_DYNAMIC_NAME(filedata, offset) \
+  (filedata->dynamic_strings + offset)
+
+#define REMOVE_ARCH_BITS(ADDR)			\
+  do						\
+    {						\
+      if (filedata->file_header.e_machine == EM_ARM)	\
+	(ADDR) &= ~1;				\
+    }						\
+  while (0)
+
+/* Get the correct GNU hash section name.  */
+#define GNU_HASH_SECTION_NAME(filedata)		\
+  filedata->dynamic_info_DT_MIPS_XHASH ? ".MIPS.xhash" : ".gnu.hash"
+
+/* Print a BFD_VMA to an internal buffer, for use in error messages.
+   BFD_FMA_FMT can't be used in translated strings.  */
+
+static const char *
+bfd_vmatoa (char *fmtch, bfd_vma value)
+{
+  /* bfd_vmatoa is used more then once in a printf call for output.
+     Cycle through an array of buffers.  */
+  static int buf_pos = 0;
+  static struct bfd_vmatoa_buf
+  {
+    char place[64];
+  } buf[4];
+  char *ret;
+  char fmt[32];
+
+  ret = buf[buf_pos++].place;
+  buf_pos %= ARRAY_SIZE (buf);
+
+  sprintf (fmt, "%%%s%s", BFD_VMA_FMT, fmtch);
+  snprintf (ret, sizeof (buf[0].place), fmt, value);
+  return ret;
+}
+
+/* Retrieve NMEMB structures, each SIZE bytes long from FILEDATA starting at
+   OFFSET + the offset of the current archive member, if we are examining an
+   archive.  Put the retrieved data into VAR, if it is not NULL.  Otherwise
+   allocate a buffer using malloc and fill that.  In either case return the
+   pointer to the start of the retrieved data or NULL if something went wrong.
+   If something does go wrong and REASON is not NULL then emit an error
+   message using REASON as part of the context.  */
+
+static void *
+get_data (void *         var,
+	  Filedata *     filedata,
+	  unsigned long  offset,
+	  bfd_size_type  size,
+	  bfd_size_type  nmemb,
+	  const char *   reason)
+{
+  void * mvar;
+  bfd_size_type amt = size * nmemb;
+
+  if (size == 0 || nmemb == 0)
+    return NULL;
+
+  /* If the size_t type is smaller than the bfd_size_type, eg because
+     you are building a 32-bit tool on a 64-bit host, then make sure
+     that when the sizes are cast to (size_t) no information is lost.  */
+  if ((size_t) size != size
+      || (size_t) nmemb != nmemb
+      || (size_t) amt != amt)
+    {
+      if (reason)
+	error (_("Size truncation prevents reading %s"
+		 " elements of size %s for %s\n"),
+	       bfd_vmatoa ("u", nmemb), bfd_vmatoa ("u", size), reason);
+      return NULL;
+    }
+
+  /* Check for size overflow.  */
+  if (amt / size != nmemb || (size_t) amt + 1 == 0)
+    {
+      if (reason)
+	error (_("Size overflow prevents reading %s"
+		 " elements of size %s for %s\n"),
+	       bfd_vmatoa ("u", nmemb), bfd_vmatoa ("u", size), reason);
+      return NULL;
+    }
+
+  /* Be kind to memory checkers (eg valgrind, address sanitizer) by not
+     attempting to allocate memory when the read is bound to fail.  */
+  if (filedata->archive_file_offset > filedata->file_size
+      || offset > filedata->file_size - filedata->archive_file_offset
+      || amt > filedata->file_size - filedata->archive_file_offset - offset)
+    {
+      if (reason)
+	error (_("Reading %s bytes extends past end of file for %s\n"),
+	       bfd_vmatoa ("u", amt), reason);
+      return NULL;
+    }
+
+  if (fseek (filedata->handle, filedata->archive_file_offset + offset,
+	     SEEK_SET))
+    {
+      if (reason)
+	error (_("Unable to seek to 0x%lx for %s\n"),
+	       filedata->archive_file_offset + offset, reason);
+      return NULL;
+    }
+
+  mvar = var;
+  if (mvar == NULL)
+    {
+      /* + 1 so that we can '\0' terminate invalid string table sections.  */
+      mvar = malloc ((size_t) amt + 1);
+
+      if (mvar == NULL)
+	{
+	  if (reason)
+	    error (_("Out of memory allocating %s bytes for %s\n"),
+		   bfd_vmatoa ("u", amt), reason);
+	  return NULL;
+	}
+
+      ((char *) mvar)[amt] = '\0';
+    }
+
+  if (fread (mvar, (size_t) size, (size_t) nmemb, filedata->handle) != nmemb)
+    {
+      if (reason)
+	error (_("Unable to read in %s bytes of %s\n"),
+	       bfd_vmatoa ("u", amt), reason);
+      if (mvar != var)
+	free (mvar);
+      return NULL;
+    }
+
+  return mvar;
+}
+
+/* Print a VMA value in the MODE specified.
+   Returns the number of characters displayed.  */
+
+static unsigned int
+print_vma (bfd_vma vma, print_mode mode)
+{
+  unsigned int nc = 0;
+
+  switch (mode)
+    {
+    case FULL_HEX:
+      nc = printf ("0x");
+      /* Fall through.  */
+    case LONG_HEX:
+#ifdef BFD64
+      if (is_32bit_elf)
+	return nc + printf ("%8.8" BFD_VMA_FMT "x", vma);
+#endif
+      printf_vma (vma);
+      return nc + 16;
+
+    case DEC_5:
+      if (vma <= 99999)
+	return printf ("%5" BFD_VMA_FMT "d", vma);
+      /* Fall through.  */
+    case PREFIX_HEX:
+      nc = printf ("0x");
+      /* Fall through.  */
+    case HEX:
+      return nc + printf ("%" BFD_VMA_FMT "x", vma);
+
+    case PREFIX_HEX_5:
+      nc = printf ("0x");
+      /* Fall through.  */
+    case HEX_5:
+      return nc + printf ("%05" BFD_VMA_FMT "x", vma);
+
+    case DEC:
+      return printf ("%" BFD_VMA_FMT "d", vma);
+
+    case UNSIGNED:
+      return printf ("%" BFD_VMA_FMT "u", vma);
+
+    case UNSIGNED_5:
+      return printf ("%5" BFD_VMA_FMT "u", vma);
+
+    case OCTAL:
+      return printf ("%" BFD_VMA_FMT "o", vma);
+
+    case OCTAL_5:
+      return printf ("%5" BFD_VMA_FMT "o", vma);
+
+    default:
+      /* FIXME: Report unrecognised mode ?  */
+      return 0;
+    }
+}
+
+
+/* Display a symbol on stdout.  Handles the display of control characters and
+   multibye characters (assuming the host environment supports them).
+
+   Display at most abs(WIDTH) characters, truncating as necessary, unless do_wide is true.
+
+   If truncation will happen and do_not_show_symbol_truncation is FALSE then display
+   abs(WIDTH) - 5 characters followed by "[...]".
+
+   If WIDTH is negative then ensure that the output is at least (- WIDTH) characters,
+   padding as necessary.
+
+   Returns the number of emitted characters.  */
+
+static unsigned int
+print_symbol (signed int width, const char * symbol)
+{
+  bool extra_padding = false;
+  bool do_dots = false;
+  signed int num_printed = 0;
+#ifdef HAVE_MBSTATE_T
+  mbstate_t state;
+#endif
+  unsigned int width_remaining;
+  const void * alloced_symbol = NULL;
+
+  if (width < 0)
+    {
+      /* Keep the width positive.  This helps the code below.  */
+      width = - width;
+      extra_padding = true;
+    }
+  else if (width == 0)
+    return 0;
+
+  if (do_wide)
+    /* Set the remaining width to a very large value.
+       This simplifies the code below.  */
+    width_remaining = INT_MAX;
+  else
+    {
+      width_remaining = width;
+      if (! do_not_show_symbol_truncation
+	  && (int) strlen (symbol) > width)
+	{
+	  width_remaining -= 5;
+	  if ((int) width_remaining < 0)
+	    width_remaining = 0;
+	  do_dots = true;
+	}
+    }
+
+#ifdef HAVE_MBSTATE_T
+  /* Initialise the multibyte conversion state.  */
+  memset (& state, 0, sizeof (state));
+#endif
+
+  if (do_demangle && *symbol)
+    {
+      const char * res = cplus_demangle (symbol, demangle_flags);
+
+      if (res != NULL)
+	alloced_symbol = symbol = res;
+    }
+
+  while (width_remaining)
+    {
+      size_t  n;
+      const char c = *symbol++;
+
+      if (c == 0)
+	break;
+
+      /* Do not print control characters directly as they can affect terminal
+	 settings.  Such characters usually appear in the names generated
+	 by the assembler for local labels.  */
+      if (ISCNTRL (c))
+	{
+	  if (width_remaining < 2)
+	    break;
+
+	  printf ("^%c", c + 0x40);
+	  width_remaining -= 2;
+	  num_printed += 2;
+	}
+      else if (ISPRINT (c))
+	{
+	  putchar (c);
+	  width_remaining --;
+	  num_printed ++;
+	}
+      else
+	{
+#ifdef HAVE_MBSTATE_T
+	  wchar_t w;
+#endif
+	  /* Let printf do the hard work of displaying multibyte characters.  */
+	  printf ("%.1s", symbol - 1);
+	  width_remaining --;
+	  num_printed ++;
+
+#ifdef HAVE_MBSTATE_T
+	  /* Try to find out how many bytes made up the character that was
+	     just printed.  Advance the symbol pointer past the bytes that
+	     were displayed.  */
+	  n = mbrtowc (& w, symbol - 1, MB_CUR_MAX, & state);
+#else
+	  n = 1;
+#endif
+	  if (n != (size_t) -1 && n != (size_t) -2 && n > 0)
+	    symbol += (n - 1);
+	}
+    }
+
+  if (do_dots)
+    num_printed += printf ("[...]");
+
+  if (extra_padding && num_printed < width)
+    {
+      /* Fill in the remaining spaces.  */
+      printf ("%-*s", width - num_printed, " ");
+      num_printed = width;
+    }
+
+  free ((void *) alloced_symbol);
+  return num_printed;
+}
+
+/* Returns a pointer to a static buffer containing a printable version of
+   the given section's name.  Like print_symbol, except that it does not try
+   to print multibyte characters, it just interprets them as hex values.  */
+
+static const char *
+printable_section_name (Filedata * filedata, const Elf_Internal_Shdr * sec)
+{
+#define MAX_PRINT_SEC_NAME_LEN 256
+  static char  sec_name_buf [MAX_PRINT_SEC_NAME_LEN + 1];
+  const char * name = SECTION_NAME_PRINT (sec);
+  char *       buf = sec_name_buf;
+  char         c;
+  unsigned int remaining = MAX_PRINT_SEC_NAME_LEN;
+
+  while ((c = * name ++) != 0)
+    {
+      if (ISCNTRL (c))
+	{
+	  if (remaining < 2)
+	    break;
+
+	  * buf ++ = '^';
+	  * buf ++ = c + 0x40;
+	  remaining -= 2;
+	}
+      else if (ISPRINT (c))
+	{
+	  * buf ++ = c;
+	  remaining -= 1;
+	}
+      else
+	{
+	  static char hex[17] = "0123456789ABCDEF";
+
+	  if (remaining < 4)
+	    break;
+	  * buf ++ = '<';
+	  * buf ++ = hex[(c & 0xf0) >> 4];
+	  * buf ++ = hex[c & 0x0f];
+	  * buf ++ = '>';
+	  remaining -= 4;
+	}
+
+      if (remaining == 0)
+	break;
+    }
+
+  * buf = 0;
+  return sec_name_buf;
+}
+
+static const char *
+printable_section_name_from_index (Filedata * filedata, unsigned long ndx)
+{
+  if (ndx >= filedata->file_header.e_shnum)
+    return _("<corrupt>");
+
+  return printable_section_name (filedata, filedata->section_headers + ndx);
+}
+
+/* Return a pointer to section NAME, or NULL if no such section exists.  */
+
+static Elf_Internal_Shdr *
+find_section (Filedata * filedata, const char * name)
+{
+  unsigned int i;
+
+  if (filedata->section_headers == NULL)
+    return NULL;
+
+  for (i = 0; i < filedata->file_header.e_shnum; i++)
+    if (SECTION_NAME_VALID (filedata->section_headers + i)
+	&& streq (SECTION_NAME (filedata->section_headers + i), name))
+      return filedata->section_headers + i;
+
+  return NULL;
+}
+
+/* Return a pointer to a section containing ADDR, or NULL if no such
+   section exists.  */
+
+static Elf_Internal_Shdr *
+find_section_by_address (Filedata * filedata, bfd_vma addr)
+{
+  unsigned int i;
+
+  if (filedata->section_headers == NULL)
+    return NULL;
+
+  for (i = 0; i < filedata->file_header.e_shnum; i++)
+    {
+      Elf_Internal_Shdr *sec = filedata->section_headers + i;
+
+      if (addr >= sec->sh_addr && addr < sec->sh_addr + sec->sh_size)
+	return sec;
+    }
+
+  return NULL;
+}
+
+static Elf_Internal_Shdr *
+find_section_by_type (Filedata * filedata, unsigned int type)
+{
+  unsigned int i;
+
+  if (filedata->section_headers == NULL)
+    return NULL;
+
+  for (i = 0; i < filedata->file_header.e_shnum; i++)
+    {
+      Elf_Internal_Shdr *sec = filedata->section_headers + i;
+
+      if (sec->sh_type == type)
+	return sec;
+    }
+
+  return NULL;
+}
+
+/* Return a pointer to section NAME, or NULL if no such section exists,
+   restricted to the list of sections given in SET.  */
+
+static Elf_Internal_Shdr *
+find_section_in_set (Filedata * filedata, const char * name, unsigned int * set)
+{
+  unsigned int i;
+
+  if (filedata->section_headers == NULL)
+    return NULL;
+
+  if (set != NULL)
+    {
+      while ((i = *set++) > 0)
+	{
+	  /* See PR 21156 for a reproducer.  */
+	  if (i >= filedata->file_header.e_shnum)
+	    continue; /* FIXME: Should we issue an error message ?  */
+
+	  if (SECTION_NAME_VALID (filedata->section_headers + i)
+	      && streq (SECTION_NAME (filedata->section_headers + i), name))
+	    return filedata->section_headers + i;
+	}
+    }
+
+  return find_section (filedata, name);
+}
+
+/* Return TRUE if the current file is for IA-64 machine and OpenVMS ABI.
+   This OS has so many departures from the ELF standard that we test it at
+   many places.  */
+
+static inline bool
+is_ia64_vms (Filedata * filedata)
+{
+  return filedata->file_header.e_machine == EM_IA_64
+    && filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_OPENVMS;
+}
+
+/* Guess the relocation size commonly used by the specific machines.  */
+
+static bool
+guess_is_rela (unsigned int e_machine)
+{
+  switch (e_machine)
+    {
+      /* Targets that use REL relocations.  */
+    case EM_386:
+    case EM_IAMCU:
+    case EM_960:
+    case EM_ARM:
+    case EM_D10V:
+    case EM_CYGNUS_D10V:
+    case EM_DLX:
+    case EM_MIPS:
+    case EM_MIPS_RS3_LE:
+    case EM_CYGNUS_M32R:
+    case EM_SCORE:
+    case EM_XGATE:
+    case EM_NFP:
+    case EM_BPF:
+      return false;
+
+      /* Targets that use RELA relocations.  */
+    case EM_68K:
+    case EM_860:
+    case EM_AARCH64:
+    case EM_ADAPTEVA_EPIPHANY:
+    case EM_ALPHA:
+    case EM_ALTERA_NIOS2:
+    case EM_ARC:
+    case EM_ARC_COMPACT:
+    case EM_ARC_COMPACT2:
+    case EM_AVR:
+    case EM_AVR_OLD:
+    case EM_BLACKFIN:
+    case EM_CR16:
+    case EM_CRIS:
+    case EM_CRX:
+    case EM_CSKY:
+    case EM_D30V:
+    case EM_CYGNUS_D30V:
+    case EM_FR30:
+    case EM_FT32:
+    case EM_CYGNUS_FR30:
+    case EM_CYGNUS_FRV:
+    case EM_H8S:
+    case EM_H8_300:
+    case EM_H8_300H:
+    case EM_IA_64:
+    case EM_IP2K:
+    case EM_IP2K_OLD:
+    case EM_IQ2000:
+    case EM_LATTICEMICO32:
+    case EM_M32C_OLD:
+    case EM_M32C:
+    case EM_M32R:
+    case EM_MCORE:
+    case EM_CYGNUS_MEP:
+    case EM_METAG:
+    case EM_MMIX:
+    case EM_MN10200:
+    case EM_CYGNUS_MN10200:
+    case EM_MN10300:
+    case EM_CYGNUS_MN10300:
+    case EM_MOXIE:
+    case EM_MSP430:
+    case EM_MSP430_OLD:
+    case EM_MT:
+    case EM_NDS32:
+    case EM_NIOS32:
+    case EM_OR1K:
+    case EM_PPC64:
+    case EM_PPC:
+    case EM_TI_PRU:
+    case EM_RISCV:
+    case EM_RL78:
+    case EM_RX:
+    case EM_S390:
+    case EM_S390_OLD:
+    case EM_SH:
+    case EM_SPARC:
+    case EM_SPARC32PLUS:
+    case EM_SPARCV9:
+    case EM_SPU:
+    case EM_TI_C6000:
+    case EM_TILEGX:
+    case EM_TILEPRO:
+    case EM_V800:
+    case EM_V850:
+    case EM_CYGNUS_V850:
+    case EM_VAX:
+    case EM_VISIUM:
+    case EM_X86_64:
+    case EM_L1OM:
+    case EM_K1OM:
+    case EM_XSTORMY16:
+    case EM_XTENSA:
+    case EM_XTENSA_OLD:
+    case EM_MICROBLAZE:
+    case EM_MICROBLAZE_OLD:
+    case EM_WEBASSEMBLY:
+      return true;
+
+    case EM_68HC05:
+    case EM_68HC08:
+    case EM_68HC11:
+    case EM_68HC16:
+    case EM_FX66:
+    case EM_ME16:
+    case EM_MMA:
+    case EM_NCPU:
+    case EM_NDR1:
+    case EM_PCP:
+    case EM_ST100:
+    case EM_ST19:
+    case EM_ST7:
+    case EM_ST9PLUS:
+    case EM_STARCORE:
+    case EM_SVX:
+    case EM_TINYJ:
+    default:
+      warn (_("Don't know about relocations on this machine architecture\n"));
+      return false;
+    }
+}
+
+/* Load RELA type relocations from FILEDATA at REL_OFFSET extending for REL_SIZE bytes.
+   Returns TRUE upon success, FALSE otherwise.  If successful then a
+   pointer to a malloc'ed buffer containing the relocs is placed in *RELASP,
+   and the number of relocs loaded is placed in *NRELASP.  It is the caller's
+   responsibility to free the allocated buffer.  */
+
+static bool
+slurp_rela_relocs (Filedata *            filedata,
+		   unsigned long         rel_offset,
+		   unsigned long         rel_size,
+		   Elf_Internal_Rela **  relasp,
+		   unsigned long *       nrelasp)
+{
+  Elf_Internal_Rela * relas;
+  size_t nrelas;
+  unsigned int i;
+
+  if (is_32bit_elf)
+    {
+      Elf32_External_Rela * erelas;
+
+      erelas = (Elf32_External_Rela *) get_data (NULL, filedata, rel_offset, 1,
+                                                 rel_size, _("32-bit relocation data"));
+      if (!erelas)
+	return false;
+
+      nrelas = rel_size / sizeof (Elf32_External_Rela);
+
+      relas = (Elf_Internal_Rela *) cmalloc (nrelas,
+                                             sizeof (Elf_Internal_Rela));
+
+      if (relas == NULL)
+	{
+	  free (erelas);
+	  error (_("out of memory parsing relocs\n"));
+	  return false;
+	}
+
+      for (i = 0; i < nrelas; i++)
+	{
+	  relas[i].r_offset = BYTE_GET (erelas[i].r_offset);
+	  relas[i].r_info   = BYTE_GET (erelas[i].r_info);
+	  relas[i].r_addend = BYTE_GET_SIGNED (erelas[i].r_addend);
+	}
+
+      free (erelas);
+    }
+  else
+    {
+      Elf64_External_Rela * erelas;
+
+      erelas = (Elf64_External_Rela *) get_data (NULL, filedata, rel_offset, 1,
+                                                 rel_size, _("64-bit relocation data"));
+      if (!erelas)
+	return false;
+
+      nrelas = rel_size / sizeof (Elf64_External_Rela);
+
+      relas = (Elf_Internal_Rela *) cmalloc (nrelas,
+                                             sizeof (Elf_Internal_Rela));
+
+      if (relas == NULL)
+	{
+	  free (erelas);
+	  error (_("out of memory parsing relocs\n"));
+	  return false;
+	}
+
+      for (i = 0; i < nrelas; i++)
+	{
+	  relas[i].r_offset = BYTE_GET (erelas[i].r_offset);
+	  relas[i].r_info   = BYTE_GET (erelas[i].r_info);
+	  relas[i].r_addend = BYTE_GET_SIGNED (erelas[i].r_addend);
+
+	  /* The #ifdef BFD64 below is to prevent a compile time
+	     warning.  We know that if we do not have a 64 bit data
+	     type that we will never execute this code anyway.  */
+#ifdef BFD64
+	  if (filedata->file_header.e_machine == EM_MIPS
+	      && filedata->file_header.e_ident[EI_DATA] != ELFDATA2MSB)
+	    {
+	      /* In little-endian objects, r_info isn't really a
+		 64-bit little-endian value: it has a 32-bit
+		 little-endian symbol index followed by four
+		 individual byte fields.  Reorder INFO
+		 accordingly.  */
+	      bfd_vma inf = relas[i].r_info;
+	      inf = (((inf & 0xffffffff) << 32)
+		      | ((inf >> 56) & 0xff)
+		      | ((inf >> 40) & 0xff00)
+		      | ((inf >> 24) & 0xff0000)
+		      | ((inf >> 8) & 0xff000000));
+	      relas[i].r_info = inf;
+	    }
+#endif /* BFD64 */
+	}
+
+      free (erelas);
+    }
+
+  *relasp = relas;
+  *nrelasp = nrelas;
+  return true;
+}
+
+/* Load REL type relocations from FILEDATA at REL_OFFSET extending for REL_SIZE bytes.
+   Returns TRUE upon success, FALSE otherwise.  If successful then a
+   pointer to a malloc'ed buffer containing the relocs is placed in *RELSP,
+   and the number of relocs loaded is placed in *NRELSP.  It is the caller's
+   responsibility to free the allocated buffer.  */
+
+static bool
+slurp_rel_relocs (Filedata *            filedata,
+		  unsigned long         rel_offset,
+		  unsigned long         rel_size,
+		  Elf_Internal_Rela **  relsp,
+		  unsigned long *       nrelsp)
+{
+  Elf_Internal_Rela * rels;
+  size_t nrels;
+  unsigned int i;
+
+  if (is_32bit_elf)
+    {
+      Elf32_External_Rel * erels;
+
+      erels = (Elf32_External_Rel *) get_data (NULL, filedata, rel_offset, 1,
+                                               rel_size, _("32-bit relocation data"));
+      if (!erels)
+	return false;
+
+      nrels = rel_size / sizeof (Elf32_External_Rel);
+
+      rels = (Elf_Internal_Rela *) cmalloc (nrels, sizeof (Elf_Internal_Rela));
+
+      if (rels == NULL)
+	{
+	  free (erels);
+	  error (_("out of memory parsing relocs\n"));
+	  return false;
+	}
+
+      for (i = 0; i < nrels; i++)
+	{
+	  rels[i].r_offset = BYTE_GET (erels[i].r_offset);
+	  rels[i].r_info   = BYTE_GET (erels[i].r_info);
+	  rels[i].r_addend = 0;
+	}
+
+      free (erels);
+    }
+  else
+    {
+      Elf64_External_Rel * erels;
+
+      erels = (Elf64_External_Rel *) get_data (NULL, filedata, rel_offset, 1,
+                                               rel_size, _("64-bit relocation data"));
+      if (!erels)
+	return false;
+
+      nrels = rel_size / sizeof (Elf64_External_Rel);
+
+      rels = (Elf_Internal_Rela *) cmalloc (nrels, sizeof (Elf_Internal_Rela));
+
+      if (rels == NULL)
+	{
+	  free (erels);
+	  error (_("out of memory parsing relocs\n"));
+	  return false;
+	}
+
+      for (i = 0; i < nrels; i++)
+	{
+	  rels[i].r_offset = BYTE_GET (erels[i].r_offset);
+	  rels[i].r_info   = BYTE_GET (erels[i].r_info);
+	  rels[i].r_addend = 0;
+
+	  /* The #ifdef BFD64 below is to prevent a compile time
+	     warning.  We know that if we do not have a 64 bit data
+	     type that we will never execute this code anyway.  */
+#ifdef BFD64
+	  if (filedata->file_header.e_machine == EM_MIPS
+	      && filedata->file_header.e_ident[EI_DATA] != ELFDATA2MSB)
+	    {
+	      /* In little-endian objects, r_info isn't really a
+		 64-bit little-endian value: it has a 32-bit
+		 little-endian symbol index followed by four
+		 individual byte fields.  Reorder INFO
+		 accordingly.  */
+	      bfd_vma inf = rels[i].r_info;
+	      inf = (((inf & 0xffffffff) << 32)
+		     | ((inf >> 56) & 0xff)
+		     | ((inf >> 40) & 0xff00)
+		     | ((inf >> 24) & 0xff0000)
+		     | ((inf >> 8) & 0xff000000));
+	      rels[i].r_info = inf;
+	    }
+#endif /* BFD64 */
+	}
+
+      free (erels);
+    }
+
+  *relsp = rels;
+  *nrelsp = nrels;
+  return true;
+}
+
+/* Returns the reloc type extracted from the reloc info field.  */
+
+static unsigned int
+get_reloc_type (Filedata * filedata, bfd_vma reloc_info)
+{
+  if (is_32bit_elf)
+    return ELF32_R_TYPE (reloc_info);
+
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_MIPS:
+      /* Note: We assume that reloc_info has already been adjusted for us.  */
+      return ELF64_MIPS_R_TYPE (reloc_info);
+
+    case EM_SPARCV9:
+      return ELF64_R_TYPE_ID (reloc_info);
+
+    default:
+      return ELF64_R_TYPE (reloc_info);
+    }
+}
+
+/* Return the symbol index extracted from the reloc info field.  */
+
+static bfd_vma
+get_reloc_symindex (bfd_vma reloc_info)
+{
+  return is_32bit_elf ? ELF32_R_SYM (reloc_info) : ELF64_R_SYM (reloc_info);
+}
+
+static inline bool
+uses_msp430x_relocs (Filedata * filedata)
+{
+  return
+    filedata->file_header.e_machine == EM_MSP430 /* Paranoia.  */
+    /* GCC uses osabi == ELFOSBI_STANDALONE.  */
+    && (((filedata->file_header.e_flags & EF_MSP430_MACH) == E_MSP430_MACH_MSP430X)
+	/* TI compiler uses ELFOSABI_NONE.  */
+	|| (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_NONE));
+}
+
+/* Display the contents of the relocation data found at the specified
+   offset.  */
+
+static bool
+dump_relocations (Filedata *          filedata,
+		  unsigned long       rel_offset,
+		  unsigned long       rel_size,
+		  Elf_Internal_Sym *  symtab,
+		  unsigned long       nsyms,
+		  char *              strtab,
+		  unsigned long       strtablen,
+		  int                 is_rela,
+		  bool                is_dynsym)
+{
+  unsigned long i;
+  Elf_Internal_Rela * rels;
+  bool res = true;
+
+  if (is_rela == UNKNOWN)
+    is_rela = guess_is_rela (filedata->file_header.e_machine);
+
+  if (is_rela)
+    {
+      if (!slurp_rela_relocs (filedata, rel_offset, rel_size, &rels, &rel_size))
+	return false;
+    }
+  else
+    {
+      if (!slurp_rel_relocs (filedata, rel_offset, rel_size, &rels, &rel_size))
+	return false;
+    }
+
+  if (is_32bit_elf)
+    {
+      if (is_rela)
+	{
+	  if (do_wide)
+	    printf (_(" Offset     Info    Type                Sym. Value  Symbol's Name + Addend\n"));
+	  else
+	    printf (_(" Offset     Info    Type            Sym.Value  Sym. Name + Addend\n"));
+	}
+      else
+	{
+	  if (do_wide)
+	    printf (_(" Offset     Info    Type                Sym. Value  Symbol's Name\n"));
+	  else
+	    printf (_(" Offset     Info    Type            Sym.Value  Sym. Name\n"));
+	}
+    }
+  else
+    {
+      if (is_rela)
+	{
+	  if (do_wide)
+	    printf (_("    Offset             Info             Type               Symbol's Value  Symbol's Name + Addend\n"));
+	  else
+	    printf (_("  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n"));
+	}
+      else
+	{
+	  if (do_wide)
+	    printf (_("    Offset             Info             Type               Symbol's Value  Symbol's Name\n"));
+	  else
+	    printf (_("  Offset          Info           Type           Sym. Value    Sym. Name\n"));
+	}
+    }
+
+  for (i = 0; i < rel_size; i++)
+    {
+      const char * rtype;
+      bfd_vma offset;
+      bfd_vma inf;
+      bfd_vma symtab_index;
+      bfd_vma type;
+
+      offset = rels[i].r_offset;
+      inf    = rels[i].r_info;
+
+      type = get_reloc_type (filedata, inf);
+      symtab_index = get_reloc_symindex  (inf);
+
+      if (is_32bit_elf)
+	{
+	  printf ("%8.8lx  %8.8lx ",
+		  (unsigned long) offset & 0xffffffff,
+		  (unsigned long) inf & 0xffffffff);
+	}
+      else
+	{
+	  printf (do_wide
+		  ? "%16.16" BFD_VMA_FMT "x  %16.16" BFD_VMA_FMT "x "
+		  : "%12.12" BFD_VMA_FMT "x  %12.12" BFD_VMA_FMT "x ",
+		  offset, inf);
+	}
+
+      switch (filedata->file_header.e_machine)
+	{
+	default:
+	  rtype = NULL;
+	  break;
+
+	case EM_AARCH64:
+	  rtype = elf_aarch64_reloc_type (type);
+	  break;
+
+	case EM_M32R:
+	case EM_CYGNUS_M32R:
+	  rtype = elf_m32r_reloc_type (type);
+	  break;
+
+	case EM_386:
+	case EM_IAMCU:
+	  rtype = elf_i386_reloc_type (type);
+	  break;
+
+	case EM_68HC11:
+	case EM_68HC12:
+	  rtype = elf_m68hc11_reloc_type (type);
+	  break;
+
+	case EM_S12Z:
+	  rtype = elf_s12z_reloc_type (type);
+	  break;
+
+	case EM_68K:
+	  rtype = elf_m68k_reloc_type (type);
+	  break;
+
+	case EM_960:
+	  rtype = elf_i960_reloc_type (type);
+	  break;
+
+	case EM_AVR:
+	case EM_AVR_OLD:
+	  rtype = elf_avr_reloc_type (type);
+	  break;
+
+	case EM_OLD_SPARCV9:
+	case EM_SPARC32PLUS:
+	case EM_SPARCV9:
+	case EM_SPARC:
+	  rtype = elf_sparc_reloc_type (type);
+	  break;
+
+	case EM_SPU:
+	  rtype = elf_spu_reloc_type (type);
+	  break;
+
+	case EM_V800:
+	  rtype = v800_reloc_type (type);
+	  break;
+	case EM_V850:
+	case EM_CYGNUS_V850:
+	  rtype = v850_reloc_type (type);
+	  break;
+
+	case EM_D10V:
+	case EM_CYGNUS_D10V:
+	  rtype = elf_d10v_reloc_type (type);
+	  break;
+
+	case EM_D30V:
+	case EM_CYGNUS_D30V:
+	  rtype = elf_d30v_reloc_type (type);
+	  break;
+
+	case EM_DLX:
+	  rtype = elf_dlx_reloc_type (type);
+	  break;
+
+	case EM_SH:
+	  rtype = elf_sh_reloc_type (type);
+	  break;
+
+	case EM_MN10300:
+	case EM_CYGNUS_MN10300:
+	  rtype = elf_mn10300_reloc_type (type);
+	  break;
+
+	case EM_MN10200:
+	case EM_CYGNUS_MN10200:
+	  rtype = elf_mn10200_reloc_type (type);
+	  break;
+
+	case EM_FR30:
+	case EM_CYGNUS_FR30:
+	  rtype = elf_fr30_reloc_type (type);
+	  break;
+
+	case EM_CYGNUS_FRV:
+	  rtype = elf_frv_reloc_type (type);
+	  break;
+
+	case EM_CSKY:
+	  rtype = elf_csky_reloc_type (type);
+	  break;
+
+	case EM_FT32:
+	  rtype = elf_ft32_reloc_type (type);
+	  break;
+
+	case EM_MCORE:
+	  rtype = elf_mcore_reloc_type (type);
+	  break;
+
+	case EM_MMIX:
+	  rtype = elf_mmix_reloc_type (type);
+	  break;
+
+	case EM_MOXIE:
+	  rtype = elf_moxie_reloc_type (type);
+	  break;
+
+	case EM_MSP430:
+	  if (uses_msp430x_relocs (filedata))
+	    {
+	      rtype = elf_msp430x_reloc_type (type);
+	      break;
+	    }
+	  /* Fall through.  */
+	case EM_MSP430_OLD:
+	  rtype = elf_msp430_reloc_type (type);
+	  break;
+
+	case EM_NDS32:
+	  rtype = elf_nds32_reloc_type (type);
+	  break;
+
+	case EM_PPC:
+	  rtype = elf_ppc_reloc_type (type);
+	  break;
+
+	case EM_PPC64:
+	  rtype = elf_ppc64_reloc_type (type);
+	  break;
+
+	case EM_MIPS:
+	case EM_MIPS_RS3_LE:
+	  rtype = elf_mips_reloc_type (type);
+	  break;
+
+	case EM_RISCV:
+	  rtype = elf_riscv_reloc_type (type);
+	  break;
+
+	case EM_ALPHA:
+	  rtype = elf_alpha_reloc_type (type);
+	  break;
+
+	case EM_ARM:
+	  rtype = elf_arm_reloc_type (type);
+	  break;
+
+	case EM_ARC:
+	case EM_ARC_COMPACT:
+	case EM_ARC_COMPACT2:
+	  rtype = elf_arc_reloc_type (type);
+	  break;
+
+	case EM_PARISC:
+	  rtype = elf_hppa_reloc_type (type);
+	  break;
+
+	case EM_H8_300:
+	case EM_H8_300H:
+	case EM_H8S:
+	  rtype = elf_h8_reloc_type (type);
+	  break;
+
+	case EM_OR1K:
+	  rtype = elf_or1k_reloc_type (type);
+	  break;
+
+	case EM_PJ:
+	case EM_PJ_OLD:
+	  rtype = elf_pj_reloc_type (type);
+	  break;
+	case EM_IA_64:
+	  rtype = elf_ia64_reloc_type (type);
+	  break;
+
+	case EM_CRIS:
+	  rtype = elf_cris_reloc_type (type);
+	  break;
+
+	case EM_860:
+	  rtype = elf_i860_reloc_type (type);
+	  break;
+
+	case EM_X86_64:
+	case EM_L1OM:
+	case EM_K1OM:
+	  rtype = elf_x86_64_reloc_type (type);
+	  break;
+
+	case EM_S370:
+	  rtype = i370_reloc_type (type);
+	  break;
+
+	case EM_S390_OLD:
+	case EM_S390:
+	  rtype = elf_s390_reloc_type (type);
+	  break;
+
+	case EM_SCORE:
+	  rtype = elf_score_reloc_type (type);
+	  break;
+
+	case EM_XSTORMY16:
+	  rtype = elf_xstormy16_reloc_type (type);
+	  break;
+
+	case EM_CRX:
+	  rtype = elf_crx_reloc_type (type);
+	  break;
+
+	case EM_VAX:
+	  rtype = elf_vax_reloc_type (type);
+	  break;
+
+	case EM_VISIUM:
+	  rtype = elf_visium_reloc_type (type);
+	  break;
+
+        case EM_BPF:
+          rtype = elf_bpf_reloc_type (type);
+          break;
+
+	case EM_ADAPTEVA_EPIPHANY:
+	  rtype = elf_epiphany_reloc_type (type);
+	  break;
+
+	case EM_IP2K:
+	case EM_IP2K_OLD:
+	  rtype = elf_ip2k_reloc_type (type);
+	  break;
+
+	case EM_IQ2000:
+	  rtype = elf_iq2000_reloc_type (type);
+	  break;
+
+	case EM_XTENSA_OLD:
+	case EM_XTENSA:
+	  rtype = elf_xtensa_reloc_type (type);
+	  break;
+
+	case EM_LATTICEMICO32:
+	  rtype = elf_lm32_reloc_type (type);
+	  break;
+
+	case EM_M32C_OLD:
+	case EM_M32C:
+	  rtype = elf_m32c_reloc_type (type);
+	  break;
+
+	case EM_MT:
+	  rtype = elf_mt_reloc_type (type);
+	  break;
+
+	case EM_BLACKFIN:
+	  rtype = elf_bfin_reloc_type (type);
+	  break;
+
+	case EM_CYGNUS_MEP:
+	  rtype = elf_mep_reloc_type (type);
+	  break;
+
+	case EM_CR16:
+	  rtype = elf_cr16_reloc_type (type);
+	  break;
+
+	case EM_MICROBLAZE:
+	case EM_MICROBLAZE_OLD:
+	  rtype = elf_microblaze_reloc_type (type);
+	  break;
+
+	case EM_RL78:
+	  rtype = elf_rl78_reloc_type (type);
+	  break;
+
+	case EM_RX:
+	  rtype = elf_rx_reloc_type (type);
+	  break;
+
+	case EM_METAG:
+	  rtype = elf_metag_reloc_type (type);
+	  break;
+
+	case EM_XC16X:
+	case EM_C166:
+	  rtype = elf_xc16x_reloc_type (type);
+	  break;
+
+	case EM_TI_C6000:
+	  rtype = elf_tic6x_reloc_type (type);
+	  break;
+
+	case EM_TILEGX:
+	  rtype = elf_tilegx_reloc_type (type);
+	  break;
+
+	case EM_TILEPRO:
+	  rtype = elf_tilepro_reloc_type (type);
+	  break;
+
+	case EM_WEBASSEMBLY:
+	  rtype = elf_wasm32_reloc_type (type);
+	  break;
+
+	case EM_XGATE:
+	  rtype = elf_xgate_reloc_type (type);
+	  break;
+
+	case EM_ALTERA_NIOS2:
+	  rtype = elf_nios2_reloc_type (type);
+	  break;
+
+	case EM_TI_PRU:
+	  rtype = elf_pru_reloc_type (type);
+	  break;
+
+	case EM_NFP:
+	  if (EF_NFP_MACH (filedata->file_header.e_flags) == E_NFP_MACH_3200)
+	    rtype = elf_nfp3200_reloc_type (type);
+	  else
+	    rtype = elf_nfp_reloc_type (type);
+	  break;
+
+	case EM_Z80:
+	  rtype = elf_z80_reloc_type (type);
+	  break;
+	}
+
+      if (rtype == NULL)
+	printf (_("unrecognized: %-7lx"), (unsigned long) type & 0xffffffff);
+      else
+	printf (do_wide ? "%-22s" : "%-17.17s", rtype);
+
+      if (filedata->file_header.e_machine == EM_ALPHA
+	  && rtype != NULL
+	  && streq (rtype, "R_ALPHA_LITUSE")
+	  && is_rela)
+	{
+	  switch (rels[i].r_addend)
+	    {
+	    case LITUSE_ALPHA_ADDR:   rtype = "ADDR";   break;
+	    case LITUSE_ALPHA_BASE:   rtype = "BASE";   break;
+	    case LITUSE_ALPHA_BYTOFF: rtype = "BYTOFF"; break;
+	    case LITUSE_ALPHA_JSR:    rtype = "JSR";    break;
+	    case LITUSE_ALPHA_TLSGD:  rtype = "TLSGD";  break;
+	    case LITUSE_ALPHA_TLSLDM: rtype = "TLSLDM"; break;
+	    case LITUSE_ALPHA_JSRDIRECT: rtype = "JSRDIRECT"; break;
+	    default: rtype = NULL;
+	    }
+
+	  if (rtype)
+	    printf (" (%s)", rtype);
+	  else
+	    {
+	      putchar (' ');
+	      printf (_("<unknown addend: %lx>"),
+		      (unsigned long) rels[i].r_addend);
+	      res = false;
+	    }
+	}
+      else if (symtab_index)
+	{
+	  if (symtab == NULL || symtab_index >= nsyms)
+	    {
+	      error (_(" bad symbol index: %08lx in reloc\n"),
+		     (unsigned long) symtab_index);
+	      res = false;
+	    }
+	  else
+	    {
+	      Elf_Internal_Sym * psym;
+	      const char * version_string;
+	      enum versioned_symbol_info sym_info;
+	      unsigned short vna_other;
+
+	      psym = symtab + symtab_index;
+
+	      version_string
+		= get_symbol_version_string (filedata, is_dynsym,
+					     strtab, strtablen,
+					     symtab_index,
+					     psym,
+					     &sym_info,
+					     &vna_other);
+
+	      printf (" ");
+
+	      if (ELF_ST_TYPE (psym->st_info) == STT_GNU_IFUNC)
+		{
+		  const char * name;
+		  unsigned int len;
+		  unsigned int width = is_32bit_elf ? 8 : 14;
+
+		  /* Relocations against GNU_IFUNC symbols do not use the value
+		     of the symbol as the address to relocate against.  Instead
+		     they invoke the function named by the symbol and use its
+		     result as the address for relocation.
+
+		     To indicate this to the user, do not display the value of
+		     the symbol in the "Symbols's Value" field.  Instead show
+		     its name followed by () as a hint that the symbol is
+		     invoked.  */
+
+		  if (strtab == NULL
+		      || psym->st_name == 0
+		      || psym->st_name >= strtablen)
+		    name = "??";
+		  else
+		    name = strtab + psym->st_name;
+
+		  len = print_symbol (width, name);
+		  if (version_string)
+		    printf (sym_info == symbol_public ? "@@%s" : "@%s",
+			    version_string);
+		  printf ("()%-*s", len <= width ? (width + 1) - len : 1, " ");
+		}
+	      else
+		{
+		  print_vma (psym->st_value, LONG_HEX);
+
+		  printf (is_32bit_elf ? "   " : " ");
+		}
+
+	      if (psym->st_name == 0)
+		{
+		  const char * sec_name = "<null>";
+		  char name_buf[40];
+
+		  if (ELF_ST_TYPE (psym->st_info) == STT_SECTION)
+		    {
+		      if (psym->st_shndx < filedata->file_header.e_shnum)
+			sec_name = SECTION_NAME_PRINT (filedata->section_headers
+						       + psym->st_shndx);
+		      else if (psym->st_shndx == SHN_ABS)
+			sec_name = "ABS";
+		      else if (psym->st_shndx == SHN_COMMON)
+			sec_name = "COMMON";
+		      else if ((filedata->file_header.e_machine == EM_MIPS
+				&& psym->st_shndx == SHN_MIPS_SCOMMON)
+			       || (filedata->file_header.e_machine == EM_TI_C6000
+				   && psym->st_shndx == SHN_TIC6X_SCOMMON))
+			sec_name = "SCOMMON";
+		      else if (filedata->file_header.e_machine == EM_MIPS
+			       && psym->st_shndx == SHN_MIPS_SUNDEFINED)
+			sec_name = "SUNDEF";
+		      else if ((filedata->file_header.e_machine == EM_X86_64
+				|| filedata->file_header.e_machine == EM_L1OM
+				|| filedata->file_header.e_machine == EM_K1OM)
+			       && psym->st_shndx == SHN_X86_64_LCOMMON)
+			sec_name = "LARGE_COMMON";
+		      else if (filedata->file_header.e_machine == EM_IA_64
+			       && filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_HPUX
+			       && psym->st_shndx == SHN_IA_64_ANSI_COMMON)
+			sec_name = "ANSI_COM";
+		      else if (is_ia64_vms (filedata)
+			       && psym->st_shndx == SHN_IA_64_VMS_SYMVEC)
+			sec_name = "VMS_SYMVEC";
+		      else
+			{
+			  sprintf (name_buf, "<section 0x%x>",
+				   (unsigned int) psym->st_shndx);
+			  sec_name = name_buf;
+			}
+		    }
+		  print_symbol (22, sec_name);
+		}
+	      else if (strtab == NULL)
+		printf (_("<string table index: %3ld>"), psym->st_name);
+	      else if (psym->st_name >= strtablen)
+		{
+		  error (_("<corrupt string table index: %3ld>\n"),
+			 psym->st_name);
+		  res = false;
+		}
+	      else
+		{
+		  print_symbol (22, strtab + psym->st_name);
+		  if (version_string)
+		    printf (sym_info == symbol_public ? "@@%s" : "@%s",
+			    version_string);
+		}
+
+	      if (is_rela)
+		{
+		  bfd_vma off = rels[i].r_addend;
+
+		  if ((bfd_signed_vma) off < 0)
+		    printf (" - %" BFD_VMA_FMT "x", - off);
+		  else
+		    printf (" + %" BFD_VMA_FMT "x", off);
+		}
+	    }
+	}
+      else if (is_rela)
+	{
+	  bfd_vma off = rels[i].r_addend;
+
+	  printf ("%*c", is_32bit_elf ? 12 : 20, ' ');
+	  if ((bfd_signed_vma) off < 0)
+	    printf ("-%" BFD_VMA_FMT "x", - off);
+	  else
+	    printf ("%" BFD_VMA_FMT "x", off);
+	}
+
+      if (filedata->file_header.e_machine == EM_SPARCV9
+	  && rtype != NULL
+	  && streq (rtype, "R_SPARC_OLO10"))
+	printf (" + %lx", (unsigned long) ELF64_R_TYPE_DATA (inf));
+
+      putchar ('\n');
+
+#ifdef BFD64
+      if (! is_32bit_elf && filedata->file_header.e_machine == EM_MIPS)
+	{
+	  bfd_vma type2 = ELF64_MIPS_R_TYPE2 (inf);
+	  bfd_vma type3 = ELF64_MIPS_R_TYPE3 (inf);
+	  const char * rtype2 = elf_mips_reloc_type (type2);
+	  const char * rtype3 = elf_mips_reloc_type (type3);
+
+	  printf ("                    Type2: ");
+
+	  if (rtype2 == NULL)
+	    printf (_("unrecognized: %-7lx"),
+		    (unsigned long) type2 & 0xffffffff);
+	  else
+	    printf ("%-17.17s", rtype2);
+
+	  printf ("\n                    Type3: ");
+
+	  if (rtype3 == NULL)
+	    printf (_("unrecognized: %-7lx"),
+		    (unsigned long) type3 & 0xffffffff);
+	  else
+	    printf ("%-17.17s", rtype3);
+
+	  putchar ('\n');
+	}
+#endif /* BFD64 */
+    }
+
+  free (rels);
+
+  return res;
+}
+
+static const char *
+get_aarch64_dynamic_type (unsigned long type)
+{
+  switch (type)
+    {
+    case DT_AARCH64_BTI_PLT:  return "AARCH64_BTI_PLT";
+    case DT_AARCH64_PAC_PLT:  return "AARCH64_PAC_PLT";
+    case DT_AARCH64_VARIANT_PCS:  return "AARCH64_VARIANT_PCS";
+    default:
+      return NULL;
+    }
+}
+
+static const char *
+get_mips_dynamic_type (unsigned long type)
+{
+  switch (type)
+    {
+    case DT_MIPS_RLD_VERSION: return "MIPS_RLD_VERSION";
+    case DT_MIPS_TIME_STAMP: return "MIPS_TIME_STAMP";
+    case DT_MIPS_ICHECKSUM: return "MIPS_ICHECKSUM";
+    case DT_MIPS_IVERSION: return "MIPS_IVERSION";
+    case DT_MIPS_FLAGS: return "MIPS_FLAGS";
+    case DT_MIPS_BASE_ADDRESS: return "MIPS_BASE_ADDRESS";
+    case DT_MIPS_MSYM: return "MIPS_MSYM";
+    case DT_MIPS_CONFLICT: return "MIPS_CONFLICT";
+    case DT_MIPS_LIBLIST: return "MIPS_LIBLIST";
+    case DT_MIPS_LOCAL_GOTNO: return "MIPS_LOCAL_GOTNO";
+    case DT_MIPS_CONFLICTNO: return "MIPS_CONFLICTNO";
+    case DT_MIPS_LIBLISTNO: return "MIPS_LIBLISTNO";
+    case DT_MIPS_SYMTABNO: return "MIPS_SYMTABNO";
+    case DT_MIPS_UNREFEXTNO: return "MIPS_UNREFEXTNO";
+    case DT_MIPS_GOTSYM: return "MIPS_GOTSYM";
+    case DT_MIPS_HIPAGENO: return "MIPS_HIPAGENO";
+    case DT_MIPS_RLD_MAP: return "MIPS_RLD_MAP";
+    case DT_MIPS_RLD_MAP_REL: return "MIPS_RLD_MAP_REL";
+    case DT_MIPS_DELTA_CLASS: return "MIPS_DELTA_CLASS";
+    case DT_MIPS_DELTA_CLASS_NO: return "MIPS_DELTA_CLASS_NO";
+    case DT_MIPS_DELTA_INSTANCE: return "MIPS_DELTA_INSTANCE";
+    case DT_MIPS_DELTA_INSTANCE_NO: return "MIPS_DELTA_INSTANCE_NO";
+    case DT_MIPS_DELTA_RELOC: return "MIPS_DELTA_RELOC";
+    case DT_MIPS_DELTA_RELOC_NO: return "MIPS_DELTA_RELOC_NO";
+    case DT_MIPS_DELTA_SYM: return "MIPS_DELTA_SYM";
+    case DT_MIPS_DELTA_SYM_NO: return "MIPS_DELTA_SYM_NO";
+    case DT_MIPS_DELTA_CLASSSYM: return "MIPS_DELTA_CLASSSYM";
+    case DT_MIPS_DELTA_CLASSSYM_NO: return "MIPS_DELTA_CLASSSYM_NO";
+    case DT_MIPS_CXX_FLAGS: return "MIPS_CXX_FLAGS";
+    case DT_MIPS_PIXIE_INIT: return "MIPS_PIXIE_INIT";
+    case DT_MIPS_SYMBOL_LIB: return "MIPS_SYMBOL_LIB";
+    case DT_MIPS_LOCALPAGE_GOTIDX: return "MIPS_LOCALPAGE_GOTIDX";
+    case DT_MIPS_LOCAL_GOTIDX: return "MIPS_LOCAL_GOTIDX";
+    case DT_MIPS_HIDDEN_GOTIDX: return "MIPS_HIDDEN_GOTIDX";
+    case DT_MIPS_PROTECTED_GOTIDX: return "MIPS_PROTECTED_GOTIDX";
+    case DT_MIPS_OPTIONS: return "MIPS_OPTIONS";
+    case DT_MIPS_INTERFACE: return "MIPS_INTERFACE";
+    case DT_MIPS_DYNSTR_ALIGN: return "MIPS_DYNSTR_ALIGN";
+    case DT_MIPS_INTERFACE_SIZE: return "MIPS_INTERFACE_SIZE";
+    case DT_MIPS_RLD_TEXT_RESOLVE_ADDR: return "MIPS_RLD_TEXT_RESOLVE_ADDR";
+    case DT_MIPS_PERF_SUFFIX: return "MIPS_PERF_SUFFIX";
+    case DT_MIPS_COMPACT_SIZE: return "MIPS_COMPACT_SIZE";
+    case DT_MIPS_GP_VALUE: return "MIPS_GP_VALUE";
+    case DT_MIPS_AUX_DYNAMIC: return "MIPS_AUX_DYNAMIC";
+    case DT_MIPS_PLTGOT: return "MIPS_PLTGOT";
+    case DT_MIPS_RWPLT: return "MIPS_RWPLT";
+    case DT_MIPS_XHASH: return "MIPS_XHASH";
+    default:
+      return NULL;
+    }
+}
+
+static const char *
+get_sparc64_dynamic_type (unsigned long type)
+{
+  switch (type)
+    {
+    case DT_SPARC_REGISTER: return "SPARC_REGISTER";
+    default:
+      return NULL;
+    }
+}
+
+static const char *
+get_ppc_dynamic_type (unsigned long type)
+{
+  switch (type)
+    {
+    case DT_PPC_GOT:    return "PPC_GOT";
+    case DT_PPC_OPT:    return "PPC_OPT";
+    default:
+      return NULL;
+    }
+}
+
+static const char *
+get_ppc64_dynamic_type (unsigned long type)
+{
+  switch (type)
+    {
+    case DT_PPC64_GLINK:  return "PPC64_GLINK";
+    case DT_PPC64_OPD:    return "PPC64_OPD";
+    case DT_PPC64_OPDSZ:  return "PPC64_OPDSZ";
+    case DT_PPC64_OPT:    return "PPC64_OPT";
+    default:
+      return NULL;
+    }
+}
+
+static const char *
+get_parisc_dynamic_type (unsigned long type)
+{
+  switch (type)
+    {
+    case DT_HP_LOAD_MAP:	return "HP_LOAD_MAP";
+    case DT_HP_DLD_FLAGS:	return "HP_DLD_FLAGS";
+    case DT_HP_DLD_HOOK:	return "HP_DLD_HOOK";
+    case DT_HP_UX10_INIT:	return "HP_UX10_INIT";
+    case DT_HP_UX10_INITSZ:	return "HP_UX10_INITSZ";
+    case DT_HP_PREINIT:		return "HP_PREINIT";
+    case DT_HP_PREINITSZ:	return "HP_PREINITSZ";
+    case DT_HP_NEEDED:		return "HP_NEEDED";
+    case DT_HP_TIME_STAMP:	return "HP_TIME_STAMP";
+    case DT_HP_CHECKSUM:	return "HP_CHECKSUM";
+    case DT_HP_GST_SIZE:	return "HP_GST_SIZE";
+    case DT_HP_GST_VERSION:	return "HP_GST_VERSION";
+    case DT_HP_GST_HASHVAL:	return "HP_GST_HASHVAL";
+    case DT_HP_EPLTREL:		return "HP_GST_EPLTREL";
+    case DT_HP_EPLTRELSZ:	return "HP_GST_EPLTRELSZ";
+    case DT_HP_FILTERED:	return "HP_FILTERED";
+    case DT_HP_FILTER_TLS:	return "HP_FILTER_TLS";
+    case DT_HP_COMPAT_FILTERED:	return "HP_COMPAT_FILTERED";
+    case DT_HP_LAZYLOAD:	return "HP_LAZYLOAD";
+    case DT_HP_BIND_NOW_COUNT:	return "HP_BIND_NOW_COUNT";
+    case DT_PLT:		return "PLT";
+    case DT_PLT_SIZE:		return "PLT_SIZE";
+    case DT_DLT:		return "DLT";
+    case DT_DLT_SIZE:		return "DLT_SIZE";
+    default:
+      return NULL;
+    }
+}
+
+static const char *
+get_ia64_dynamic_type (unsigned long type)
+{
+  switch (type)
+    {
+    case DT_IA_64_PLT_RESERVE:         return "IA_64_PLT_RESERVE";
+    case DT_IA_64_VMS_SUBTYPE:         return "VMS_SUBTYPE";
+    case DT_IA_64_VMS_IMGIOCNT:        return "VMS_IMGIOCNT";
+    case DT_IA_64_VMS_LNKFLAGS:        return "VMS_LNKFLAGS";
+    case DT_IA_64_VMS_VIR_MEM_BLK_SIZ: return "VMS_VIR_MEM_BLK_SIZ";
+    case DT_IA_64_VMS_IDENT:           return "VMS_IDENT";
+    case DT_IA_64_VMS_NEEDED_IDENT:    return "VMS_NEEDED_IDENT";
+    case DT_IA_64_VMS_IMG_RELA_CNT:    return "VMS_IMG_RELA_CNT";
+    case DT_IA_64_VMS_SEG_RELA_CNT:    return "VMS_SEG_RELA_CNT";
+    case DT_IA_64_VMS_FIXUP_RELA_CNT:  return "VMS_FIXUP_RELA_CNT";
+    case DT_IA_64_VMS_FIXUP_NEEDED:    return "VMS_FIXUP_NEEDED";
+    case DT_IA_64_VMS_SYMVEC_CNT:      return "VMS_SYMVEC_CNT";
+    case DT_IA_64_VMS_XLATED:          return "VMS_XLATED";
+    case DT_IA_64_VMS_STACKSIZE:       return "VMS_STACKSIZE";
+    case DT_IA_64_VMS_UNWINDSZ:        return "VMS_UNWINDSZ";
+    case DT_IA_64_VMS_UNWIND_CODSEG:   return "VMS_UNWIND_CODSEG";
+    case DT_IA_64_VMS_UNWIND_INFOSEG:  return "VMS_UNWIND_INFOSEG";
+    case DT_IA_64_VMS_LINKTIME:        return "VMS_LINKTIME";
+    case DT_IA_64_VMS_SEG_NO:          return "VMS_SEG_NO";
+    case DT_IA_64_VMS_SYMVEC_OFFSET:   return "VMS_SYMVEC_OFFSET";
+    case DT_IA_64_VMS_SYMVEC_SEG:      return "VMS_SYMVEC_SEG";
+    case DT_IA_64_VMS_UNWIND_OFFSET:   return "VMS_UNWIND_OFFSET";
+    case DT_IA_64_VMS_UNWIND_SEG:      return "VMS_UNWIND_SEG";
+    case DT_IA_64_VMS_STRTAB_OFFSET:   return "VMS_STRTAB_OFFSET";
+    case DT_IA_64_VMS_SYSVER_OFFSET:   return "VMS_SYSVER_OFFSET";
+    case DT_IA_64_VMS_IMG_RELA_OFF:    return "VMS_IMG_RELA_OFF";
+    case DT_IA_64_VMS_SEG_RELA_OFF:    return "VMS_SEG_RELA_OFF";
+    case DT_IA_64_VMS_FIXUP_RELA_OFF:  return "VMS_FIXUP_RELA_OFF";
+    case DT_IA_64_VMS_PLTGOT_OFFSET:   return "VMS_PLTGOT_OFFSET";
+    case DT_IA_64_VMS_PLTGOT_SEG:      return "VMS_PLTGOT_SEG";
+    case DT_IA_64_VMS_FPMODE:          return "VMS_FPMODE";
+    default:
+      return NULL;
+    }
+}
+
+static const char *
+get_solaris_section_type (unsigned long type)
+{
+  switch (type)
+    {
+    case 0x6fffffee: return "SUNW_ancillary";
+    case 0x6fffffef: return "SUNW_capchain";
+    case 0x6ffffff0: return "SUNW_capinfo";
+    case 0x6ffffff1: return "SUNW_symsort";
+    case 0x6ffffff2: return "SUNW_tlssort";
+    case 0x6ffffff3: return "SUNW_LDYNSYM";
+    case 0x6ffffff4: return "SUNW_dof";
+    case 0x6ffffff5: return "SUNW_cap";
+    case 0x6ffffff6: return "SUNW_SIGNATURE";
+    case 0x6ffffff7: return "SUNW_ANNOTATE";
+    case 0x6ffffff8: return "SUNW_DEBUGSTR";
+    case 0x6ffffff9: return "SUNW_DEBUG";
+    case 0x6ffffffa: return "SUNW_move";
+    case 0x6ffffffb: return "SUNW_COMDAT";
+    case 0x6ffffffc: return "SUNW_syminfo";
+    case 0x6ffffffd: return "SUNW_verdef";
+    case 0x6ffffffe: return "SUNW_verneed";
+    case 0x6fffffff: return "SUNW_versym";
+    case 0x70000000: return "SPARC_GOTDATA";
+    default: return NULL;
+    }
+}
+
+static const char *
+get_alpha_dynamic_type (unsigned long type)
+{
+  switch (type)
+    {
+    case DT_ALPHA_PLTRO: return "ALPHA_PLTRO";
+    default: return NULL;
+    }
+}
+
+static const char *
+get_score_dynamic_type (unsigned long type)
+{
+  switch (type)
+    {
+    case DT_SCORE_BASE_ADDRESS: return "SCORE_BASE_ADDRESS";
+    case DT_SCORE_LOCAL_GOTNO:  return "SCORE_LOCAL_GOTNO";
+    case DT_SCORE_SYMTABNO:     return "SCORE_SYMTABNO";
+    case DT_SCORE_GOTSYM:       return "SCORE_GOTSYM";
+    case DT_SCORE_UNREFEXTNO:   return "SCORE_UNREFEXTNO";
+    case DT_SCORE_HIPAGENO:     return "SCORE_HIPAGENO";
+    default:                    return NULL;
+    }
+}
+
+static const char *
+get_tic6x_dynamic_type (unsigned long type)
+{
+  switch (type)
+    {
+    case DT_C6000_GSYM_OFFSET: return "C6000_GSYM_OFFSET";
+    case DT_C6000_GSTR_OFFSET: return "C6000_GSTR_OFFSET";
+    case DT_C6000_DSBT_BASE:   return "C6000_DSBT_BASE";
+    case DT_C6000_DSBT_SIZE:   return "C6000_DSBT_SIZE";
+    case DT_C6000_PREEMPTMAP:  return "C6000_PREEMPTMAP";
+    case DT_C6000_DSBT_INDEX:  return "C6000_DSBT_INDEX";
+    default:                   return NULL;
+    }
+}
+
+static const char *
+get_nios2_dynamic_type (unsigned long type)
+{
+  switch (type)
+    {
+    case DT_NIOS2_GP: return "NIOS2_GP";
+    default:          return NULL;
+    }
+}
+
+static const char *
+get_solaris_dynamic_type (unsigned long type)
+{
+  switch (type)
+    {
+    case 0x6000000d: return "SUNW_AUXILIARY";
+    case 0x6000000e: return "SUNW_RTLDINF";
+    case 0x6000000f: return "SUNW_FILTER";
+    case 0x60000010: return "SUNW_CAP";
+    case 0x60000011: return "SUNW_SYMTAB";
+    case 0x60000012: return "SUNW_SYMSZ";
+    case 0x60000013: return "SUNW_SORTENT";
+    case 0x60000014: return "SUNW_SYMSORT";
+    case 0x60000015: return "SUNW_SYMSORTSZ";
+    case 0x60000016: return "SUNW_TLSSORT";
+    case 0x60000017: return "SUNW_TLSSORTSZ";
+    case 0x60000018: return "SUNW_CAPINFO";
+    case 0x60000019: return "SUNW_STRPAD";
+    case 0x6000001a: return "SUNW_CAPCHAIN";
+    case 0x6000001b: return "SUNW_LDMACH";
+    case 0x6000001d: return "SUNW_CAPCHAINENT";
+    case 0x6000001f: return "SUNW_CAPCHAINSZ";
+    case 0x60000021: return "SUNW_PARENT";
+    case 0x60000023: return "SUNW_ASLR";
+    case 0x60000025: return "SUNW_RELAX";
+    case 0x60000029: return "SUNW_NXHEAP";
+    case 0x6000002b: return "SUNW_NXSTACK";
+
+    case 0x70000001: return "SPARC_REGISTER";
+    case 0x7ffffffd: return "AUXILIARY";
+    case 0x7ffffffe: return "USED";
+    case 0x7fffffff: return "FILTER";
+
+    default: return NULL;
+    }
+}
+
+static const char *
+get_dynamic_type (Filedata * filedata, unsigned long type)
+{
+  static char buff[64];
+
+  switch (type)
+    {
+    case DT_NULL:	return "NULL";
+    case DT_NEEDED:	return "NEEDED";
+    case DT_PLTRELSZ:	return "PLTRELSZ";
+    case DT_PLTGOT:	return "PLTGOT";
+    case DT_HASH:	return "HASH";
+    case DT_STRTAB:	return "STRTAB";
+    case DT_SYMTAB:	return "SYMTAB";
+    case DT_RELA:	return "RELA";
+    case DT_RELASZ:	return "RELASZ";
+    case DT_RELAENT:	return "RELAENT";
+    case DT_STRSZ:	return "STRSZ";
+    case DT_SYMENT:	return "SYMENT";
+    case DT_INIT:	return "INIT";
+    case DT_FINI:	return "FINI";
+    case DT_SONAME:	return "SONAME";
+    case DT_RPATH:	return "RPATH";
+    case DT_SYMBOLIC:	return "SYMBOLIC";
+    case DT_REL:	return "REL";
+    case DT_RELSZ:	return "RELSZ";
+    case DT_RELENT:	return "RELENT";
+    case DT_PLTREL:	return "PLTREL";
+    case DT_DEBUG:	return "DEBUG";
+    case DT_TEXTREL:	return "TEXTREL";
+    case DT_JMPREL:	return "JMPREL";
+    case DT_BIND_NOW:   return "BIND_NOW";
+    case DT_INIT_ARRAY: return "INIT_ARRAY";
+    case DT_FINI_ARRAY: return "FINI_ARRAY";
+    case DT_INIT_ARRAYSZ: return "INIT_ARRAYSZ";
+    case DT_FINI_ARRAYSZ: return "FINI_ARRAYSZ";
+    case DT_RUNPATH:    return "RUNPATH";
+    case DT_FLAGS:      return "FLAGS";
+
+    case DT_PREINIT_ARRAY: return "PREINIT_ARRAY";
+    case DT_PREINIT_ARRAYSZ: return "PREINIT_ARRAYSZ";
+    case DT_SYMTAB_SHNDX: return "SYMTAB_SHNDX";
+
+    case DT_CHECKSUM:	return "CHECKSUM";
+    case DT_PLTPADSZ:	return "PLTPADSZ";
+    case DT_MOVEENT:	return "MOVEENT";
+    case DT_MOVESZ:	return "MOVESZ";
+    case DT_FEATURE:	return "FEATURE";
+    case DT_POSFLAG_1:	return "POSFLAG_1";
+    case DT_SYMINSZ:	return "SYMINSZ";
+    case DT_SYMINENT:	return "SYMINENT"; /* aka VALRNGHI */
+
+    case DT_ADDRRNGLO:  return "ADDRRNGLO";
+    case DT_CONFIG:	return "CONFIG";
+    case DT_DEPAUDIT:	return "DEPAUDIT";
+    case DT_AUDIT:	return "AUDIT";
+    case DT_PLTPAD:	return "PLTPAD";
+    case DT_MOVETAB:	return "MOVETAB";
+    case DT_SYMINFO:	return "SYMINFO"; /* aka ADDRRNGHI */
+
+    case DT_VERSYM:	return "VERSYM";
+
+    case DT_TLSDESC_GOT: return "TLSDESC_GOT";
+    case DT_TLSDESC_PLT: return "TLSDESC_PLT";
+    case DT_RELACOUNT:	return "RELACOUNT";
+    case DT_RELCOUNT:	return "RELCOUNT";
+    case DT_FLAGS_1:	return "FLAGS_1";
+    case DT_VERDEF:	return "VERDEF";
+    case DT_VERDEFNUM:	return "VERDEFNUM";
+    case DT_VERNEED:	return "VERNEED";
+    case DT_VERNEEDNUM:	return "VERNEEDNUM";
+
+    case DT_AUXILIARY:	return "AUXILIARY";
+    case DT_USED:	return "USED";
+    case DT_FILTER:	return "FILTER";
+
+    case DT_GNU_PRELINKED: return "GNU_PRELINKED";
+    case DT_GNU_CONFLICT: return "GNU_CONFLICT";
+    case DT_GNU_CONFLICTSZ: return "GNU_CONFLICTSZ";
+    case DT_GNU_LIBLIST: return "GNU_LIBLIST";
+    case DT_GNU_LIBLISTSZ: return "GNU_LIBLISTSZ";
+    case DT_GNU_HASH:	return "GNU_HASH";
+    case DT_GNU_FLAGS_1: return "GNU_FLAGS_1";
+
+    default:
+      if ((type >= DT_LOPROC) && (type <= DT_HIPROC))
+	{
+	  const char * result;
+
+	  switch (filedata->file_header.e_machine)
+	    {
+	    case EM_AARCH64:
+	      result = get_aarch64_dynamic_type (type);
+	      break;
+	    case EM_MIPS:
+	    case EM_MIPS_RS3_LE:
+	      result = get_mips_dynamic_type (type);
+	      break;
+	    case EM_SPARCV9:
+	      result = get_sparc64_dynamic_type (type);
+	      break;
+	    case EM_PPC:
+	      result = get_ppc_dynamic_type (type);
+	      break;
+	    case EM_PPC64:
+	      result = get_ppc64_dynamic_type (type);
+	      break;
+	    case EM_IA_64:
+	      result = get_ia64_dynamic_type (type);
+	      break;
+	    case EM_ALPHA:
+	      result = get_alpha_dynamic_type (type);
+	      break;
+	    case EM_SCORE:
+	      result = get_score_dynamic_type (type);
+	      break;
+	    case EM_TI_C6000:
+	      result = get_tic6x_dynamic_type (type);
+	      break;
+	    case EM_ALTERA_NIOS2:
+	      result = get_nios2_dynamic_type (type);
+	      break;
+	    default:
+	      if (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_SOLARIS)
+		result = get_solaris_dynamic_type (type);
+	      else
+		result = NULL;
+	      break;
+	    }
+
+	  if (result != NULL)
+	    return result;
+
+	  snprintf (buff, sizeof (buff), _("Processor Specific: %lx"), type);
+	}
+      else if (((type >= DT_LOOS) && (type <= DT_HIOS))
+	       || (filedata->file_header.e_machine == EM_PARISC
+		   && (type >= OLD_DT_LOOS) && (type <= OLD_DT_HIOS)))
+	{
+	  const char * result;
+
+	  switch (filedata->file_header.e_machine)
+	    {
+	    case EM_PARISC:
+	      result = get_parisc_dynamic_type (type);
+	      break;
+	    case EM_IA_64:
+	      result = get_ia64_dynamic_type (type);
+	      break;
+	    default:
+	      if (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_SOLARIS)
+		result = get_solaris_dynamic_type (type);
+	      else
+		result = NULL;
+	      break;
+	    }
+
+	  if (result != NULL)
+	    return result;
+
+	  snprintf (buff, sizeof (buff), _("Operating System specific: %lx"),
+		    type);
+	}
+      else
+	snprintf (buff, sizeof (buff), _("<unknown>: %lx"), type);
+
+      return buff;
+    }
+}
+
+static bool get_program_headers (Filedata *);
+static bool get_dynamic_section (Filedata *);
+
+static void
+locate_dynamic_section (Filedata *filedata)
+{
+  unsigned long dynamic_addr = 0;
+  bfd_size_type dynamic_size = 0;
+
+  if (filedata->file_header.e_phnum != 0
+      && get_program_headers (filedata))
+    {
+      Elf_Internal_Phdr *segment;
+      unsigned int i;
+
+      for (i = 0, segment = filedata->program_headers;
+	   i < filedata->file_header.e_phnum;
+	   i++, segment++)
+	{
+	  if (segment->p_type == PT_DYNAMIC)
+	    {
+	      dynamic_addr = segment->p_offset;
+	      dynamic_size = segment->p_filesz;
+
+	      if (filedata->section_headers != NULL)
+		{
+		  Elf_Internal_Shdr *sec;
+
+		  sec = find_section (filedata, ".dynamic");
+		  if (sec != NULL)
+		    {
+		      if (sec->sh_size == 0
+			  || sec->sh_type == SHT_NOBITS)
+			{
+			  dynamic_addr = 0;
+			  dynamic_size = 0;
+			}
+		      else
+			{
+			  dynamic_addr = sec->sh_offset;
+			  dynamic_size = sec->sh_size;
+			}
+		    }
+		}
+
+	      if (dynamic_addr > filedata->file_size
+		  || (dynamic_size > filedata->file_size - dynamic_addr))
+		{
+		  dynamic_addr = 0;
+		  dynamic_size = 0;
+		}
+	      break;
+	    }
+	}
+    }
+  filedata->dynamic_addr = dynamic_addr;
+  filedata->dynamic_size = dynamic_size ? dynamic_size : 1;
+}
+
+static bool
+is_pie (Filedata *filedata)
+{
+  Elf_Internal_Dyn *entry;
+
+  if (filedata->dynamic_size == 0)
+    locate_dynamic_section (filedata);
+  if (filedata->dynamic_size <= 1)
+    return false;
+
+  if (!get_dynamic_section (filedata))
+    return false;
+
+  for (entry = filedata->dynamic_section;
+       entry < filedata->dynamic_section + filedata->dynamic_nent;
+       entry++)
+    {
+      if (entry->d_tag == DT_FLAGS_1)
+	{
+	  if ((entry->d_un.d_val & DF_1_PIE) != 0)
+	    return true;
+	  break;
+	}
+    }
+  return false;
+}
+
+static char *
+get_file_type (Filedata *filedata)
+{
+  unsigned e_type = filedata->file_header.e_type;
+  static char buff[64];
+
+  switch (e_type)
+    {
+    case ET_NONE: return _("NONE (None)");
+    case ET_REL:  return _("REL (Relocatable file)");
+    case ET_EXEC: return _("EXEC (Executable file)");
+    case ET_DYN:
+      if (is_pie (filedata))
+	return _("DYN (Position-Independent Executable file)");
+      else
+	return _("DYN (Shared object file)");
+    case ET_CORE: return _("CORE (Core file)");
+
+    default:
+      if ((e_type >= ET_LOPROC) && (e_type <= ET_HIPROC))
+	snprintf (buff, sizeof (buff), _("Processor Specific: (%x)"), e_type);
+      else if ((e_type >= ET_LOOS) && (e_type <= ET_HIOS))
+	snprintf (buff, sizeof (buff), _("OS Specific: (%x)"), e_type);
+      else
+	snprintf (buff, sizeof (buff), _("<unknown>: %x"), e_type);
+      return buff;
+    }
+}
+
+static char *
+get_machine_name (unsigned e_machine)
+{
+  static char buff[64]; /* XXX */
+
+  switch (e_machine)
+    {
+      /* Please keep this switch table sorted by increasing EM_ value.  */
+      /* 0 */
+    case EM_NONE:		return _("None");
+    case EM_M32:		return "WE32100";
+    case EM_SPARC:		return "Sparc";
+    case EM_386:		return "Intel 80386";
+    case EM_68K:		return "MC68000";
+    case EM_88K:		return "MC88000";
+    case EM_IAMCU:		return "Intel MCU";
+    case EM_860:		return "Intel 80860";
+    case EM_MIPS:		return "MIPS R3000";
+    case EM_S370:		return "IBM System/370";
+      /* 10 */
+    case EM_MIPS_RS3_LE:	return "MIPS R4000 big-endian";
+    case EM_OLD_SPARCV9:	return "Sparc v9 (old)";
+    case EM_PARISC:		return "HPPA";
+    case EM_VPP550:		return "Fujitsu VPP500";
+    case EM_SPARC32PLUS:	return "Sparc v8+" ;
+    case EM_960:		return "Intel 80960";
+    case EM_PPC:		return "PowerPC";
+      /* 20 */
+    case EM_PPC64:		return "PowerPC64";
+    case EM_S390_OLD:
+    case EM_S390:		return "IBM S/390";
+    case EM_SPU:		return "SPU";
+      /* 30 */
+    case EM_V800:		return "Renesas V850 (using RH850 ABI)";
+    case EM_FR20:		return "Fujitsu FR20";
+    case EM_RH32:		return "TRW RH32";
+    case EM_MCORE:		return "MCORE";
+      /* 40 */
+    case EM_ARM:		return "ARM";
+    case EM_OLD_ALPHA:		return "Digital Alpha (old)";
+    case EM_SH:			return "Renesas / SuperH SH";
+    case EM_SPARCV9:		return "Sparc v9";
+    case EM_TRICORE:		return "Siemens Tricore";
+    case EM_ARC:		return "ARC";
+    case EM_H8_300:		return "Renesas H8/300";
+    case EM_H8_300H:		return "Renesas H8/300H";
+    case EM_H8S:		return "Renesas H8S";
+    case EM_H8_500:		return "Renesas H8/500";
+      /* 50 */
+    case EM_IA_64:		return "Intel IA-64";
+    case EM_MIPS_X:		return "Stanford MIPS-X";
+    case EM_COLDFIRE:		return "Motorola Coldfire";
+    case EM_68HC12:		return "Motorola MC68HC12 Microcontroller";
+    case EM_MMA:		return "Fujitsu Multimedia Accelerator";
+    case EM_PCP:		return "Siemens PCP";
+    case EM_NCPU:		return "Sony nCPU embedded RISC processor";
+    case EM_NDR1:		return "Denso NDR1 microprocesspr";
+    case EM_STARCORE:		return "Motorola Star*Core processor";
+    case EM_ME16:		return "Toyota ME16 processor";
+      /* 60 */
+    case EM_ST100:		return "STMicroelectronics ST100 processor";
+    case EM_TINYJ:		return "Advanced Logic Corp. TinyJ embedded processor";
+    case EM_X86_64:		return "Advanced Micro Devices X86-64";
+    case EM_PDSP:		return "Sony DSP processor";
+    case EM_PDP10:		return "Digital Equipment Corp. PDP-10";
+    case EM_PDP11:		return "Digital Equipment Corp. PDP-11";
+    case EM_FX66:		return "Siemens FX66 microcontroller";
+    case EM_ST9PLUS:		return "STMicroelectronics ST9+ 8/16 bit microcontroller";
+    case EM_ST7:		return "STMicroelectronics ST7 8-bit microcontroller";
+    case EM_68HC16:		return "Motorola MC68HC16 Microcontroller";
+      /* 70 */
+    case EM_68HC11:		return "Motorola MC68HC11 Microcontroller";
+    case EM_68HC08:		return "Motorola MC68HC08 Microcontroller";
+    case EM_68HC05:		return "Motorola MC68HC05 Microcontroller";
+    case EM_SVX:		return "Silicon Graphics SVx";
+    case EM_ST19:		return "STMicroelectronics ST19 8-bit microcontroller";
+    case EM_VAX:		return "Digital VAX";
+    case EM_CRIS:		return "Axis Communications 32-bit embedded processor";
+    case EM_JAVELIN:		return "Infineon Technologies 32-bit embedded cpu";
+    case EM_FIREPATH:		return "Element 14 64-bit DSP processor";
+    case EM_ZSP:		return "LSI Logic's 16-bit DSP processor";
+      /* 80 */
+    case EM_MMIX:		return "Donald Knuth's educational 64-bit processor";
+    case EM_HUANY:		return "Harvard Universitys's machine-independent object format";
+    case EM_PRISM:		return "Vitesse Prism";
+    case EM_AVR_OLD:
+    case EM_AVR:		return "Atmel AVR 8-bit microcontroller";
+    case EM_CYGNUS_FR30:
+    case EM_FR30:		return "Fujitsu FR30";
+    case EM_CYGNUS_D10V:
+    case EM_D10V:		return "d10v";
+    case EM_CYGNUS_D30V:
+    case EM_D30V:		return "d30v";
+    case EM_CYGNUS_V850:
+    case EM_V850:		return "Renesas V850";
+    case EM_CYGNUS_M32R:
+    case EM_M32R:		return "Renesas M32R (formerly Mitsubishi M32r)";
+    case EM_CYGNUS_MN10300:
+    case EM_MN10300:		return "mn10300";
+      /* 90 */
+    case EM_CYGNUS_MN10200:
+    case EM_MN10200:		return "mn10200";
+    case EM_PJ:			return "picoJava";
+    case EM_OR1K:		return "OpenRISC 1000";
+    case EM_ARC_COMPACT:	return "ARCompact";
+    case EM_XTENSA_OLD:
+    case EM_XTENSA:		return "Tensilica Xtensa Processor";
+    case EM_VIDEOCORE:		return "Alphamosaic VideoCore processor";
+    case EM_TMM_GPP:		return "Thompson Multimedia General Purpose Processor";
+    case EM_NS32K:		return "National Semiconductor 32000 series";
+    case EM_TPC:		return "Tenor Network TPC processor";
+    case EM_SNP1K:	        return "Trebia SNP 1000 processor";
+      /* 100 */
+    case EM_ST200:		return "STMicroelectronics ST200 microcontroller";
+    case EM_IP2K_OLD:
+    case EM_IP2K:		return "Ubicom IP2xxx 8-bit microcontrollers";
+    case EM_MAX:		return "MAX Processor";
+    case EM_CR:			return "National Semiconductor CompactRISC";
+    case EM_F2MC16:		return "Fujitsu F2MC16";
+    case EM_MSP430:		return "Texas Instruments msp430 microcontroller";
+    case EM_BLACKFIN:		return "Analog Devices Blackfin";
+    case EM_SE_C33:		return "S1C33 Family of Seiko Epson processors";
+    case EM_SEP:		return "Sharp embedded microprocessor";
+    case EM_ARCA:		return "Arca RISC microprocessor";
+      /* 110 */
+    case EM_UNICORE:		return "Unicore";
+    case EM_EXCESS:		return "eXcess 16/32/64-bit configurable embedded CPU";
+    case EM_DXP:		return "Icera Semiconductor Inc. Deep Execution Processor";
+    case EM_ALTERA_NIOS2:	return "Altera Nios II";
+    case EM_CRX:		return "National Semiconductor CRX microprocessor";
+    case EM_XGATE:		return "Motorola XGATE embedded processor";
+    case EM_C166:
+    case EM_XC16X:		return "Infineon Technologies xc16x";
+    case EM_M16C:		return "Renesas M16C series microprocessors";
+    case EM_DSPIC30F:		return "Microchip Technology dsPIC30F Digital Signal Controller";
+    case EM_CE:			return "Freescale Communication Engine RISC core";
+      /* 120 */
+    case EM_M32C:	        return "Renesas M32c";
+      /* 130 */
+    case EM_TSK3000:		return "Altium TSK3000 core";
+    case EM_RS08:		return "Freescale RS08 embedded processor";
+    case EM_ECOG2:		return "Cyan Technology eCOG2 microprocessor";
+    case EM_SCORE:		return "SUNPLUS S+Core";
+    case EM_DSP24:		return "New Japan Radio (NJR) 24-bit DSP Processor";
+    case EM_VIDEOCORE3:		return "Broadcom VideoCore III processor";
+    case EM_LATTICEMICO32:	return "Lattice Mico32";
+    case EM_SE_C17:		return "Seiko Epson C17 family";
+      /* 140 */
+    case EM_TI_C6000:		return "Texas Instruments TMS320C6000 DSP family";
+    case EM_TI_C2000:		return "Texas Instruments TMS320C2000 DSP family";
+    case EM_TI_C5500:		return "Texas Instruments TMS320C55x DSP family";
+    case EM_TI_PRU:		return "TI PRU I/O processor";
+      /* 160 */
+    case EM_MMDSP_PLUS:		return "STMicroelectronics 64bit VLIW Data Signal Processor";
+    case EM_CYPRESS_M8C:	return "Cypress M8C microprocessor";
+    case EM_R32C:		return "Renesas R32C series microprocessors";
+    case EM_TRIMEDIA:		return "NXP Semiconductors TriMedia architecture family";
+    case EM_QDSP6:		return "QUALCOMM DSP6 Processor";
+    case EM_8051:		return "Intel 8051 and variants";
+    case EM_STXP7X:		return "STMicroelectronics STxP7x family";
+    case EM_NDS32:		return "Andes Technology compact code size embedded RISC processor family";
+    case EM_ECOG1X:		return "Cyan Technology eCOG1X family";
+    case EM_MAXQ30:		return "Dallas Semiconductor MAXQ30 Core microcontrollers";
+      /* 170 */
+    case EM_XIMO16:		return "New Japan Radio (NJR) 16-bit DSP Processor";
+    case EM_MANIK:		return "M2000 Reconfigurable RISC Microprocessor";
+    case EM_CRAYNV2:		return "Cray Inc. NV2 vector architecture";
+    case EM_RX:			return "Renesas RX";
+    case EM_METAG:		return "Imagination Technologies Meta processor architecture";
+    case EM_MCST_ELBRUS:	return "MCST Elbrus general purpose hardware architecture";
+    case EM_ECOG16:		return "Cyan Technology eCOG16 family";
+    case EM_CR16:
+    case EM_MICROBLAZE:
+    case EM_MICROBLAZE_OLD:	return "Xilinx MicroBlaze";
+    case EM_ETPU:		return "Freescale Extended Time Processing Unit";
+    case EM_SLE9X:		return "Infineon Technologies SLE9X core";
+      /* 180 */
+    case EM_L1OM:		return "Intel L1OM";
+    case EM_K1OM:		return "Intel K1OM";
+    case EM_INTEL182:		return "Intel (reserved)";
+    case EM_AARCH64:		return "AArch64";
+    case EM_ARM184:		return "ARM (reserved)";
+    case EM_AVR32:		return "Atmel Corporation 32-bit microprocessor";
+    case EM_STM8:		return "STMicroeletronics STM8 8-bit microcontroller";
+    case EM_TILE64:		return "Tilera TILE64 multicore architecture family";
+    case EM_TILEPRO:		return "Tilera TILEPro multicore architecture family";
+      /* 190 */
+    case EM_CUDA:		return "NVIDIA CUDA architecture";
+    case EM_TILEGX:		return "Tilera TILE-Gx multicore architecture family";
+    case EM_CLOUDSHIELD:	return "CloudShield architecture family";
+    case EM_COREA_1ST:		return "KIPO-KAIST Core-A 1st generation processor family";
+    case EM_COREA_2ND:		return "KIPO-KAIST Core-A 2nd generation processor family";
+    case EM_ARC_COMPACT2:	return "ARCv2";
+    case EM_OPEN8:		return "Open8 8-bit RISC soft processor core";
+    case EM_RL78:		return "Renesas RL78";
+    case EM_VIDEOCORE5:		return "Broadcom VideoCore V processor";
+    case EM_78K0R:		return "Renesas 78K0R";
+      /* 200 */
+    case EM_56800EX:		return "Freescale 56800EX Digital Signal Controller (DSC)";
+    case EM_BA1:		return "Beyond BA1 CPU architecture";
+    case EM_BA2:		return "Beyond BA2 CPU architecture";
+    case EM_XCORE:		return "XMOS xCORE processor family";
+    case EM_MCHP_PIC:		return "Microchip 8-bit PIC(r) family";
+    case EM_INTELGT:		return "Intel Graphics Technology";
+      /* 210 */
+    case EM_KM32:		return "KM211 KM32 32-bit processor";
+    case EM_KMX32:		return "KM211 KMX32 32-bit processor";
+    case EM_KMX16:		return "KM211 KMX16 16-bit processor";
+    case EM_KMX8:		return "KM211 KMX8 8-bit processor";
+    case EM_KVARC:		return "KM211 KVARC processor";
+    case EM_CDP:		return "Paneve CDP architecture family";
+    case EM_COGE:		return "Cognitive Smart Memory Processor";
+    case EM_COOL:		return "Bluechip Systems CoolEngine";
+    case EM_NORC:		return "Nanoradio Optimized RISC";
+    case EM_CSR_KALIMBA:	return "CSR Kalimba architecture family";
+      /* 220 */
+    case EM_Z80:		return "Zilog Z80";
+    case EM_VISIUM:		return "CDS VISIUMcore processor";
+    case EM_FT32:               return "FTDI Chip FT32";
+    case EM_MOXIE:              return "Moxie";
+    case EM_AMDGPU: 	 	return "AMD GPU";
+      /* 230 (all reserved) */
+      /* 240 */
+    case EM_RISCV: 	 	return "RISC-V";
+    case EM_LANAI:		return "Lanai 32-bit processor";
+    case EM_CEVA:		return "CEVA Processor Architecture Family";
+    case EM_CEVA_X2:		return "CEVA X2 Processor Family";
+    case EM_BPF:		return "Linux BPF";
+    case EM_GRAPHCORE_IPU:	return "Graphcore Intelligent Processing Unit";
+    case EM_IMG1:		return "Imagination Technologies";
+      /* 250 */
+    case EM_NFP:		return "Netronome Flow Processor";
+    case EM_VE:			return "NEC Vector Engine";
+    case EM_CSKY:		return "C-SKY";
+    case EM_ARC_COMPACT3_64:	return "Synopsys ARCv2.3 64-bit";
+    case EM_MCS6502:		return "MOS Technology MCS 6502 processor";
+    case EM_ARC_COMPACT3:	return "Synopsys ARCv2.3 32-bit";
+    case EM_KVX:		return "Kalray VLIW core of the MPPA processor family";
+    case EM_65816:		return "WDC 65816/65C816";
+    case EM_LOONGARCH:		return "LoongArch";
+    case EM_KF32:		return "ChipON KungFu32";
+
+      /* Large numbers...  */
+    case EM_MT:                 return "Morpho Techologies MT processor";
+    case EM_ALPHA:		return "Alpha";
+    case EM_WEBASSEMBLY:	return "Web Assembly";
+    case EM_DLX:		return "OpenDLX";
+    case EM_XSTORMY16:		return "Sanyo XStormy16 CPU core";
+    case EM_IQ2000:       	return "Vitesse IQ2000";
+    case EM_M32C_OLD:
+    case EM_NIOS32:		return "Altera Nios";
+    case EM_CYGNUS_MEP:         return "Toshiba MeP Media Engine";
+    case EM_ADAPTEVA_EPIPHANY:	return "Adapteva EPIPHANY";
+    case EM_CYGNUS_FRV:		return "Fujitsu FR-V";
+    case EM_S12Z:               return "Freescale S12Z";
+
+    default:
+      snprintf (buff, sizeof (buff), _("<unknown>: 0x%x"), e_machine);
+      return buff;
+    }
+}
+
+static void
+decode_ARC_machine_flags (unsigned e_flags, unsigned e_machine, char buf[])
+{
+  /* ARC has two machine types EM_ARC_COMPACT and EM_ARC_COMPACT2.  Some
+     other compilers don't specify an architecture type in the e_flags, and
+     instead use EM_ARC_COMPACT for old ARC600, ARC601, and ARC700
+     architectures, and switch to EM_ARC_COMPACT2 for newer ARCEM and ARCHS
+     architectures.
+
+     Th GNU tools follows this use of EM_ARC_COMPACT and EM_ARC_COMPACT2,
+     but also sets a specific architecture type in the e_flags field.
+
+     However, when decoding the flags we don't worry if we see an
+     unexpected pairing, for example EM_ARC_COMPACT machine type, with
+     ARCEM architecture type.  */
+
+  switch (e_flags & EF_ARC_MACH_MSK)
+    {
+      /* We only expect these to occur for EM_ARC_COMPACT2.  */
+    case EF_ARC_CPU_ARCV2EM:
+      strcat (buf, ", ARC EM");
+      break;
+    case EF_ARC_CPU_ARCV2HS:
+      strcat (buf, ", ARC HS");
+      break;
+
+      /* We only expect these to occur for EM_ARC_COMPACT.  */
+    case E_ARC_MACH_ARC600:
+      strcat (buf, ", ARC600");
+      break;
+    case E_ARC_MACH_ARC601:
+      strcat (buf, ", ARC601");
+      break;
+    case E_ARC_MACH_ARC700:
+      strcat (buf, ", ARC700");
+      break;
+
+      /* The only times we should end up here are (a) A corrupt ELF, (b) A
+         new ELF with new architecture being read by an old version of
+         readelf, or (c) An ELF built with non-GNU compiler that does not
+         set the architecture in the e_flags.  */
+    default:
+      if (e_machine == EM_ARC_COMPACT)
+        strcat (buf, ", Unknown ARCompact");
+      else
+        strcat (buf, ", Unknown ARC");
+      break;
+    }
+
+  switch (e_flags & EF_ARC_OSABI_MSK)
+    {
+    case E_ARC_OSABI_ORIG:
+      strcat (buf, ", (ABI:legacy)");
+      break;
+    case E_ARC_OSABI_V2:
+      strcat (buf, ", (ABI:v2)");
+      break;
+      /* Only upstream 3.9+ kernels will support ARCv2 ISA.  */
+    case E_ARC_OSABI_V3:
+      strcat (buf, ", v3 no-legacy-syscalls ABI");
+      break;
+    case E_ARC_OSABI_V4:
+      strcat (buf, ", v4 ABI");
+      break;
+    default:
+      strcat (buf, ", unrecognised ARC OSABI flag");
+      break;
+    }
+}
+
+static void
+decode_ARM_machine_flags (unsigned e_flags, char buf[])
+{
+  unsigned eabi;
+  bool unknown = false;
+
+  eabi = EF_ARM_EABI_VERSION (e_flags);
+  e_flags &= ~ EF_ARM_EABIMASK;
+
+  /* Handle "generic" ARM flags.  */
+  if (e_flags & EF_ARM_RELEXEC)
+    {
+      strcat (buf, ", relocatable executable");
+      e_flags &= ~ EF_ARM_RELEXEC;
+    }
+
+  if (e_flags & EF_ARM_PIC)
+    {
+      strcat (buf, ", position independent");
+      e_flags &= ~ EF_ARM_PIC;
+    }
+
+  /* Now handle EABI specific flags.  */
+  switch (eabi)
+    {
+    default:
+      strcat (buf, ", <unrecognized EABI>");
+      if (e_flags)
+	unknown = true;
+      break;
+
+    case EF_ARM_EABI_VER1:
+      strcat (buf, ", Version1 EABI");
+      while (e_flags)
+	{
+	  unsigned flag;
+
+	  /* Process flags one bit at a time.  */
+	  flag = e_flags & - e_flags;
+	  e_flags &= ~ flag;
+
+	  switch (flag)
+	    {
+	    case EF_ARM_SYMSARESORTED: /* Conflicts with EF_ARM_INTERWORK.  */
+	      strcat (buf, ", sorted symbol tables");
+	      break;
+
+	    default:
+	      unknown = true;
+	      break;
+	    }
+	}
+      break;
+
+    case EF_ARM_EABI_VER2:
+      strcat (buf, ", Version2 EABI");
+      while (e_flags)
+	{
+	  unsigned flag;
+
+	  /* Process flags one bit at a time.  */
+	  flag = e_flags & - e_flags;
+	  e_flags &= ~ flag;
+
+	  switch (flag)
+	    {
+	    case EF_ARM_SYMSARESORTED: /* Conflicts with EF_ARM_INTERWORK.  */
+	      strcat (buf, ", sorted symbol tables");
+	      break;
+
+	    case EF_ARM_DYNSYMSUSESEGIDX:
+	      strcat (buf, ", dynamic symbols use segment index");
+	      break;
+
+	    case EF_ARM_MAPSYMSFIRST:
+	      strcat (buf, ", mapping symbols precede others");
+	      break;
+
+	    default:
+	      unknown = true;
+	      break;
+	    }
+	}
+      break;
+
+    case EF_ARM_EABI_VER3:
+      strcat (buf, ", Version3 EABI");
+      break;
+
+    case EF_ARM_EABI_VER4:
+      strcat (buf, ", Version4 EABI");
+      while (e_flags)
+	{
+	  unsigned flag;
+
+	  /* Process flags one bit at a time.  */
+	  flag = e_flags & - e_flags;
+	  e_flags &= ~ flag;
+
+	  switch (flag)
+	    {
+	    case EF_ARM_BE8:
+	      strcat (buf, ", BE8");
+	      break;
+
+	    case EF_ARM_LE8:
+	      strcat (buf, ", LE8");
+	      break;
+
+	    default:
+	      unknown = true;
+	      break;
+	    }
+	}
+      break;
+
+    case EF_ARM_EABI_VER5:
+      strcat (buf, ", Version5 EABI");
+      while (e_flags)
+	{
+	  unsigned flag;
+
+	  /* Process flags one bit at a time.  */
+	  flag = e_flags & - e_flags;
+	  e_flags &= ~ flag;
+
+	  switch (flag)
+	    {
+	    case EF_ARM_BE8:
+	      strcat (buf, ", BE8");
+	      break;
+
+	    case EF_ARM_LE8:
+	      strcat (buf, ", LE8");
+	      break;
+
+	    case EF_ARM_ABI_FLOAT_SOFT: /* Conflicts with EF_ARM_SOFT_FLOAT.  */
+	      strcat (buf, ", soft-float ABI");
+	      break;
+
+	    case EF_ARM_ABI_FLOAT_HARD: /* Conflicts with EF_ARM_VFP_FLOAT.  */
+	      strcat (buf, ", hard-float ABI");
+	      break;
+
+	    default:
+	      unknown = true;
+	      break;
+	    }
+	}
+      break;
+
+    case EF_ARM_EABI_UNKNOWN:
+      strcat (buf, ", GNU EABI");
+      while (e_flags)
+	{
+	  unsigned flag;
+
+	  /* Process flags one bit at a time.  */
+	  flag = e_flags & - e_flags;
+	  e_flags &= ~ flag;
+
+	  switch (flag)
+	    {
+	    case EF_ARM_INTERWORK:
+	      strcat (buf, ", interworking enabled");
+	      break;
+
+	    case EF_ARM_APCS_26:
+	      strcat (buf, ", uses APCS/26");
+	      break;
+
+	    case EF_ARM_APCS_FLOAT:
+	      strcat (buf, ", uses APCS/float");
+	      break;
+
+	    case EF_ARM_PIC:
+	      strcat (buf, ", position independent");
+	      break;
+
+	    case EF_ARM_ALIGN8:
+	      strcat (buf, ", 8 bit structure alignment");
+	      break;
+
+	    case EF_ARM_NEW_ABI:
+	      strcat (buf, ", uses new ABI");
+	      break;
+
+	    case EF_ARM_OLD_ABI:
+	      strcat (buf, ", uses old ABI");
+	      break;
+
+	    case EF_ARM_SOFT_FLOAT:
+	      strcat (buf, ", software FP");
+	      break;
+
+	    case EF_ARM_VFP_FLOAT:
+	      strcat (buf, ", VFP");
+	      break;
+
+	    case EF_ARM_MAVERICK_FLOAT:
+	      strcat (buf, ", Maverick FP");
+	      break;
+
+	    default:
+	      unknown = true;
+	      break;
+	    }
+	}
+    }
+
+  if (unknown)
+    strcat (buf,_(", <unknown>"));
+}
+
+static void
+decode_AVR_machine_flags (unsigned e_flags, char buf[], size_t size)
+{
+  --size; /* Leave space for null terminator.  */
+
+  switch (e_flags & EF_AVR_MACH)
+    {
+    case E_AVR_MACH_AVR1:
+      strncat (buf, ", avr:1", size);
+      break;
+    case E_AVR_MACH_AVR2:
+      strncat (buf, ", avr:2", size);
+      break;
+    case E_AVR_MACH_AVR25:
+      strncat (buf, ", avr:25", size);
+      break;
+    case E_AVR_MACH_AVR3:
+      strncat (buf, ", avr:3", size);
+      break;
+    case E_AVR_MACH_AVR31:
+      strncat (buf, ", avr:31", size);
+      break;
+    case E_AVR_MACH_AVR35:
+      strncat (buf, ", avr:35", size);
+      break;
+    case E_AVR_MACH_AVR4:
+      strncat (buf, ", avr:4", size);
+      break;
+    case E_AVR_MACH_AVR5:
+      strncat (buf, ", avr:5", size);
+      break;
+    case E_AVR_MACH_AVR51:
+      strncat (buf, ", avr:51", size);
+      break;
+    case E_AVR_MACH_AVR6:
+      strncat (buf, ", avr:6", size);
+      break;
+    case E_AVR_MACH_AVRTINY:
+      strncat (buf, ", avr:100", size);
+      break;
+    case E_AVR_MACH_XMEGA1:
+      strncat (buf, ", avr:101", size);
+      break;
+    case E_AVR_MACH_XMEGA2:
+      strncat (buf, ", avr:102", size);
+      break;
+    case E_AVR_MACH_XMEGA3:
+      strncat (buf, ", avr:103", size);
+      break;
+    case E_AVR_MACH_XMEGA4:
+      strncat (buf, ", avr:104", size);
+      break;
+    case E_AVR_MACH_XMEGA5:
+      strncat (buf, ", avr:105", size);
+      break;
+    case E_AVR_MACH_XMEGA6:
+      strncat (buf, ", avr:106", size);
+      break;
+    case E_AVR_MACH_XMEGA7:
+      strncat (buf, ", avr:107", size);
+      break;
+    default:
+      strncat (buf, ", avr:<unknown>", size);
+      break;
+    }
+
+  size -= strlen (buf);
+  if (e_flags & EF_AVR_LINKRELAX_PREPARED)
+    strncat (buf, ", link-relax", size);
+}
+
+static void
+decode_NDS32_machine_flags (unsigned e_flags, char buf[], size_t size)
+{
+  unsigned abi;
+  unsigned arch;
+  unsigned config;
+  unsigned version;
+  bool has_fpu = false;
+  unsigned int r = 0;
+
+  static const char *ABI_STRINGS[] =
+  {
+    "ABI v0", /* use r5 as return register; only used in N1213HC */
+    "ABI v1", /* use r0 as return register */
+    "ABI v2", /* use r0 as return register and don't reserve 24 bytes for arguments */
+    "ABI v2fp", /* for FPU */
+    "AABI",
+    "ABI2 FP+"
+  };
+  static const char *VER_STRINGS[] =
+  {
+    "Andes ELF V1.3 or older",
+    "Andes ELF V1.3.1",
+    "Andes ELF V1.4"
+  };
+  static const char *ARCH_STRINGS[] =
+  {
+    "",
+    "Andes Star v1.0",
+    "Andes Star v2.0",
+    "Andes Star v3.0",
+    "Andes Star v3.0m"
+  };
+
+  abi = EF_NDS_ABI & e_flags;
+  arch = EF_NDS_ARCH & e_flags;
+  config = EF_NDS_INST & e_flags;
+  version = EF_NDS32_ELF_VERSION & e_flags;
+
+  memset (buf, 0, size);
+
+  switch (abi)
+    {
+    case E_NDS_ABI_V0:
+    case E_NDS_ABI_V1:
+    case E_NDS_ABI_V2:
+    case E_NDS_ABI_V2FP:
+    case E_NDS_ABI_AABI:
+    case E_NDS_ABI_V2FP_PLUS:
+      /* In case there are holes in the array.  */
+      r += snprintf (buf + r, size - r, ", %s", ABI_STRINGS[abi >> EF_NDS_ABI_SHIFT]);
+      break;
+
+    default:
+      r += snprintf (buf + r, size - r, ", <unrecognized ABI>");
+      break;
+    }
+
+  switch (version)
+    {
+    case E_NDS32_ELF_VER_1_2:
+    case E_NDS32_ELF_VER_1_3:
+    case E_NDS32_ELF_VER_1_4:
+      r += snprintf (buf + r, size - r, ", %s", VER_STRINGS[version >> EF_NDS32_ELF_VERSION_SHIFT]);
+      break;
+
+    default:
+      r += snprintf (buf + r, size - r, ", <unrecognized ELF version number>");
+      break;
+    }
+
+  if (E_NDS_ABI_V0 == abi)
+    {
+      /* OLD ABI; only used in N1213HC, has performance extension 1.  */
+      r += snprintf (buf + r, size - r, ", Andes Star v1.0, N1213HC, MAC, PERF1");
+      if (arch == E_NDS_ARCH_STAR_V1_0)
+	r += snprintf (buf + r, size -r, ", 16b"); /* has 16-bit instructions */
+      return;
+    }
+
+  switch (arch)
+    {
+    case E_NDS_ARCH_STAR_V1_0:
+    case E_NDS_ARCH_STAR_V2_0:
+    case E_NDS_ARCH_STAR_V3_0:
+    case E_NDS_ARCH_STAR_V3_M:
+      r += snprintf (buf + r, size - r, ", %s", ARCH_STRINGS[arch >> EF_NDS_ARCH_SHIFT]);
+      break;
+
+    default:
+      r += snprintf (buf + r, size - r, ", <unrecognized architecture>");
+      /* ARCH version determines how the e_flags are interpreted.
+	 If it is unknown, we cannot proceed.  */
+      return;
+    }
+
+  /* Newer ABI; Now handle architecture specific flags.  */
+  if (arch == E_NDS_ARCH_STAR_V1_0)
+    {
+      if (config & E_NDS32_HAS_MFUSR_PC_INST)
+	r += snprintf (buf + r, size -r, ", MFUSR_PC");
+
+      if (!(config & E_NDS32_HAS_NO_MAC_INST))
+	r += snprintf (buf + r, size -r, ", MAC");
+
+      if (config & E_NDS32_HAS_DIV_INST)
+	r += snprintf (buf + r, size -r, ", DIV");
+
+      if (config & E_NDS32_HAS_16BIT_INST)
+	r += snprintf (buf + r, size -r, ", 16b");
+    }
+  else
+    {
+      if (config & E_NDS32_HAS_MFUSR_PC_INST)
+	{
+	  if (version <= E_NDS32_ELF_VER_1_3)
+	    r += snprintf (buf + r, size -r, ", [B8]");
+	  else
+	    r += snprintf (buf + r, size -r, ", EX9");
+	}
+
+      if (config & E_NDS32_HAS_MAC_DX_INST)
+	r += snprintf (buf + r, size -r, ", MAC_DX");
+
+      if (config & E_NDS32_HAS_DIV_DX_INST)
+	r += snprintf (buf + r, size -r, ", DIV_DX");
+
+      if (config & E_NDS32_HAS_16BIT_INST)
+	{
+	  if (version <= E_NDS32_ELF_VER_1_3)
+	    r += snprintf (buf + r, size -r, ", 16b");
+	  else
+	    r += snprintf (buf + r, size -r, ", IFC");
+	}
+    }
+
+  if (config & E_NDS32_HAS_EXT_INST)
+    r += snprintf (buf + r, size -r, ", PERF1");
+
+  if (config & E_NDS32_HAS_EXT2_INST)
+    r += snprintf (buf + r, size -r, ", PERF2");
+
+  if (config & E_NDS32_HAS_FPU_INST)
+    {
+      has_fpu = true;
+      r += snprintf (buf + r, size -r, ", FPU_SP");
+    }
+
+  if (config & E_NDS32_HAS_FPU_DP_INST)
+    {
+      has_fpu = true;
+      r += snprintf (buf + r, size -r, ", FPU_DP");
+    }
+
+  if (config & E_NDS32_HAS_FPU_MAC_INST)
+    {
+      has_fpu = true;
+      r += snprintf (buf + r, size -r, ", FPU_MAC");
+    }
+
+  if (has_fpu)
+    {
+      switch ((config & E_NDS32_FPU_REG_CONF) >> E_NDS32_FPU_REG_CONF_SHIFT)
+	{
+	case E_NDS32_FPU_REG_8SP_4DP:
+	  r += snprintf (buf + r, size -r, ", FPU_REG:8/4");
+	  break;
+	case E_NDS32_FPU_REG_16SP_8DP:
+	  r += snprintf (buf + r, size -r, ", FPU_REG:16/8");
+	  break;
+	case E_NDS32_FPU_REG_32SP_16DP:
+	  r += snprintf (buf + r, size -r, ", FPU_REG:32/16");
+	  break;
+	case E_NDS32_FPU_REG_32SP_32DP:
+	  r += snprintf (buf + r, size -r, ", FPU_REG:32/32");
+	  break;
+	}
+    }
+
+  if (config & E_NDS32_HAS_AUDIO_INST)
+    r += snprintf (buf + r, size -r, ", AUDIO");
+
+  if (config & E_NDS32_HAS_STRING_INST)
+    r += snprintf (buf + r, size -r, ", STR");
+
+  if (config & E_NDS32_HAS_REDUCED_REGS)
+    r += snprintf (buf + r, size -r, ", 16REG");
+
+  if (config & E_NDS32_HAS_VIDEO_INST)
+    {
+      if (version <= E_NDS32_ELF_VER_1_3)
+	r += snprintf (buf + r, size -r, ", VIDEO");
+      else
+	r += snprintf (buf + r, size -r, ", SATURATION");
+    }
+
+  if (config & E_NDS32_HAS_ENCRIPT_INST)
+    r += snprintf (buf + r, size -r, ", ENCRP");
+
+  if (config & E_NDS32_HAS_L2C_INST)
+    r += snprintf (buf + r, size -r, ", L2C");
+}
+
+static char *
+get_machine_flags (Filedata * filedata, unsigned e_flags, unsigned e_machine)
+{
+  static char buf[1024];
+
+  buf[0] = '\0';
+
+  if (e_flags)
+    {
+      switch (e_machine)
+	{
+	default:
+	  break;
+
+	case EM_ARC_COMPACT2:
+	case EM_ARC_COMPACT:
+          decode_ARC_machine_flags (e_flags, e_machine, buf);
+          break;
+
+	case EM_ARM:
+	  decode_ARM_machine_flags (e_flags, buf);
+	  break;
+
+        case EM_AVR:
+          decode_AVR_machine_flags (e_flags, buf, sizeof buf);
+          break;
+
+	case EM_BLACKFIN:
+	  if (e_flags & EF_BFIN_PIC)
+	    strcat (buf, ", PIC");
+
+	  if (e_flags & EF_BFIN_FDPIC)
+	    strcat (buf, ", FDPIC");
+
+	  if (e_flags & EF_BFIN_CODE_IN_L1)
+	    strcat (buf, ", code in L1");
+
+	  if (e_flags & EF_BFIN_DATA_IN_L1)
+	    strcat (buf, ", data in L1");
+
+	  break;
+
+	case EM_CYGNUS_FRV:
+	  switch (e_flags & EF_FRV_CPU_MASK)
+	    {
+	    case EF_FRV_CPU_GENERIC:
+	      break;
+
+	    default:
+	      strcat (buf, ", fr???");
+	      break;
+
+	    case EF_FRV_CPU_FR300:
+	      strcat (buf, ", fr300");
+	      break;
+
+	    case EF_FRV_CPU_FR400:
+	      strcat (buf, ", fr400");
+	      break;
+	    case EF_FRV_CPU_FR405:
+	      strcat (buf, ", fr405");
+	      break;
+
+	    case EF_FRV_CPU_FR450:
+	      strcat (buf, ", fr450");
+	      break;
+
+	    case EF_FRV_CPU_FR500:
+	      strcat (buf, ", fr500");
+	      break;
+	    case EF_FRV_CPU_FR550:
+	      strcat (buf, ", fr550");
+	      break;
+
+	    case EF_FRV_CPU_SIMPLE:
+	      strcat (buf, ", simple");
+	      break;
+	    case EF_FRV_CPU_TOMCAT:
+	      strcat (buf, ", tomcat");
+	      break;
+	    }
+	  break;
+
+	case EM_68K:
+	  if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_M68000)
+	    strcat (buf, ", m68000");
+	  else if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_CPU32)
+	    strcat (buf, ", cpu32");
+	  else if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_FIDO)
+	    strcat (buf, ", fido_a");
+	  else
+	    {
+	      char const * isa = _("unknown");
+	      char const * mac = _("unknown mac");
+	      char const * additional = NULL;
+
+	      switch (e_flags & EF_M68K_CF_ISA_MASK)
+		{
+		case EF_M68K_CF_ISA_A_NODIV:
+		  isa = "A";
+		  additional = ", nodiv";
+		  break;
+		case EF_M68K_CF_ISA_A:
+		  isa = "A";
+		  break;
+		case EF_M68K_CF_ISA_A_PLUS:
+		  isa = "A+";
+		  break;
+		case EF_M68K_CF_ISA_B_NOUSP:
+		  isa = "B";
+		  additional = ", nousp";
+		  break;
+		case EF_M68K_CF_ISA_B:
+		  isa = "B";
+		  break;
+		case EF_M68K_CF_ISA_C:
+		  isa = "C";
+		  break;
+		case EF_M68K_CF_ISA_C_NODIV:
+		  isa = "C";
+		  additional = ", nodiv";
+		  break;
+		}
+	      strcat (buf, ", cf, isa ");
+	      strcat (buf, isa);
+	      if (additional)
+		strcat (buf, additional);
+	      if (e_flags & EF_M68K_CF_FLOAT)
+		strcat (buf, ", float");
+	      switch (e_flags & EF_M68K_CF_MAC_MASK)
+		{
+		case 0:
+		  mac = NULL;
+		  break;
+		case EF_M68K_CF_MAC:
+		  mac = "mac";
+		  break;
+		case EF_M68K_CF_EMAC:
+		  mac = "emac";
+		  break;
+		case EF_M68K_CF_EMAC_B:
+		  mac = "emac_b";
+		  break;
+		}
+	      if (mac)
+		{
+		  strcat (buf, ", ");
+		  strcat (buf, mac);
+		}
+	    }
+	  break;
+
+	case EM_CYGNUS_MEP:
+	  switch (e_flags & EF_MEP_CPU_MASK)
+	    {
+	    case EF_MEP_CPU_MEP: strcat (buf, ", generic MeP"); break;
+	    case EF_MEP_CPU_C2: strcat (buf, ", MeP C2"); break;
+	    case EF_MEP_CPU_C3: strcat (buf, ", MeP C3"); break;
+	    case EF_MEP_CPU_C4: strcat (buf, ", MeP C4"); break;
+	    case EF_MEP_CPU_C5: strcat (buf, ", MeP C5"); break;
+	    case EF_MEP_CPU_H1: strcat (buf, ", MeP H1"); break;
+	    default: strcat (buf, _(", <unknown MeP cpu type>")); break;
+	    }
+
+	  switch (e_flags & EF_MEP_COP_MASK)
+	    {
+	    case EF_MEP_COP_NONE: break;
+	    case EF_MEP_COP_AVC: strcat (buf, ", AVC coprocessor"); break;
+	    case EF_MEP_COP_AVC2: strcat (buf, ", AVC2 coprocessor"); break;
+	    case EF_MEP_COP_FMAX: strcat (buf, ", FMAX coprocessor"); break;
+	    case EF_MEP_COP_IVC2: strcat (buf, ", IVC2 coprocessor"); break;
+	    default: strcat (buf, _("<unknown MeP copro type>")); break;
+	    }
+
+	  if (e_flags & EF_MEP_LIBRARY)
+	    strcat (buf, ", Built for Library");
+
+	  if (e_flags & EF_MEP_INDEX_MASK)
+	    sprintf (buf + strlen (buf), ", Configuration Index: %#x",
+		     e_flags & EF_MEP_INDEX_MASK);
+
+	  if (e_flags & ~ EF_MEP_ALL_FLAGS)
+	    sprintf (buf + strlen (buf), _(", unknown flags bits: %#x"),
+		     e_flags & ~ EF_MEP_ALL_FLAGS);
+	  break;
+
+	case EM_PPC:
+	  if (e_flags & EF_PPC_EMB)
+	    strcat (buf, ", emb");
+
+	  if (e_flags & EF_PPC_RELOCATABLE)
+	    strcat (buf, _(", relocatable"));
+
+	  if (e_flags & EF_PPC_RELOCATABLE_LIB)
+	    strcat (buf, _(", relocatable-lib"));
+	  break;
+
+	case EM_PPC64:
+	  if (e_flags & EF_PPC64_ABI)
+	    {
+	      char abi[] = ", abiv0";
+
+	      abi[6] += e_flags & EF_PPC64_ABI;
+	      strcat (buf, abi);
+	    }
+	  break;
+
+	case EM_V800:
+	  if ((e_flags & EF_RH850_ABI) == EF_RH850_ABI)
+	    strcat (buf, ", RH850 ABI");
+
+	  if (e_flags & EF_V800_850E3)
+	    strcat (buf, ", V3 architecture");
+
+	  if ((e_flags & (EF_RH850_FPU_DOUBLE | EF_RH850_FPU_SINGLE)) == 0)
+	    strcat (buf, ", FPU not used");
+
+	  if ((e_flags & (EF_RH850_REGMODE22 | EF_RH850_REGMODE32)) == 0)
+	    strcat (buf, ", regmode: COMMON");
+
+	  if ((e_flags & (EF_RH850_GP_FIX | EF_RH850_GP_NOFIX)) == 0)
+	    strcat (buf, ", r4 not used");
+
+	  if ((e_flags & (EF_RH850_EP_FIX | EF_RH850_EP_NOFIX)) == 0)
+	    strcat (buf, ", r30 not used");
+
+	  if ((e_flags & (EF_RH850_TP_FIX | EF_RH850_TP_NOFIX)) == 0)
+	    strcat (buf, ", r5 not used");
+
+	  if ((e_flags & (EF_RH850_REG2_RESERVE | EF_RH850_REG2_NORESERVE)) == 0)
+	    strcat (buf, ", r2 not used");
+
+	  for (e_flags &= 0xFFFF; e_flags; e_flags &= ~ (e_flags & - e_flags))
+	    {
+	      switch (e_flags & - e_flags)
+		{
+		case EF_RH850_FPU_DOUBLE: strcat (buf, ", double precision FPU"); break;
+		case EF_RH850_FPU_SINGLE: strcat (buf, ", single precision FPU"); break;
+		case EF_RH850_REGMODE22: strcat (buf, ", regmode:22"); break;
+		case EF_RH850_REGMODE32: strcat (buf, ", regmode:23"); break;
+		case EF_RH850_GP_FIX: strcat (buf, ", r4 fixed"); break;
+		case EF_RH850_GP_NOFIX: strcat (buf, ", r4 free"); break;
+		case EF_RH850_EP_FIX: strcat (buf, ", r30 fixed"); break;
+		case EF_RH850_EP_NOFIX: strcat (buf, ", r30 free"); break;
+		case EF_RH850_TP_FIX: strcat (buf, ", r5 fixed"); break;
+		case EF_RH850_TP_NOFIX: strcat (buf, ", r5 free"); break;
+		case EF_RH850_REG2_RESERVE: strcat (buf, ", r2 fixed"); break;
+		case EF_RH850_REG2_NORESERVE: strcat (buf, ", r2 free"); break;
+		default: break;
+		}
+	    }
+	  break;
+
+	case EM_V850:
+	case EM_CYGNUS_V850:
+	  switch (e_flags & EF_V850_ARCH)
+	    {
+	    case E_V850E3V5_ARCH:
+	      strcat (buf, ", v850e3v5");
+	      break;
+	    case E_V850E2V3_ARCH:
+	      strcat (buf, ", v850e2v3");
+	      break;
+	    case E_V850E2_ARCH:
+	      strcat (buf, ", v850e2");
+	      break;
+            case E_V850E1_ARCH:
+              strcat (buf, ", v850e1");
+	      break;
+	    case E_V850E_ARCH:
+	      strcat (buf, ", v850e");
+	      break;
+	    case E_V850_ARCH:
+	      strcat (buf, ", v850");
+	      break;
+	    default:
+	      strcat (buf, _(", unknown v850 architecture variant"));
+	      break;
+	    }
+	  break;
+
+	case EM_M32R:
+	case EM_CYGNUS_M32R:
+	  if ((e_flags & EF_M32R_ARCH) == E_M32R_ARCH)
+	    strcat (buf, ", m32r");
+	  break;
+
+	case EM_MIPS:
+	case EM_MIPS_RS3_LE:
+	  if (e_flags & EF_MIPS_NOREORDER)
+	    strcat (buf, ", noreorder");
+
+	  if (e_flags & EF_MIPS_PIC)
+	    strcat (buf, ", pic");
+
+	  if (e_flags & EF_MIPS_CPIC)
+	    strcat (buf, ", cpic");
+
+	  if (e_flags & EF_MIPS_UCODE)
+	    strcat (buf, ", ugen_reserved");
+
+	  if (e_flags & EF_MIPS_ABI2)
+	    strcat (buf, ", abi2");
+
+	  if (e_flags & EF_MIPS_OPTIONS_FIRST)
+	    strcat (buf, ", odk first");
+
+	  if (e_flags & EF_MIPS_32BITMODE)
+	    strcat (buf, ", 32bitmode");
+
+	  if (e_flags & EF_MIPS_NAN2008)
+	    strcat (buf, ", nan2008");
+
+	  if (e_flags & EF_MIPS_FP64)
+	    strcat (buf, ", fp64");
+
+	  switch ((e_flags & EF_MIPS_MACH))
+	    {
+	    case E_MIPS_MACH_3900: strcat (buf, ", 3900"); break;
+	    case E_MIPS_MACH_4010: strcat (buf, ", 4010"); break;
+	    case E_MIPS_MACH_4100: strcat (buf, ", 4100"); break;
+	    case E_MIPS_MACH_4111: strcat (buf, ", 4111"); break;
+	    case E_MIPS_MACH_4120: strcat (buf, ", 4120"); break;
+	    case E_MIPS_MACH_4650: strcat (buf, ", 4650"); break;
+	    case E_MIPS_MACH_5400: strcat (buf, ", 5400"); break;
+	    case E_MIPS_MACH_5500: strcat (buf, ", 5500"); break;
+	    case E_MIPS_MACH_5900: strcat (buf, ", 5900"); break;
+	    case E_MIPS_MACH_SB1:  strcat (buf, ", sb1");  break;
+	    case E_MIPS_MACH_9000: strcat (buf, ", 9000"); break;
+  	    case E_MIPS_MACH_LS2E: strcat (buf, ", loongson-2e"); break;
+  	    case E_MIPS_MACH_LS2F: strcat (buf, ", loongson-2f"); break;
+	    case E_MIPS_MACH_GS464: strcat (buf, ", gs464"); break;
+	    case E_MIPS_MACH_GS464E: strcat (buf, ", gs464e"); break;
+	    case E_MIPS_MACH_GS264E: strcat (buf, ", gs264e"); break;
+	    case E_MIPS_MACH_OCTEON: strcat (buf, ", octeon"); break;
+	    case E_MIPS_MACH_OCTEON2: strcat (buf, ", octeon2"); break;
+	    case E_MIPS_MACH_OCTEON3: strcat (buf, ", octeon3"); break;
+	    case E_MIPS_MACH_XLR:  strcat (buf, ", xlr"); break;
+	    case E_MIPS_MACH_IAMR2:  strcat (buf, ", interaptiv-mr2"); break;
+	    case 0:
+	    /* We simply ignore the field in this case to avoid confusion:
+	       MIPS ELF does not specify EF_MIPS_MACH, it is a GNU
+	       extension.  */
+	      break;
+	    default: strcat (buf, _(", unknown CPU")); break;
+	    }
+
+	  switch ((e_flags & EF_MIPS_ABI))
+	    {
+	    case E_MIPS_ABI_O32: strcat (buf, ", o32"); break;
+	    case E_MIPS_ABI_O64: strcat (buf, ", o64"); break;
+	    case E_MIPS_ABI_EABI32: strcat (buf, ", eabi32"); break;
+	    case E_MIPS_ABI_EABI64: strcat (buf, ", eabi64"); break;
+	    case 0:
+	    /* We simply ignore the field in this case to avoid confusion:
+	       MIPS ELF does not specify EF_MIPS_ABI, it is a GNU extension.
+	       This means it is likely to be an o32 file, but not for
+	       sure.  */
+	      break;
+	    default: strcat (buf, _(", unknown ABI")); break;
+	    }
+
+	  if (e_flags & EF_MIPS_ARCH_ASE_MDMX)
+	    strcat (buf, ", mdmx");
+
+	  if (e_flags & EF_MIPS_ARCH_ASE_M16)
+	    strcat (buf, ", mips16");
+
+	  if (e_flags & EF_MIPS_ARCH_ASE_MICROMIPS)
+	    strcat (buf, ", micromips");
+
+	  switch ((e_flags & EF_MIPS_ARCH))
+	    {
+	    case E_MIPS_ARCH_1: strcat (buf, ", mips1"); break;
+	    case E_MIPS_ARCH_2: strcat (buf, ", mips2"); break;
+	    case E_MIPS_ARCH_3: strcat (buf, ", mips3"); break;
+	    case E_MIPS_ARCH_4: strcat (buf, ", mips4"); break;
+	    case E_MIPS_ARCH_5: strcat (buf, ", mips5"); break;
+	    case E_MIPS_ARCH_32: strcat (buf, ", mips32"); break;
+	    case E_MIPS_ARCH_32R2: strcat (buf, ", mips32r2"); break;
+	    case E_MIPS_ARCH_32R6: strcat (buf, ", mips32r6"); break;
+	    case E_MIPS_ARCH_64: strcat (buf, ", mips64"); break;
+	    case E_MIPS_ARCH_64R2: strcat (buf, ", mips64r2"); break;
+	    case E_MIPS_ARCH_64R6: strcat (buf, ", mips64r6"); break;
+	    default: strcat (buf, _(", unknown ISA")); break;
+	    }
+	  break;
+
+	case EM_NDS32:
+	  decode_NDS32_machine_flags (e_flags, buf, sizeof buf);
+	  break;
+
+	case EM_NFP:
+	  switch (EF_NFP_MACH (e_flags))
+	    {
+	    case E_NFP_MACH_3200:
+	      strcat (buf, ", NFP-32xx");
+	      break;
+	    case E_NFP_MACH_6000:
+	      strcat (buf, ", NFP-6xxx");
+	      break;
+	    }
+	  break;
+
+	case EM_RISCV:
+	  if (e_flags & EF_RISCV_RVC)
+	    strcat (buf, ", RVC");
+
+	  if (e_flags & EF_RISCV_RVE)
+	    strcat (buf, ", RVE");
+
+	  switch (e_flags & EF_RISCV_FLOAT_ABI)
+	    {
+	    case EF_RISCV_FLOAT_ABI_SOFT:
+	      strcat (buf, ", soft-float ABI");
+	      break;
+
+	    case EF_RISCV_FLOAT_ABI_SINGLE:
+	      strcat (buf, ", single-float ABI");
+	      break;
+
+	    case EF_RISCV_FLOAT_ABI_DOUBLE:
+	      strcat (buf, ", double-float ABI");
+	      break;
+
+	    case EF_RISCV_FLOAT_ABI_QUAD:
+	      strcat (buf, ", quad-float ABI");
+	      break;
+	    }
+	  break;
+
+	case EM_SH:
+	  switch ((e_flags & EF_SH_MACH_MASK))
+	    {
+	    case EF_SH1: strcat (buf, ", sh1"); break;
+	    case EF_SH2: strcat (buf, ", sh2"); break;
+	    case EF_SH3: strcat (buf, ", sh3"); break;
+	    case EF_SH_DSP: strcat (buf, ", sh-dsp"); break;
+	    case EF_SH3_DSP: strcat (buf, ", sh3-dsp"); break;
+	    case EF_SH4AL_DSP: strcat (buf, ", sh4al-dsp"); break;
+	    case EF_SH3E: strcat (buf, ", sh3e"); break;
+	    case EF_SH4: strcat (buf, ", sh4"); break;
+	    case EF_SH5: strcat (buf, ", sh5"); break;
+	    case EF_SH2E: strcat (buf, ", sh2e"); break;
+	    case EF_SH4A: strcat (buf, ", sh4a"); break;
+	    case EF_SH2A: strcat (buf, ", sh2a"); break;
+	    case EF_SH4_NOFPU: strcat (buf, ", sh4-nofpu"); break;
+	    case EF_SH4A_NOFPU: strcat (buf, ", sh4a-nofpu"); break;
+	    case EF_SH2A_NOFPU: strcat (buf, ", sh2a-nofpu"); break;
+	    case EF_SH3_NOMMU: strcat (buf, ", sh3-nommu"); break;
+	    case EF_SH4_NOMMU_NOFPU: strcat (buf, ", sh4-nommu-nofpu"); break;
+	    case EF_SH2A_SH4_NOFPU: strcat (buf, ", sh2a-nofpu-or-sh4-nommu-nofpu"); break;
+	    case EF_SH2A_SH3_NOFPU: strcat (buf, ", sh2a-nofpu-or-sh3-nommu"); break;
+	    case EF_SH2A_SH4: strcat (buf, ", sh2a-or-sh4"); break;
+	    case EF_SH2A_SH3E: strcat (buf, ", sh2a-or-sh3e"); break;
+	    default: strcat (buf, _(", unknown ISA")); break;
+	    }
+
+	  if (e_flags & EF_SH_PIC)
+	    strcat (buf, ", pic");
+
+	  if (e_flags & EF_SH_FDPIC)
+	    strcat (buf, ", fdpic");
+	  break;
+
+        case EM_OR1K:
+          if (e_flags & EF_OR1K_NODELAY)
+            strcat (buf, ", no delay");
+          break;
+
+	case EM_SPARCV9:
+	  if (e_flags & EF_SPARC_32PLUS)
+	    strcat (buf, ", v8+");
+
+	  if (e_flags & EF_SPARC_SUN_US1)
+	    strcat (buf, ", ultrasparcI");
+
+	  if (e_flags & EF_SPARC_SUN_US3)
+	    strcat (buf, ", ultrasparcIII");
+
+	  if (e_flags & EF_SPARC_HAL_R1)
+	    strcat (buf, ", halr1");
+
+	  if (e_flags & EF_SPARC_LEDATA)
+	    strcat (buf, ", ledata");
+
+	  if ((e_flags & EF_SPARCV9_MM) == EF_SPARCV9_TSO)
+	    strcat (buf, ", tso");
+
+	  if ((e_flags & EF_SPARCV9_MM) == EF_SPARCV9_PSO)
+	    strcat (buf, ", pso");
+
+	  if ((e_flags & EF_SPARCV9_MM) == EF_SPARCV9_RMO)
+	    strcat (buf, ", rmo");
+	  break;
+
+	case EM_PARISC:
+	  switch (e_flags & EF_PARISC_ARCH)
+	    {
+	    case EFA_PARISC_1_0:
+	      strcpy (buf, ", PA-RISC 1.0");
+	      break;
+	    case EFA_PARISC_1_1:
+	      strcpy (buf, ", PA-RISC 1.1");
+	      break;
+	    case EFA_PARISC_2_0:
+	      strcpy (buf, ", PA-RISC 2.0");
+	      break;
+	    default:
+	      break;
+	    }
+	  if (e_flags & EF_PARISC_TRAPNIL)
+	    strcat (buf, ", trapnil");
+	  if (e_flags & EF_PARISC_EXT)
+	    strcat (buf, ", ext");
+	  if (e_flags & EF_PARISC_LSB)
+	    strcat (buf, ", lsb");
+	  if (e_flags & EF_PARISC_WIDE)
+	    strcat (buf, ", wide");
+	  if (e_flags & EF_PARISC_NO_KABP)
+	    strcat (buf, ", no kabp");
+	  if (e_flags & EF_PARISC_LAZYSWAP)
+	    strcat (buf, ", lazyswap");
+	  break;
+
+	case EM_PJ:
+	case EM_PJ_OLD:
+	  if ((e_flags & EF_PICOJAVA_NEWCALLS) == EF_PICOJAVA_NEWCALLS)
+	    strcat (buf, ", new calling convention");
+
+	  if ((e_flags & EF_PICOJAVA_GNUCALLS) == EF_PICOJAVA_GNUCALLS)
+	    strcat (buf, ", gnu calling convention");
+	  break;
+
+	case EM_IA_64:
+	  if ((e_flags & EF_IA_64_ABI64))
+	    strcat (buf, ", 64-bit");
+	  else
+	    strcat (buf, ", 32-bit");
+	  if ((e_flags & EF_IA_64_REDUCEDFP))
+	    strcat (buf, ", reduced fp model");
+	  if ((e_flags & EF_IA_64_NOFUNCDESC_CONS_GP))
+	    strcat (buf, ", no function descriptors, constant gp");
+	  else if ((e_flags & EF_IA_64_CONS_GP))
+	    strcat (buf, ", constant gp");
+	  if ((e_flags & EF_IA_64_ABSOLUTE))
+	    strcat (buf, ", absolute");
+          if (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_OPENVMS)
+            {
+              if ((e_flags & EF_IA_64_VMS_LINKAGES))
+                strcat (buf, ", vms_linkages");
+              switch ((e_flags & EF_IA_64_VMS_COMCOD))
+                {
+                case EF_IA_64_VMS_COMCOD_SUCCESS:
+                  break;
+                case EF_IA_64_VMS_COMCOD_WARNING:
+                  strcat (buf, ", warning");
+                  break;
+                case EF_IA_64_VMS_COMCOD_ERROR:
+                  strcat (buf, ", error");
+                  break;
+                case EF_IA_64_VMS_COMCOD_ABORT:
+                  strcat (buf, ", abort");
+                  break;
+                default:
+		  warn (_("Unrecognised IA64 VMS Command Code: %x\n"),
+			e_flags & EF_IA_64_VMS_COMCOD);
+		  strcat (buf, ", <unknown>");
+                }
+            }
+	  break;
+
+	case EM_VAX:
+	  if ((e_flags & EF_VAX_NONPIC))
+	    strcat (buf, ", non-PIC");
+	  if ((e_flags & EF_VAX_DFLOAT))
+	    strcat (buf, ", D-Float");
+	  if ((e_flags & EF_VAX_GFLOAT))
+	    strcat (buf, ", G-Float");
+	  break;
+
+        case EM_VISIUM:
+	  if (e_flags & EF_VISIUM_ARCH_MCM)
+	    strcat (buf, ", mcm");
+	  else if (e_flags & EF_VISIUM_ARCH_MCM24)
+	    strcat (buf, ", mcm24");
+	  if (e_flags & EF_VISIUM_ARCH_GR6)
+	    strcat (buf, ", gr6");
+	  break;
+
+	case EM_RL78:
+	  switch (e_flags & E_FLAG_RL78_CPU_MASK)
+	    {
+	    case E_FLAG_RL78_ANY_CPU: break;
+	    case E_FLAG_RL78_G10: strcat (buf, ", G10"); break;
+	    case E_FLAG_RL78_G13: strcat (buf, ", G13"); break;
+	    case E_FLAG_RL78_G14: strcat (buf, ", G14"); break;
+	    }
+	  if (e_flags & E_FLAG_RL78_64BIT_DOUBLES)
+	    strcat (buf, ", 64-bit doubles");
+	  break;
+
+	case EM_RX:
+	  if (e_flags & E_FLAG_RX_64BIT_DOUBLES)
+	    strcat (buf, ", 64-bit doubles");
+	  if (e_flags & E_FLAG_RX_DSP)
+	    strcat (buf, ", dsp");
+	  if (e_flags & E_FLAG_RX_PID)
+	    strcat (buf, ", pid");
+	  if (e_flags & E_FLAG_RX_ABI)
+	    strcat (buf, ", RX ABI");
+	  if (e_flags & E_FLAG_RX_SINSNS_SET)
+	    strcat (buf, e_flags & E_FLAG_RX_SINSNS_YES
+		    ? ", uses String instructions" : ", bans String instructions");
+	  if (e_flags & E_FLAG_RX_V2)
+	    strcat (buf, ", V2");
+	  if (e_flags & E_FLAG_RX_V3)
+	    strcat (buf, ", V3");
+	  break;
+
+	case EM_S390:
+	  if (e_flags & EF_S390_HIGH_GPRS)
+	    strcat (buf, ", highgprs");
+	  break;
+
+	case EM_TI_C6000:
+	  if ((e_flags & EF_C6000_REL))
+	    strcat (buf, ", relocatable module");
+	  break;
+
+	case EM_MSP430:
+	  strcat (buf, _(": architecture variant: "));
+	  switch (e_flags & EF_MSP430_MACH)
+	    {
+	    case E_MSP430_MACH_MSP430x11: strcat (buf, "MSP430x11"); break;
+	    case E_MSP430_MACH_MSP430x11x1 : strcat (buf, "MSP430x11x1 "); break;
+	    case E_MSP430_MACH_MSP430x12: strcat (buf, "MSP430x12"); break;
+	    case E_MSP430_MACH_MSP430x13: strcat (buf, "MSP430x13"); break;
+	    case E_MSP430_MACH_MSP430x14: strcat (buf, "MSP430x14"); break;
+	    case E_MSP430_MACH_MSP430x15: strcat (buf, "MSP430x15"); break;
+	    case E_MSP430_MACH_MSP430x16: strcat (buf, "MSP430x16"); break;
+	    case E_MSP430_MACH_MSP430x31: strcat (buf, "MSP430x31"); break;
+	    case E_MSP430_MACH_MSP430x32: strcat (buf, "MSP430x32"); break;
+	    case E_MSP430_MACH_MSP430x33: strcat (buf, "MSP430x33"); break;
+	    case E_MSP430_MACH_MSP430x41: strcat (buf, "MSP430x41"); break;
+	    case E_MSP430_MACH_MSP430x42: strcat (buf, "MSP430x42"); break;
+	    case E_MSP430_MACH_MSP430x43: strcat (buf, "MSP430x43"); break;
+	    case E_MSP430_MACH_MSP430x44: strcat (buf, "MSP430x44"); break;
+	    case E_MSP430_MACH_MSP430X  : strcat (buf, "MSP430X"); break;
+	    default:
+	      strcat (buf, _(": unknown")); break;
+	    }
+
+	  if (e_flags & ~ EF_MSP430_MACH)
+	    strcat (buf, _(": unknown extra flag bits also present"));
+	  break;
+
+	case EM_Z80:
+	  switch (e_flags & EF_Z80_MACH_MSK)
+	    {
+	    case EF_Z80_MACH_Z80: strcat (buf, ", Z80"); break;
+	    case EF_Z80_MACH_Z180: strcat (buf, ", Z180"); break;
+	    case EF_Z80_MACH_R800: strcat (buf, ", R800"); break;
+	    case EF_Z80_MACH_EZ80_Z80: strcat (buf, ", EZ80"); break;
+	    case EF_Z80_MACH_EZ80_ADL: strcat (buf, ", EZ80, ADL"); break;
+	    case EF_Z80_MACH_GBZ80: strcat (buf, ", GBZ80"); break;
+	    case EF_Z80_MACH_Z80N: strcat (buf, ", Z80N"); break;
+	    default:
+	      strcat (buf, _(", unknown")); break;
+	    }
+	  break;
+	}
+    }
+
+  return buf;
+}
+
+static const char *
+get_osabi_name (Filedata * filedata, unsigned int osabi)
+{
+  static char buff[32];
+
+  switch (osabi)
+    {
+    case ELFOSABI_NONE:		return "UNIX - System V";
+    case ELFOSABI_HPUX:		return "UNIX - HP-UX";
+    case ELFOSABI_NETBSD:	return "UNIX - NetBSD";
+    case ELFOSABI_GNU:		return "UNIX - GNU";
+    case ELFOSABI_SOLARIS:	return "UNIX - Solaris";
+    case ELFOSABI_AIX:		return "UNIX - AIX";
+    case ELFOSABI_IRIX:		return "UNIX - IRIX";
+    case ELFOSABI_FREEBSD:	return "UNIX - FreeBSD";
+    case ELFOSABI_TRU64:	return "UNIX - TRU64";
+    case ELFOSABI_MODESTO:	return "Novell - Modesto";
+    case ELFOSABI_OPENBSD:	return "UNIX - OpenBSD";
+    case ELFOSABI_OPENVMS:	return "VMS - OpenVMS";
+    case ELFOSABI_NSK:		return "HP - Non-Stop Kernel";
+    case ELFOSABI_AROS:		return "AROS";
+    case ELFOSABI_FENIXOS:	return "FenixOS";
+    case ELFOSABI_CLOUDABI:	return "Nuxi CloudABI";
+    case ELFOSABI_OPENVOS:	return "Stratus Technologies OpenVOS";
+    default:
+      if (osabi >= 64)
+	switch (filedata->file_header.e_machine)
+	  {
+	  case EM_ARM:
+	    switch (osabi)
+	      {
+	      case ELFOSABI_ARM:	return "ARM";
+	      case ELFOSABI_ARM_FDPIC:	return "ARM FDPIC";
+	      default:
+		break;
+	      }
+	    break;
+
+	  case EM_MSP430:
+	  case EM_MSP430_OLD:
+	  case EM_VISIUM:
+	    switch (osabi)
+	      {
+	      case ELFOSABI_STANDALONE:	return _("Standalone App");
+	      default:
+		break;
+	      }
+	    break;
+
+	  case EM_TI_C6000:
+	    switch (osabi)
+	      {
+	      case ELFOSABI_C6000_ELFABI:	return _("Bare-metal C6000");
+	      case ELFOSABI_C6000_LINUX:	return "Linux C6000";
+	      default:
+		break;
+	      }
+	    break;
+
+	  default:
+	    break;
+	  }
+      snprintf (buff, sizeof (buff), _("<unknown: %x>"), osabi);
+      return buff;
+    }
+}
+
+static const char *
+get_aarch64_segment_type (unsigned long type)
+{
+  switch (type)
+    {
+    case PT_AARCH64_ARCHEXT:  return "AARCH64_ARCHEXT";
+    default:                  return NULL;
+    }
+}
+
+static const char *
+get_arm_segment_type (unsigned long type)
+{
+  switch (type)
+    {
+    case PT_ARM_EXIDX: return "EXIDX";
+    default:           return NULL;
+    }
+}
+
+static const char *
+get_s390_segment_type (unsigned long type)
+{
+  switch (type)
+    {
+    case PT_S390_PGSTE: return "S390_PGSTE";
+    default:            return NULL;
+    }
+}
+
+static const char *
+get_mips_segment_type (unsigned long type)
+{
+  switch (type)
+    {
+    case PT_MIPS_REGINFO:   return "REGINFO";
+    case PT_MIPS_RTPROC:    return "RTPROC";
+    case PT_MIPS_OPTIONS:   return "OPTIONS";
+    case PT_MIPS_ABIFLAGS:  return "ABIFLAGS";
+    default:                return NULL;
+    }
+}
+
+static const char *
+get_parisc_segment_type (unsigned long type)
+{
+  switch (type)
+    {
+    case PT_PARISC_ARCHEXT:	return "PARISC_ARCHEXT";
+    case PT_PARISC_UNWIND:	return "PARISC_UNWIND";
+    case PT_PARISC_WEAKORDER:	return "PARISC_WEAKORDER";
+    default:                    return NULL;
+    }
+}
+
+static const char *
+get_ia64_segment_type (unsigned long type)
+{
+  switch (type)
+    {
+    case PT_IA_64_ARCHEXT:	return "IA_64_ARCHEXT";
+    case PT_IA_64_UNWIND:	return "IA_64_UNWIND";
+    default:                    return NULL;
+    }
+}
+
+static const char *
+get_tic6x_segment_type (unsigned long type)
+{
+  switch (type)
+    {
+    case PT_C6000_PHATTR:  return "C6000_PHATTR";
+    default:               return NULL;
+    }
+}
+
+static const char *
+get_hpux_segment_type (unsigned long type, unsigned e_machine)
+{
+  if (e_machine == EM_PARISC)
+    switch (type)
+      {
+      case PT_HP_TLS:		return "HP_TLS";
+      case PT_HP_CORE_NONE:	return "HP_CORE_NONE";
+      case PT_HP_CORE_VERSION:	return "HP_CORE_VERSION";
+      case PT_HP_CORE_KERNEL:	return "HP_CORE_KERNEL";
+      case PT_HP_CORE_COMM:	return "HP_CORE_COMM";
+      case PT_HP_CORE_PROC:	return "HP_CORE_PROC";
+      case PT_HP_CORE_LOADABLE:	return "HP_CORE_LOADABLE";
+      case PT_HP_CORE_STACK:	return "HP_CORE_STACK";
+      case PT_HP_CORE_SHM:	return "HP_CORE_SHM";
+      case PT_HP_CORE_MMF:	return "HP_CORE_MMF";
+      case PT_HP_PARALLEL:	return "HP_PARALLEL";
+      case PT_HP_FASTBIND:	return "HP_FASTBIND";
+      case PT_HP_OPT_ANNOT:	return "HP_OPT_ANNOT";
+      case PT_HP_HSL_ANNOT:	return "HP_HSL_ANNOT";
+      case PT_HP_STACK:		return "HP_STACK";
+      case PT_HP_CORE_UTSNAME:	return "HP_CORE_UTSNAME";
+      default:			return NULL;
+      }
+
+  if (e_machine == EM_IA_64)
+    switch (type)
+      {
+      case PT_HP_TLS:		 return "HP_TLS";
+      case PT_IA_64_HP_OPT_ANOT: return "HP_OPT_ANNOT";
+      case PT_IA_64_HP_HSL_ANOT: return "HP_HSL_ANNOT";
+      case PT_IA_64_HP_STACK:	 return "HP_STACK";
+      default:			 return NULL;
+      }
+
+  return NULL;
+}
+
+static const char *
+get_solaris_segment_type (unsigned long type)
+{
+  switch (type)
+    {
+    case 0x6464e550: return "PT_SUNW_UNWIND";
+    case 0x6474e550: return "PT_SUNW_EH_FRAME";
+    case 0x6ffffff7: return "PT_LOSUNW";
+    case 0x6ffffffa: return "PT_SUNWBSS";
+    case 0x6ffffffb: return "PT_SUNWSTACK";
+    case 0x6ffffffc: return "PT_SUNWDTRACE";
+    case 0x6ffffffd: return "PT_SUNWCAP";
+    case 0x6fffffff: return "PT_HISUNW";
+    default:         return NULL;
+    }
+}
+
+static const char *
+get_segment_type (Filedata * filedata, unsigned long p_type)
+{
+  static char buff[32];
+
+  switch (p_type)
+    {
+    case PT_NULL:	return "NULL";
+    case PT_LOAD:	return "LOAD";
+    case PT_DYNAMIC:	return "DYNAMIC";
+    case PT_INTERP:	return "INTERP";
+    case PT_NOTE:	return "NOTE";
+    case PT_SHLIB:	return "SHLIB";
+    case PT_PHDR:	return "PHDR";
+    case PT_TLS:	return "TLS";
+    case PT_GNU_EH_FRAME: return "GNU_EH_FRAME";
+    case PT_GNU_STACK:	return "GNU_STACK";
+    case PT_GNU_RELRO:  return "GNU_RELRO";
+    case PT_GNU_PROPERTY: return "GNU_PROPERTY";
+
+    case PT_OPENBSD_RANDOMIZE: return "OPENBSD_RANDOMIZE";
+    case PT_OPENBSD_WXNEEDED: return "OPENBSD_WXNEEDED";
+    case PT_OPENBSD_BOOTDATA: return "OPENBSD_BOOTDATA";
+
+    default:
+      if ((p_type >= PT_LOPROC) && (p_type <= PT_HIPROC))
+	{
+	  const char * result;
+
+	  switch (filedata->file_header.e_machine)
+	    {
+	    case EM_AARCH64:
+	      result = get_aarch64_segment_type (p_type);
+	      break;
+	    case EM_ARM:
+	      result = get_arm_segment_type (p_type);
+	      break;
+	    case EM_MIPS:
+	    case EM_MIPS_RS3_LE:
+	      result = get_mips_segment_type (p_type);
+	      break;
+	    case EM_PARISC:
+	      result = get_parisc_segment_type (p_type);
+	      break;
+	    case EM_IA_64:
+	      result = get_ia64_segment_type (p_type);
+	      break;
+	    case EM_TI_C6000:
+	      result = get_tic6x_segment_type (p_type);
+	      break;
+	    case EM_S390:
+	    case EM_S390_OLD:
+	      result = get_s390_segment_type (p_type);
+	      break;
+	    default:
+	      result = NULL;
+	      break;
+	    }
+
+	  if (result != NULL)
+	    return result;
+
+	  sprintf (buff, "LOPROC+%#lx", p_type - PT_LOPROC);
+	}
+      else if ((p_type >= PT_LOOS) && (p_type <= PT_HIOS))
+	{
+	  const char * result = NULL;
+
+	  switch (filedata->file_header.e_ident[EI_OSABI])
+	    {
+	    case ELFOSABI_GNU:
+	    case ELFOSABI_FREEBSD:
+	      if (p_type >= PT_GNU_MBIND_LO && p_type <= PT_GNU_MBIND_HI)
+		{
+		  sprintf (buff, "GNU_MBIND+%#lx", p_type - PT_GNU_MBIND_LO);
+		  result = buff;
+		}
+	      break;
+	    case ELFOSABI_HPUX:
+	      result = get_hpux_segment_type (p_type,
+					      filedata->file_header.e_machine);
+	      break;
+	    case ELFOSABI_SOLARIS:
+	      result = get_solaris_segment_type (p_type);
+	      break;
+	    default:
+	      break;
+	    }
+	  if (result != NULL)
+	    return result;
+
+	  sprintf (buff, "LOOS+%#lx", p_type - PT_LOOS);
+	}
+      else
+	snprintf (buff, sizeof (buff), _("<unknown>: %lx"), p_type);
+
+      return buff;
+    }
+}
+
+static const char *
+get_arc_section_type_name (unsigned int sh_type)
+{
+  switch (sh_type)
+    {
+    case SHT_ARC_ATTRIBUTES:      return "ARC_ATTRIBUTES";
+    default:
+      break;
+    }
+  return NULL;
+}
+
+static const char *
+get_mips_section_type_name (unsigned int sh_type)
+{
+  switch (sh_type)
+    {
+    case SHT_MIPS_LIBLIST:	 return "MIPS_LIBLIST";
+    case SHT_MIPS_MSYM:		 return "MIPS_MSYM";
+    case SHT_MIPS_CONFLICT:	 return "MIPS_CONFLICT";
+    case SHT_MIPS_GPTAB:	 return "MIPS_GPTAB";
+    case SHT_MIPS_UCODE:	 return "MIPS_UCODE";
+    case SHT_MIPS_DEBUG:	 return "MIPS_DEBUG";
+    case SHT_MIPS_REGINFO:	 return "MIPS_REGINFO";
+    case SHT_MIPS_PACKAGE:	 return "MIPS_PACKAGE";
+    case SHT_MIPS_PACKSYM:	 return "MIPS_PACKSYM";
+    case SHT_MIPS_RELD:		 return "MIPS_RELD";
+    case SHT_MIPS_IFACE:	 return "MIPS_IFACE";
+    case SHT_MIPS_CONTENT:	 return "MIPS_CONTENT";
+    case SHT_MIPS_OPTIONS:	 return "MIPS_OPTIONS";
+    case SHT_MIPS_SHDR:		 return "MIPS_SHDR";
+    case SHT_MIPS_FDESC:	 return "MIPS_FDESC";
+    case SHT_MIPS_EXTSYM:	 return "MIPS_EXTSYM";
+    case SHT_MIPS_DENSE:	 return "MIPS_DENSE";
+    case SHT_MIPS_PDESC:	 return "MIPS_PDESC";
+    case SHT_MIPS_LOCSYM:	 return "MIPS_LOCSYM";
+    case SHT_MIPS_AUXSYM:	 return "MIPS_AUXSYM";
+    case SHT_MIPS_OPTSYM:	 return "MIPS_OPTSYM";
+    case SHT_MIPS_LOCSTR:	 return "MIPS_LOCSTR";
+    case SHT_MIPS_LINE:		 return "MIPS_LINE";
+    case SHT_MIPS_RFDESC:	 return "MIPS_RFDESC";
+    case SHT_MIPS_DELTASYM:	 return "MIPS_DELTASYM";
+    case SHT_MIPS_DELTAINST:	 return "MIPS_DELTAINST";
+    case SHT_MIPS_DELTACLASS:	 return "MIPS_DELTACLASS";
+    case SHT_MIPS_DWARF:	 return "MIPS_DWARF";
+    case SHT_MIPS_DELTADECL:	 return "MIPS_DELTADECL";
+    case SHT_MIPS_SYMBOL_LIB:	 return "MIPS_SYMBOL_LIB";
+    case SHT_MIPS_EVENTS:	 return "MIPS_EVENTS";
+    case SHT_MIPS_TRANSLATE:	 return "MIPS_TRANSLATE";
+    case SHT_MIPS_PIXIE:	 return "MIPS_PIXIE";
+    case SHT_MIPS_XLATE:	 return "MIPS_XLATE";
+    case SHT_MIPS_XLATE_DEBUG:	 return "MIPS_XLATE_DEBUG";
+    case SHT_MIPS_WHIRL:	 return "MIPS_WHIRL";
+    case SHT_MIPS_EH_REGION:	 return "MIPS_EH_REGION";
+    case SHT_MIPS_XLATE_OLD:	 return "MIPS_XLATE_OLD";
+    case SHT_MIPS_PDR_EXCEPTION: return "MIPS_PDR_EXCEPTION";
+    case SHT_MIPS_ABIFLAGS:	 return "MIPS_ABIFLAGS";
+    case SHT_MIPS_XHASH:	 return "MIPS_XHASH";
+    default:
+      break;
+    }
+  return NULL;
+}
+
+static const char *
+get_parisc_section_type_name (unsigned int sh_type)
+{
+  switch (sh_type)
+    {
+    case SHT_PARISC_EXT:	return "PARISC_EXT";
+    case SHT_PARISC_UNWIND:	return "PARISC_UNWIND";
+    case SHT_PARISC_DOC:	return "PARISC_DOC";
+    case SHT_PARISC_ANNOT:	return "PARISC_ANNOT";
+    case SHT_PARISC_SYMEXTN:	return "PARISC_SYMEXTN";
+    case SHT_PARISC_STUBS:	return "PARISC_STUBS";
+    case SHT_PARISC_DLKM:	return "PARISC_DLKM";
+    default:             	return NULL;
+    }
+}
+
+static const char *
+get_ia64_section_type_name (Filedata * filedata, unsigned int sh_type)
+{
+  /* If the top 8 bits are 0x78 the next 8 are the os/abi ID.  */
+  if ((sh_type & 0xFF000000) == SHT_IA_64_LOPSREG)
+    return get_osabi_name (filedata, (sh_type & 0x00FF0000) >> 16);
+
+  switch (sh_type)
+    {
+    case SHT_IA_64_EXT:		       return "IA_64_EXT";
+    case SHT_IA_64_UNWIND:	       return "IA_64_UNWIND";
+    case SHT_IA_64_PRIORITY_INIT:      return "IA_64_PRIORITY_INIT";
+    case SHT_IA_64_VMS_TRACE:          return "VMS_TRACE";
+    case SHT_IA_64_VMS_TIE_SIGNATURES: return "VMS_TIE_SIGNATURES";
+    case SHT_IA_64_VMS_DEBUG:          return "VMS_DEBUG";
+    case SHT_IA_64_VMS_DEBUG_STR:      return "VMS_DEBUG_STR";
+    case SHT_IA_64_VMS_LINKAGES:       return "VMS_LINKAGES";
+    case SHT_IA_64_VMS_SYMBOL_VECTOR:  return "VMS_SYMBOL_VECTOR";
+    case SHT_IA_64_VMS_FIXUP:          return "VMS_FIXUP";
+    default:
+      break;
+    }
+  return NULL;
+}
+
+static const char *
+get_x86_64_section_type_name (unsigned int sh_type)
+{
+  switch (sh_type)
+    {
+    case SHT_X86_64_UNWIND:	return "X86_64_UNWIND";
+    default:			return NULL;
+    }
+}
+
+static const char *
+get_aarch64_section_type_name (unsigned int sh_type)
+{
+  switch (sh_type)
+    {
+    case SHT_AARCH64_ATTRIBUTES: return "AARCH64_ATTRIBUTES";
+    default:			 return NULL;
+    }
+}
+
+static const char *
+get_arm_section_type_name (unsigned int sh_type)
+{
+  switch (sh_type)
+    {
+    case SHT_ARM_EXIDX:           return "ARM_EXIDX";
+    case SHT_ARM_PREEMPTMAP:      return "ARM_PREEMPTMAP";
+    case SHT_ARM_ATTRIBUTES:      return "ARM_ATTRIBUTES";
+    case SHT_ARM_DEBUGOVERLAY:    return "ARM_DEBUGOVERLAY";
+    case SHT_ARM_OVERLAYSECTION:  return "ARM_OVERLAYSECTION";
+    default:			  return NULL;
+    }
+}
+
+static const char *
+get_tic6x_section_type_name (unsigned int sh_type)
+{
+  switch (sh_type)
+    {
+    case SHT_C6000_UNWIND:      return "C6000_UNWIND";
+    case SHT_C6000_PREEMPTMAP:  return "C6000_PREEMPTMAP";
+    case SHT_C6000_ATTRIBUTES:  return "C6000_ATTRIBUTES";
+    case SHT_TI_ICODE:          return "TI_ICODE";
+    case SHT_TI_XREF:           return "TI_XREF";
+    case SHT_TI_HANDLER:        return "TI_HANDLER";
+    case SHT_TI_INITINFO:       return "TI_INITINFO";
+    case SHT_TI_PHATTRS:        return "TI_PHATTRS";
+    default:                    return NULL;
+    }
+}
+
+static const char *
+get_msp430_section_type_name (unsigned int sh_type)
+{
+  switch (sh_type)
+    {
+    case SHT_MSP430_SEC_FLAGS:    return "MSP430_SEC_FLAGS";
+    case SHT_MSP430_SYM_ALIASES:  return "MSP430_SYM_ALIASES";
+    case SHT_MSP430_ATTRIBUTES:   return "MSP430_ATTRIBUTES";
+    default:                      return NULL;
+    }
+}
+
+static const char *
+get_nfp_section_type_name (unsigned int sh_type)
+{
+  switch (sh_type)
+    {
+    case SHT_NFP_MECONFIG:	return "NFP_MECONFIG";
+    case SHT_NFP_INITREG:	return "NFP_INITREG";
+    case SHT_NFP_UDEBUG:	return "NFP_UDEBUG";
+    default:			return NULL;
+    }
+}
+
+static const char *
+get_v850_section_type_name (unsigned int sh_type)
+{
+  switch (sh_type)
+    {
+    case SHT_V850_SCOMMON:  return "V850 Small Common";
+    case SHT_V850_TCOMMON:  return "V850 Tiny Common";
+    case SHT_V850_ZCOMMON:  return "V850 Zero Common";
+    case SHT_RENESAS_IOP:   return "RENESAS IOP";
+    case SHT_RENESAS_INFO:  return "RENESAS INFO";
+    default:                return NULL;
+    }
+}
+
+static const char *
+get_riscv_section_type_name (unsigned int sh_type)
+{
+  switch (sh_type)
+    {
+    case SHT_RISCV_ATTRIBUTES:  return "RISCV_ATTRIBUTES";
+    default: return NULL;
+    }
+}
+
+static const char *
+get_csky_section_type_name (unsigned int sh_type)
+{
+  switch (sh_type)
+    {
+    case SHT_CSKY_ATTRIBUTES:  return "CSKY_ATTRIBUTES";
+    default:  return NULL;
+    }
+}
+
+static const char *
+get_section_type_name (Filedata * filedata, unsigned int sh_type)
+{
+  static char buff[32];
+  const char * result;
+
+  switch (sh_type)
+    {
+    case SHT_NULL:		return "NULL";
+    case SHT_PROGBITS:		return "PROGBITS";
+    case SHT_SYMTAB:		return "SYMTAB";
+    case SHT_STRTAB:		return "STRTAB";
+    case SHT_RELA:		return "RELA";
+    case SHT_HASH:		return "HASH";
+    case SHT_DYNAMIC:		return "DYNAMIC";
+    case SHT_NOTE:		return "NOTE";
+    case SHT_NOBITS:		return "NOBITS";
+    case SHT_REL:		return "REL";
+    case SHT_SHLIB:		return "SHLIB";
+    case SHT_DYNSYM:		return "DYNSYM";
+    case SHT_INIT_ARRAY:	return "INIT_ARRAY";
+    case SHT_FINI_ARRAY:	return "FINI_ARRAY";
+    case SHT_PREINIT_ARRAY:	return "PREINIT_ARRAY";
+    case SHT_GNU_HASH:		return "GNU_HASH";
+    case SHT_GROUP:		return "GROUP";
+    case SHT_SYMTAB_SHNDX:	return "SYMTAB SECTION INDICES";
+    case SHT_GNU_verdef:	return "VERDEF";
+    case SHT_GNU_verneed:	return "VERNEED";
+    case SHT_GNU_versym:	return "VERSYM";
+    case 0x6ffffff0:		return "VERSYM";
+    case 0x6ffffffc:		return "VERDEF";
+    case 0x7ffffffd:		return "AUXILIARY";
+    case 0x7fffffff:		return "FILTER";
+    case SHT_GNU_LIBLIST:	return "GNU_LIBLIST";
+
+    default:
+      if ((sh_type >= SHT_LOPROC) && (sh_type <= SHT_HIPROC))
+	{
+	  switch (filedata->file_header.e_machine)
+	    {
+	    case EM_ARC:
+	    case EM_ARC_COMPACT:
+	    case EM_ARC_COMPACT2:
+	      result = get_arc_section_type_name (sh_type);
+	      break;
+	    case EM_MIPS:
+	    case EM_MIPS_RS3_LE:
+	      result = get_mips_section_type_name (sh_type);
+	      break;
+	    case EM_PARISC:
+	      result = get_parisc_section_type_name (sh_type);
+	      break;
+	    case EM_IA_64:
+	      result = get_ia64_section_type_name (filedata, sh_type);
+	      break;
+	    case EM_X86_64:
+	    case EM_L1OM:
+	    case EM_K1OM:
+	      result = get_x86_64_section_type_name (sh_type);
+	      break;
+	    case EM_AARCH64:
+	      result = get_aarch64_section_type_name (sh_type);
+	      break;
+	    case EM_ARM:
+	      result = get_arm_section_type_name (sh_type);
+	      break;
+	    case EM_TI_C6000:
+	      result = get_tic6x_section_type_name (sh_type);
+	      break;
+	    case EM_MSP430:
+	      result = get_msp430_section_type_name (sh_type);
+	      break;
+	    case EM_NFP:
+	      result = get_nfp_section_type_name (sh_type);
+	      break;
+	    case EM_V800:
+	    case EM_V850:
+	    case EM_CYGNUS_V850:
+	      result = get_v850_section_type_name (sh_type);
+	      break;
+	    case EM_RISCV:
+	      result = get_riscv_section_type_name (sh_type);
+	      break;
+	    case EM_CSKY:
+	      result = get_csky_section_type_name (sh_type);
+	      break;
+	    default:
+	      result = NULL;
+	      break;
+	    }
+
+	  if (result != NULL)
+	    return result;
+
+	  sprintf (buff, "LOPROC+%#x", sh_type - SHT_LOPROC);
+	}
+      else if ((sh_type >= SHT_LOOS) && (sh_type <= SHT_HIOS))
+	{
+	  switch (filedata->file_header.e_machine)
+	    {
+	    case EM_IA_64:
+	      result = get_ia64_section_type_name (filedata, sh_type);
+	      break;
+	    default:
+	      if (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_SOLARIS)
+		result = get_solaris_section_type (sh_type);
+	      else
+		{
+		  switch (sh_type)
+		    {
+		    case SHT_GNU_INCREMENTAL_INPUTS: result = "GNU_INCREMENTAL_INPUTS"; break;
+		    case SHT_GNU_ATTRIBUTES: result = "GNU_ATTRIBUTES"; break;
+		    case SHT_GNU_HASH: result = "GNU_HASH"; break;
+		    case SHT_GNU_LIBLIST: result = "GNU_LIBLIST"; break;
+		    default:
+		      result = NULL;
+		      break;
+		    }
+		}
+	      break;
+	    }
+
+	  if (result != NULL)
+	    return result;
+
+	  sprintf (buff, "LOOS+%#x", sh_type - SHT_LOOS);
+	}
+      else if ((sh_type >= SHT_LOUSER) && (sh_type <= SHT_HIUSER))
+	{
+	  switch (filedata->file_header.e_machine)
+	    {
+	    case EM_V800:
+	    case EM_V850:
+	    case EM_CYGNUS_V850:
+	      result = get_v850_section_type_name (sh_type);
+	      break;
+	    default:
+	      result = NULL;
+	      break;
+	    }
+
+	  if (result != NULL)
+	    return result;
+
+	  sprintf (buff, "LOUSER+%#x", sh_type - SHT_LOUSER);
+	}
+      else
+	/* This message is probably going to be displayed in a 15
+	   character wide field, so put the hex value first.  */
+	snprintf (buff, sizeof (buff), _("%08x: <unknown>"), sh_type);
+
+      return buff;
+    }
+}
+
+enum long_option_values
+{
+  OPTION_DEBUG_DUMP = 512,
+  OPTION_DYN_SYMS,
+  OPTION_LTO_SYMS,
+  OPTION_DWARF_DEPTH,
+  OPTION_DWARF_START,
+  OPTION_DWARF_CHECK,
+  OPTION_CTF_DUMP,
+  OPTION_CTF_PARENT,
+  OPTION_CTF_SYMBOLS,
+  OPTION_CTF_STRINGS,
+  OPTION_WITH_SYMBOL_VERSIONS,
+  OPTION_RECURSE_LIMIT,
+  OPTION_NO_RECURSE_LIMIT,
+  OPTION_NO_DEMANGLING,
+  OPTION_SYM_BASE
+};
+
+static struct option options[] =
+{
+ /* Note - This table is alpha-sorted on the 'val'
+    field in order to make adding new options easier.  */
+  {"arch-specific",    no_argument, 0, 'A'},
+  {"all",	       no_argument, 0, 'a'},
+  {"demangle",         optional_argument, 0, 'C'},
+  {"archive-index",    no_argument, 0, 'c'},
+  {"use-dynamic",      no_argument, 0, 'D'},
+  {"dynamic",	       no_argument, 0, 'd'},
+  {"headers",	       no_argument, 0, 'e'},
+  {"section-groups",   no_argument, 0, 'g'},
+  {"help",	       no_argument, 0, 'H'},
+  {"file-header",      no_argument, 0, 'h'},
+  {"histogram",	       no_argument, 0, 'I'},
+  {"lint",             no_argument, 0, 'L'},
+  {"enable-checks",    no_argument, 0, 'L'},
+  {"program-headers",  no_argument, 0, 'l'},
+  {"segments",	       no_argument, 0, 'l'},
+  {"full-section-name",no_argument, 0, 'N'},
+  {"notes",	       no_argument, 0, 'n'},
+  {"process-links",    no_argument, 0, 'P'},
+  {"string-dump",      required_argument, 0, 'p'},
+  {"relocated-dump",   required_argument, 0, 'R'},
+  {"relocs",	       no_argument, 0, 'r'},
+  {"section-headers",  no_argument, 0, 'S'},
+  {"sections",	       no_argument, 0, 'S'},
+  {"symbols",	       no_argument, 0, 's'},
+  {"syms",	       no_argument, 0, 's'},
+  {"silent-truncation",no_argument, 0, 'T'},
+  {"section-details",  no_argument, 0, 't'},
+  {"unwind",	       no_argument, 0, 'u'},
+  {"version-info",     no_argument, 0, 'V'},
+  {"version",	       no_argument, 0, 'v'},
+  {"wide",	       no_argument, 0, 'W'},
+  {"hex-dump",	       required_argument, 0, 'x'},
+  {"decompress",       no_argument, 0, 'z'},
+
+  {"no-demangle",      no_argument, 0, OPTION_NO_DEMANGLING},
+  {"recurse-limit",    no_argument, NULL, OPTION_RECURSE_LIMIT},
+  {"no-recurse-limit", no_argument, NULL, OPTION_NO_RECURSE_LIMIT},
+  {"no-recursion-limit", no_argument, NULL, OPTION_NO_RECURSE_LIMIT},
+  {"dyn-syms",	       no_argument, 0, OPTION_DYN_SYMS},
+  {"lto-syms",         no_argument, 0, OPTION_LTO_SYMS},
+  {"debug-dump",       optional_argument, 0, OPTION_DEBUG_DUMP},
+  {"dwarf-depth",      required_argument, 0, OPTION_DWARF_DEPTH},
+  {"dwarf-start",      required_argument, 0, OPTION_DWARF_START},
+  {"dwarf-check",      no_argument, 0, OPTION_DWARF_CHECK},
+#ifdef ENABLE_LIBCTF
+  {"ctf",	       required_argument, 0, OPTION_CTF_DUMP},
+  {"ctf-symbols",      required_argument, 0, OPTION_CTF_SYMBOLS},
+  {"ctf-strings",      required_argument, 0, OPTION_CTF_STRINGS},
+  {"ctf-parent",       required_argument, 0, OPTION_CTF_PARENT},
+#endif
+  {"sym-base",	       optional_argument, 0, OPTION_SYM_BASE},
+
+  {0,		       no_argument, 0, 0}
+};
+
+static void
+usage (FILE * stream)
+{
+  fprintf (stream, _("Usage: readelf <option(s)> elf-file(s)\n"));
+  fprintf (stream, _(" Display information about the contents of ELF format files\n"));
+  fprintf (stream, _(" Options are:\n"));
+  fprintf (stream, _("\
+  -a --all               Equivalent to: -h -l -S -s -r -d -V -A -I\n"));
+  fprintf (stream, _("\
+  -h --file-header       Display the ELF file header\n"));
+  fprintf (stream, _("\
+  -l --program-headers   Display the program headers\n"));
+  fprintf (stream, _("\
+     --segments          An alias for --program-headers\n"));
+  fprintf (stream, _("\
+  -S --section-headers   Display the sections' header\n"));
+  fprintf (stream, _("\
+     --sections          An alias for --section-headers\n"));
+  fprintf (stream, _("\
+  -g --section-groups    Display the section groups\n"));
+  fprintf (stream, _("\
+  -t --section-details   Display the section details\n"));
+  fprintf (stream, _("\
+  -e --headers           Equivalent to: -h -l -S\n"));
+  fprintf (stream, _("\
+  -s --syms              Display the symbol table\n"));
+  fprintf (stream, _("\
+     --symbols           An alias for --syms\n"));
+  fprintf (stream, _("\
+     --dyn-syms          Display the dynamic symbol table\n"));
+  fprintf (stream, _("\
+     --lto-syms          Display LTO symbol tables\n"));
+  fprintf (stream, _("\
+     --sym-base=[0|8|10|16] \n\
+                         Force base for symbol sizes.  The options are \n\
+                         mixed (the default), octal, decimal, hexadecimal.\n"));
+  fprintf (stream, _("\
+  -C --demangle[=STYLE]  Decode low-level symbol names into user-level names\n\
+                          The STYLE, if specified, can be `auto' (the default),\n\
+                          `gnu', `lucid', `arm', `hp', `edg', `gnu-v3', `java'\n\
+                          or `gnat'\n"));
+  fprintf (stream, _("\
+     --no-demangle       Do not demangle low-level symbol names.  (default)\n"));
+  fprintf (stream, _("\
+     --recurse-limit     Enable a demangling recursion limit.  (default)\n"));
+  fprintf (stream, _("\
+     --no-recurse-limit  Disable a demangling recursion limit\n"));
+  fprintf (stream, _("\
+  -n --notes             Display the core notes (if present)\n"));
+  fprintf (stream, _("\
+  -r --relocs            Display the relocations (if present)\n"));
+  fprintf (stream, _("\
+  -u --unwind            Display the unwind info (if present)\n"));
+  fprintf (stream, _("\
+  -d --dynamic           Display the dynamic section (if present)\n"));
+  fprintf (stream, _("\
+  -V --version-info      Display the version sections (if present)\n"));
+  fprintf (stream, _("\
+  -A --arch-specific     Display architecture specific information (if any)\n"));
+  fprintf (stream, _("\
+  -c --archive-index     Display the symbol/file index in an archive\n"));
+  fprintf (stream, _("\
+  -D --use-dynamic       Use the dynamic section info when displaying symbols\n"));
+  fprintf (stream, _("\
+  -L --lint|--enable-checks\n\
+                         Display warning messages for possible problems\n"));
+  fprintf (stream, _("\
+  -x --hex-dump=<number|name>\n\
+                         Dump the contents of section <number|name> as bytes\n"));
+  fprintf (stream, _("\
+  -p --string-dump=<number|name>\n\
+                         Dump the contents of section <number|name> as strings\n"));
+  fprintf (stream, _("\
+  -R --relocated-dump=<number|name>\n\
+                         Dump the relocated contents of section <number|name>\n"));
+  fprintf (stream, _("\
+  -z --decompress        Decompress section before dumping it\n"));
+  fprintf (stream, _("\
+  -w --debug-dump[a/=abbrev, A/=addr, r/=aranges, c/=cu_index, L/=decodedline,\n\
+                  f/=frames, F/=frames-interp, g/=gdb_index, i/=info, o/=loc,\n\
+                  m/=macro, p/=pubnames, t/=pubtypes, R/=Ranges, l/=rawline,\n\
+                  s/=str, O/=str-offsets, u/=trace_abbrev, T/=trace_aranges,\n\
+                  U/=trace_info]\n\
+                         Display the contents of DWARF debug sections\n"));
+  fprintf (stream, _("\
+  -wk --debug-dump=links Display the contents of sections that link to separate\n\
+                          debuginfo files\n"));
+  fprintf (stream, _("\
+  -P --process-links     Display the contents of non-debug sections in separate\n\
+                          debuginfo files.  (Implies -wK)\n"));
+#if DEFAULT_FOR_FOLLOW_LINKS
+  fprintf (stream, _("\
+  -wK --debug-dump=follow-links\n\
+                         Follow links to separate debug info files (default)\n"));
+  fprintf (stream, _("\
+  -wN --debug-dump=no-follow-links\n\
+                         Do not follow links to separate debug info files\n"));
+#else
+  fprintf (stream, _("\
+  -wK --debug-dump=follow-links\n\
+                         Follow links to separate debug info files\n"));
+  fprintf (stream, _("\
+  -wN --debug-dump=no-follow-links\n\
+                         Do not follow links to separate debug info files\n\
+                          (default)\n"));
+#endif
+  fprintf (stream, _("\
+  --dwarf-depth=N        Do not display DIEs at depth N or greater\n"));
+  fprintf (stream, _("\
+  --dwarf-start=N        Display DIEs starting at offset N\n"));
+#ifdef ENABLE_LIBCTF
+  fprintf (stream, _("\
+  --ctf=<number|name>    Display CTF info from section <number|name>\n"));
+  fprintf (stream, _("\
+  --ctf-parent=<number|name>\n\
+                         Use section <number|name> as the CTF parent\n"));
+  fprintf (stream, _("\
+  --ctf-symbols=<number|name>\n\
+                         Use section <number|name> as the CTF external symtab\n"));
+  fprintf (stream, _("\
+  --ctf-strings=<number|name>\n\
+                         Use section <number|name> as the CTF external strtab\n"));
+#endif
+
+#ifdef SUPPORT_DISASSEMBLY
+  fprintf (stream, _("\
+  -i --instruction-dump=<number|name>\n\
+                         Disassemble the contents of section <number|name>\n"));
+#endif
+  fprintf (stream, _("\
+  -I --histogram         Display histogram of bucket list lengths\n"));
+  fprintf (stream, _("\
+  -W --wide              Allow output width to exceed 80 characters\n"));
+  fprintf (stream, _("\
+  -T --silent-truncation If a symbol name is truncated, do not add [...] suffix\n"));
+  fprintf (stream, _("\
+  @<file>                Read options from <file>\n"));
+  fprintf (stream, _("\
+  -H --help              Display this information\n"));
+  fprintf (stream, _("\
+  -v --version           Display the version number of readelf\n"));
+
+  if (REPORT_BUGS_TO[0] && stream == stdout)
+    fprintf (stdout, _("Report bugs to %s\n"), REPORT_BUGS_TO);
+
+  exit (stream == stdout ? 0 : 1);
+}
+
+/* Record the fact that the user wants the contents of section number
+   SECTION to be displayed using the method(s) encoded as flags bits
+   in TYPE.  Note, TYPE can be zero if we are creating the array for
+   the first time.  */
+
+static void
+request_dump_bynumber (struct dump_data *dumpdata,
+		       unsigned int section, dump_type type)
+{
+  if (section >= dumpdata->num_dump_sects)
+    {
+      dump_type * new_dump_sects;
+
+      new_dump_sects = (dump_type *) calloc (section + 1,
+                                             sizeof (* new_dump_sects));
+
+      if (new_dump_sects == NULL)
+	error (_("Out of memory allocating dump request table.\n"));
+      else
+	{
+	  if (dumpdata->dump_sects)
+	    {
+	      /* Copy current flag settings.  */
+	      memcpy (new_dump_sects, dumpdata->dump_sects,
+		      dumpdata->num_dump_sects * sizeof (* new_dump_sects));
+
+	      free (dumpdata->dump_sects);
+	    }
+
+	  dumpdata->dump_sects = new_dump_sects;
+	  dumpdata->num_dump_sects = section + 1;
+	}
+    }
+
+  if (dumpdata->dump_sects)
+    dumpdata->dump_sects[section] |= type;
+}
+
+/* Request a dump by section name.  */
+
+static void
+request_dump_byname (const char * section, dump_type type)
+{
+  struct dump_list_entry * new_request;
+
+  new_request = (struct dump_list_entry *)
+      malloc (sizeof (struct dump_list_entry));
+  if (!new_request)
+    error (_("Out of memory allocating dump request table.\n"));
+
+  new_request->name = strdup (section);
+  if (!new_request->name)
+    error (_("Out of memory allocating dump request table.\n"));
+
+  new_request->type = type;
+
+  new_request->next = dump_sects_byname;
+  dump_sects_byname = new_request;
+}
+
+static inline void
+request_dump (struct dump_data *dumpdata, dump_type type)
+{
+  int section;
+  char * cp;
+
+  do_dump = true;
+  section = strtoul (optarg, & cp, 0);
+
+  if (! *cp && section >= 0)
+    request_dump_bynumber (dumpdata, section, type);
+  else
+    request_dump_byname (optarg, type);
+}
+
+static void
+parse_args (struct dump_data *dumpdata, int argc, char ** argv)
+{
+  int c;
+
+  if (argc < 2)
+    usage (stderr);
+
+  while ((c = getopt_long
+	  (argc, argv, "ACDHILNPR:STVWacdeghi:lnp:rstuvw::x:z", options, NULL)) != EOF)
+    {
+      switch (c)
+	{
+	case 0:
+	  /* Long options.  */
+	  break;
+	case 'H':
+	  usage (stdout);
+	  break;
+
+	case 'a':
+	  do_syms = true;
+	  do_reloc = true;
+	  do_unwind = true;
+	  do_dynamic = true;
+	  do_header = true;
+	  do_sections = true;
+	  do_section_groups = true;
+	  do_segments = true;
+	  do_version = true;
+	  do_histogram = true;
+	  do_arch = true;
+	  do_notes = true;
+	  break;
+
+	case 'g':
+	  do_section_groups = true;
+	  break;
+	case 't':
+	case 'N':
+	  do_sections = true;
+	  do_section_details = true;
+	  break;
+	case 'e':
+	  do_header = true;
+	  do_sections = true;
+	  do_segments = true;
+	  break;
+	case 'A':
+	  do_arch = true;
+	  break;
+	case 'D':
+	  do_using_dynamic = true;
+	  break;
+	case 'r':
+	  do_reloc = true;
+	  break;
+	case 'u':
+	  do_unwind = true;
+	  break;
+	case 'h':
+	  do_header = true;
+	  break;
+	case 'l':
+	  do_segments = true;
+	  break;
+	case 's':
+	  do_syms = true;
+	  break;
+	case 'S':
+	  do_sections = true;
+	  break;
+	case 'd':
+	  do_dynamic = true;
+	  break;
+	case 'I':
+	  do_histogram = true;
+	  break;
+	case 'n':
+	  do_notes = true;
+	  break;
+	case 'c':
+	  do_archive_index = true;
+	  break;
+	case 'L':
+	  do_checks = true;
+	  break;
+	case 'P':
+	  process_links = true;
+	  do_follow_links = true;
+	  break;
+	case 'x':
+	  request_dump (dumpdata, HEX_DUMP);
+	  break;
+	case 'p':
+	  request_dump (dumpdata, STRING_DUMP);
+	  break;
+	case 'R':
+	  request_dump (dumpdata, RELOC_DUMP);
+	  break;
+	case 'z':
+	  decompress_dumps = true;
+	  break;
+	case 'w':
+	  do_dump = true;
+	  if (optarg == NULL)
+	    {
+	      do_debugging = true;
+	      dwarf_select_sections_all ();
+	    }
+	  else
+	    {
+	      do_debugging = false;
+	      dwarf_select_sections_by_letters (optarg);
+	    }
+	  break;
+	case OPTION_DEBUG_DUMP:
+	  do_dump = true;
+	  if (optarg == NULL)
+	    {
+	      do_debugging = true;
+	      dwarf_select_sections_all ();
+	    }
+	  else
+	    {
+	      do_debugging = false;
+	      dwarf_select_sections_by_names (optarg);
+	    }
+	  break;
+	case OPTION_DWARF_DEPTH:
+	  {
+	    char *cp;
+
+	    dwarf_cutoff_level = strtoul (optarg, & cp, 0);
+	  }
+	  break;
+	case OPTION_DWARF_START:
+	  {
+	    char *cp;
+
+	    dwarf_start_die = strtoul (optarg, & cp, 0);
+	  }
+	  break;
+	case OPTION_DWARF_CHECK:
+	  dwarf_check = true;
+	  break;
+	case OPTION_CTF_DUMP:
+	  do_ctf = true;
+	  request_dump (dumpdata, CTF_DUMP);
+	  break;
+	case OPTION_CTF_SYMBOLS:
+	  free (dump_ctf_symtab_name);
+	  dump_ctf_symtab_name = strdup (optarg);
+	  break;
+	case OPTION_CTF_STRINGS:
+	  free (dump_ctf_strtab_name);
+	  dump_ctf_strtab_name = strdup (optarg);
+	  break;
+	case OPTION_CTF_PARENT:
+	  free (dump_ctf_parent_name);
+	  dump_ctf_parent_name = strdup (optarg);
+	  break;
+	case OPTION_DYN_SYMS:
+	  do_dyn_syms = true;
+	  break;
+	case OPTION_LTO_SYMS:
+	  do_lto_syms = true;
+	  break;
+#ifdef SUPPORT_DISASSEMBLY
+	case 'i':
+	  request_dump (dumpdata, DISASS_DUMP);
+	  break;
+#endif
+	case 'v':
+	  print_version (program_name);
+	  break;
+	case 'V':
+	  do_version = true;
+	  break;
+	case 'W':
+	  do_wide = true;
+	  break;
+	case 'T':
+	  do_not_show_symbol_truncation = true;
+	  break;
+	case 'C':
+	  do_demangle = true;
+	  if (optarg != NULL)
+	    {
+	      enum demangling_styles style;
+
+	      style = cplus_demangle_name_to_style (optarg);
+	      if (style == unknown_demangling)
+		error (_("unknown demangling style `%s'"), optarg);
+
+	      cplus_demangle_set_style (style);
+	    }
+	  break;
+	case OPTION_NO_DEMANGLING:
+	  do_demangle = false;
+	  break;
+	case OPTION_RECURSE_LIMIT:
+	  demangle_flags &= ~ DMGL_NO_RECURSE_LIMIT;
+	  break;
+	case OPTION_NO_RECURSE_LIMIT:
+	  demangle_flags |= DMGL_NO_RECURSE_LIMIT;
+	  break;
+	case OPTION_WITH_SYMBOL_VERSIONS:
+	  /* Ignored for backward compatibility.  */
+	  break;
+
+	case OPTION_SYM_BASE:
+	  sym_base = 0;
+	  if (optarg != NULL)
+	    {
+	      sym_base = strtoul (optarg, NULL, 0);
+	      switch (sym_base)
+		{
+		  case 0:
+		  case 8:
+		  case 10:
+		  case 16:
+		    break;
+
+		  default:
+		    sym_base = 0;
+		    break;
+		}
+	    }
+	  break;
+
+	default:
+	  /* xgettext:c-format */
+	  error (_("Invalid option '-%c'\n"), c);
+	  /* Fall through.  */
+	case '?':
+	  usage (stderr);
+	}
+    }
+
+  if (!do_dynamic && !do_syms && !do_reloc && !do_unwind && !do_sections
+      && !do_segments && !do_header && !do_dump && !do_version
+      && !do_histogram && !do_debugging && !do_arch && !do_notes
+      && !do_section_groups && !do_archive_index
+      && !do_dyn_syms && !do_lto_syms)
+    {
+      if (do_checks)
+	{
+	  check_all = true;
+	  do_dynamic = do_syms = do_reloc = do_unwind = do_sections = true;
+	  do_segments = do_header = do_dump = do_version = true;
+	  do_histogram = do_debugging = do_arch = do_notes = true;
+	  do_section_groups = do_archive_index = do_dyn_syms = true;
+	  do_lto_syms = true;
+	}
+      else
+	usage (stderr);
+    }
+}
+
+static const char *
+get_elf_class (unsigned int elf_class)
+{
+  static char buff[32];
+
+  switch (elf_class)
+    {
+    case ELFCLASSNONE: return _("none");
+    case ELFCLASS32:   return "ELF32";
+    case ELFCLASS64:   return "ELF64";
+    default:
+      snprintf (buff, sizeof (buff), _("<unknown: %x>"), elf_class);
+      return buff;
+    }
+}
+
+static const char *
+get_data_encoding (unsigned int encoding)
+{
+  static char buff[32];
+
+  switch (encoding)
+    {
+    case ELFDATANONE: return _("none");
+    case ELFDATA2LSB: return _("2's complement, little endian");
+    case ELFDATA2MSB: return _("2's complement, big endian");
+    default:
+      snprintf (buff, sizeof (buff), _("<unknown: %x>"), encoding);
+      return buff;
+    }
+}
+
+/* Decode the data held in 'filedata->file_header'.  */
+
+static bool
+process_file_header (Filedata * filedata)
+{
+  Elf_Internal_Ehdr * header = & filedata->file_header;
+
+  if (   header->e_ident[EI_MAG0] != ELFMAG0
+      || header->e_ident[EI_MAG1] != ELFMAG1
+      || header->e_ident[EI_MAG2] != ELFMAG2
+      || header->e_ident[EI_MAG3] != ELFMAG3)
+    {
+      error
+	(_("Not an ELF file - it has the wrong magic bytes at the start\n"));
+      return false;
+    }
+
+  if (! filedata->is_separate)
+    init_dwarf_regnames_by_elf_machine_code (header->e_machine);
+
+  if (do_header)
+    {
+      unsigned i;
+
+      if (filedata->is_separate)
+	printf (_("ELF Header in linked file '%s':\n"), filedata->file_name);
+      else
+	printf (_("ELF Header:\n"));
+      printf (_("  Magic:   "));
+      for (i = 0; i < EI_NIDENT; i++)
+	printf ("%2.2x ", header->e_ident[i]);
+      printf ("\n");
+      printf (_("  Class:                             %s\n"),
+	      get_elf_class (header->e_ident[EI_CLASS]));
+      printf (_("  Data:                              %s\n"),
+	      get_data_encoding (header->e_ident[EI_DATA]));
+      printf (_("  Version:                           %d%s\n"),
+	      header->e_ident[EI_VERSION],
+	      (header->e_ident[EI_VERSION] == EV_CURRENT
+	       ? _(" (current)")
+	       : (header->e_ident[EI_VERSION] != EV_NONE
+		  ? _(" <unknown>")
+		  : "")));
+      printf (_("  OS/ABI:                            %s\n"),
+	      get_osabi_name (filedata, header->e_ident[EI_OSABI]));
+      printf (_("  ABI Version:                       %d\n"),
+	      header->e_ident[EI_ABIVERSION]);
+      printf (_("  Type:                              %s\n"),
+	      get_file_type (filedata));
+      printf (_("  Machine:                           %s\n"),
+	      get_machine_name (header->e_machine));
+      printf (_("  Version:                           0x%lx\n"),
+	      header->e_version);
+
+      printf (_("  Entry point address:               "));
+      print_vma (header->e_entry, PREFIX_HEX);
+      printf (_("\n  Start of program headers:          "));
+      print_vma (header->e_phoff, DEC);
+      printf (_(" (bytes into file)\n  Start of section headers:          "));
+      print_vma (header->e_shoff, DEC);
+      printf (_(" (bytes into file)\n"));
+
+      printf (_("  Flags:                             0x%lx%s\n"),
+	      header->e_flags,
+	      get_machine_flags (filedata, header->e_flags, header->e_machine));
+      printf (_("  Size of this header:               %u (bytes)\n"),
+	      header->e_ehsize);
+      printf (_("  Size of program headers:           %u (bytes)\n"),
+	      header->e_phentsize);
+      printf (_("  Number of program headers:         %u"),
+	      header->e_phnum);
+      if (filedata->section_headers != NULL
+	  && header->e_phnum == PN_XNUM
+	  && filedata->section_headers[0].sh_info != 0)
+	{
+	  header->e_phnum = filedata->section_headers[0].sh_info;
+	  printf (" (%u)", header->e_phnum);
+	}
+      putc ('\n', stdout);
+      printf (_("  Size of section headers:           %u (bytes)\n"),
+	      header->e_shentsize);
+      printf (_("  Number of section headers:         %u"),
+	      header->e_shnum);
+      if (filedata->section_headers != NULL && header->e_shnum == SHN_UNDEF)
+	{
+	  header->e_shnum = filedata->section_headers[0].sh_size;
+	  printf (" (%u)", header->e_shnum);
+	}
+      putc ('\n', stdout);
+      printf (_("  Section header string table index: %u"),
+	      header->e_shstrndx);
+      if (filedata->section_headers != NULL
+	  && header->e_shstrndx == (SHN_XINDEX & 0xffff))
+	{
+	  header->e_shstrndx = filedata->section_headers[0].sh_link;
+	  printf (" (%u)", header->e_shstrndx);
+	}
+      if (header->e_shstrndx != SHN_UNDEF
+	  && header->e_shstrndx >= header->e_shnum)
+	{
+	  header->e_shstrndx = SHN_UNDEF;
+	  printf (_(" <corrupt: out of range>"));
+	}
+      putc ('\n', stdout);
+    }
+
+  if (filedata->section_headers != NULL)
+    {
+      if (header->e_phnum == PN_XNUM
+	  && filedata->section_headers[0].sh_info != 0)
+	header->e_phnum = filedata->section_headers[0].sh_info;
+      if (header->e_shnum == SHN_UNDEF)
+	header->e_shnum = filedata->section_headers[0].sh_size;
+      if (header->e_shstrndx == (SHN_XINDEX & 0xffff))
+	header->e_shstrndx = filedata->section_headers[0].sh_link;
+      if (header->e_shstrndx >= header->e_shnum)
+	header->e_shstrndx = SHN_UNDEF;
+    }
+
+  return true;
+}
+
+/* Read in the program headers from FILEDATA and store them in PHEADERS.
+   Returns TRUE upon success, FALSE otherwise.  Loads 32-bit headers.  */
+
+static bool
+get_32bit_program_headers (Filedata * filedata, Elf_Internal_Phdr * pheaders)
+{
+  Elf32_External_Phdr * phdrs;
+  Elf32_External_Phdr * external;
+  Elf_Internal_Phdr *   internal;
+  unsigned int i;
+  unsigned int size = filedata->file_header.e_phentsize;
+  unsigned int num  = filedata->file_header.e_phnum;
+
+  /* PR binutils/17531: Cope with unexpected section header sizes.  */
+  if (size == 0 || num == 0)
+    return false;
+  if (size < sizeof * phdrs)
+    {
+      error (_("The e_phentsize field in the ELF header is less than the size of an ELF program header\n"));
+      return false;
+    }
+  if (size > sizeof * phdrs)
+    warn (_("The e_phentsize field in the ELF header is larger than the size of an ELF program header\n"));
+
+  phdrs = (Elf32_External_Phdr *) get_data (NULL, filedata, filedata->file_header.e_phoff,
+                                            size, num, _("program headers"));
+  if (phdrs == NULL)
+    return false;
+
+  for (i = 0, internal = pheaders, external = phdrs;
+       i < filedata->file_header.e_phnum;
+       i++, internal++, external++)
+    {
+      internal->p_type   = BYTE_GET (external->p_type);
+      internal->p_offset = BYTE_GET (external->p_offset);
+      internal->p_vaddr  = BYTE_GET (external->p_vaddr);
+      internal->p_paddr  = BYTE_GET (external->p_paddr);
+      internal->p_filesz = BYTE_GET (external->p_filesz);
+      internal->p_memsz  = BYTE_GET (external->p_memsz);
+      internal->p_flags  = BYTE_GET (external->p_flags);
+      internal->p_align  = BYTE_GET (external->p_align);
+    }
+
+  free (phdrs);
+  return true;
+}
+
+/* Read in the program headers from FILEDATA and store them in PHEADERS.
+   Returns TRUE upon success, FALSE otherwise.  Loads 64-bit headers.  */
+
+static bool
+get_64bit_program_headers (Filedata * filedata, Elf_Internal_Phdr * pheaders)
+{
+  Elf64_External_Phdr * phdrs;
+  Elf64_External_Phdr * external;
+  Elf_Internal_Phdr *   internal;
+  unsigned int i;
+  unsigned int size = filedata->file_header.e_phentsize;
+  unsigned int num  = filedata->file_header.e_phnum;
+
+  /* PR binutils/17531: Cope with unexpected section header sizes.  */
+  if (size == 0 || num == 0)
+    return false;
+  if (size < sizeof * phdrs)
+    {
+      error (_("The e_phentsize field in the ELF header is less than the size of an ELF program header\n"));
+      return false;
+    }
+  if (size > sizeof * phdrs)
+    warn (_("The e_phentsize field in the ELF header is larger than the size of an ELF program header\n"));
+
+  phdrs = (Elf64_External_Phdr *) get_data (NULL, filedata, filedata->file_header.e_phoff,
+                                            size, num, _("program headers"));
+  if (!phdrs)
+    return false;
+
+  for (i = 0, internal = pheaders, external = phdrs;
+       i < filedata->file_header.e_phnum;
+       i++, internal++, external++)
+    {
+      internal->p_type   = BYTE_GET (external->p_type);
+      internal->p_flags  = BYTE_GET (external->p_flags);
+      internal->p_offset = BYTE_GET (external->p_offset);
+      internal->p_vaddr  = BYTE_GET (external->p_vaddr);
+      internal->p_paddr  = BYTE_GET (external->p_paddr);
+      internal->p_filesz = BYTE_GET (external->p_filesz);
+      internal->p_memsz  = BYTE_GET (external->p_memsz);
+      internal->p_align  = BYTE_GET (external->p_align);
+    }
+
+  free (phdrs);
+  return true;
+}
+
+/* Returns TRUE if the program headers were read into `program_headers'.  */
+
+static bool
+get_program_headers (Filedata * filedata)
+{
+  Elf_Internal_Phdr * phdrs;
+
+  /* Check cache of prior read.  */
+  if (filedata->program_headers != NULL)
+    return true;
+
+  /* Be kind to memory checkers by looking for
+     e_phnum values which we know must be invalid.  */
+  if (filedata->file_header.e_phnum
+      * (is_32bit_elf ? sizeof (Elf32_External_Phdr) : sizeof (Elf64_External_Phdr))
+      >= filedata->file_size)
+    {
+      error (_("Too many program headers - %#x - the file is not that big\n"),
+	     filedata->file_header.e_phnum);
+      return false;
+    }
+
+  phdrs = (Elf_Internal_Phdr *) cmalloc (filedata->file_header.e_phnum,
+					 sizeof (Elf_Internal_Phdr));
+  if (phdrs == NULL)
+    {
+      error (_("Out of memory reading %u program headers\n"),
+	     filedata->file_header.e_phnum);
+      return false;
+    }
+
+  if (is_32bit_elf
+      ? get_32bit_program_headers (filedata, phdrs)
+      : get_64bit_program_headers (filedata, phdrs))
+    {
+      filedata->program_headers = phdrs;
+      return true;
+    }
+
+  free (phdrs);
+  return false;
+}
+
+/* Print program header info and locate dynamic section.  */
+
+static void
+process_program_headers (Filedata * filedata)
+{
+  Elf_Internal_Phdr * segment;
+  unsigned int i;
+  Elf_Internal_Phdr * previous_load = NULL;
+
+  if (filedata->file_header.e_phnum == 0)
+    {
+      /* PR binutils/12467.  */
+      if (filedata->file_header.e_phoff != 0)
+	warn (_("possibly corrupt ELF header - it has a non-zero program"
+		" header offset, but no program headers\n"));
+      else if (do_segments)
+	{
+	  if (filedata->is_separate)
+	    printf (_("\nThere are no program headers in linked file '%s'.\n"),
+		    filedata->file_name);
+	  else
+	    printf (_("\nThere are no program headers in this file.\n"));
+	}
+      goto no_headers;
+    }
+
+  if (do_segments && !do_header)
+    {
+      if (filedata->is_separate)
+	printf ("\nIn linked file '%s' the ELF file type is %s\n",
+		filedata->file_name, get_file_type (filedata));
+      else
+	printf (_("\nElf file type is %s\n"), get_file_type (filedata));
+      printf (_("Entry point 0x%s\n"), bfd_vmatoa ("x", filedata->file_header.e_entry));
+      printf (ngettext ("There is %d program header, starting at offset %s\n",
+			"There are %d program headers, starting at offset %s\n",
+			filedata->file_header.e_phnum),
+	      filedata->file_header.e_phnum,
+	      bfd_vmatoa ("u", filedata->file_header.e_phoff));
+    }
+
+  if (! get_program_headers (filedata))
+    goto no_headers;
+
+  if (do_segments)
+    {
+      if (filedata->file_header.e_phnum > 1)
+	printf (_("\nProgram Headers:\n"));
+      else
+	printf (_("\nProgram Headers:\n"));
+
+      if (is_32bit_elf)
+	printf
+	  (_("  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n"));
+      else if (do_wide)
+	printf
+	  (_("  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n"));
+      else
+	{
+	  printf
+	    (_("  Type           Offset             VirtAddr           PhysAddr\n"));
+	  printf
+	    (_("                 FileSiz            MemSiz              Flags  Align\n"));
+	}
+    }
+
+  unsigned long dynamic_addr = 0;
+  bfd_size_type dynamic_size = 0;
+  for (i = 0, segment = filedata->program_headers;
+       i < filedata->file_header.e_phnum;
+       i++, segment++)
+    {
+      if (do_segments)
+	{
+	  printf ("  %-14.14s ", get_segment_type (filedata, segment->p_type));
+
+	  if (is_32bit_elf)
+	    {
+	      printf ("0x%6.6lx ", (unsigned long) segment->p_offset);
+	      printf ("0x%8.8lx ", (unsigned long) segment->p_vaddr);
+	      printf ("0x%8.8lx ", (unsigned long) segment->p_paddr);
+	      printf ("0x%5.5lx ", (unsigned long) segment->p_filesz);
+	      printf ("0x%5.5lx ", (unsigned long) segment->p_memsz);
+	      printf ("%c%c%c ",
+		      (segment->p_flags & PF_R ? 'R' : ' '),
+		      (segment->p_flags & PF_W ? 'W' : ' '),
+		      (segment->p_flags & PF_X ? 'E' : ' '));
+	      printf ("%#lx", (unsigned long) segment->p_align);
+	    }
+	  else if (do_wide)
+	    {
+	      if ((unsigned long) segment->p_offset == segment->p_offset)
+		printf ("0x%6.6lx ", (unsigned long) segment->p_offset);
+	      else
+		{
+		  print_vma (segment->p_offset, FULL_HEX);
+		  putchar (' ');
+		}
+
+	      print_vma (segment->p_vaddr, FULL_HEX);
+	      putchar (' ');
+	      print_vma (segment->p_paddr, FULL_HEX);
+	      putchar (' ');
+
+	      if ((unsigned long) segment->p_filesz == segment->p_filesz)
+		printf ("0x%6.6lx ", (unsigned long) segment->p_filesz);
+	      else
+		{
+		  print_vma (segment->p_filesz, FULL_HEX);
+		  putchar (' ');
+		}
+
+	      if ((unsigned long) segment->p_memsz == segment->p_memsz)
+		printf ("0x%6.6lx", (unsigned long) segment->p_memsz);
+	      else
+		{
+		  print_vma (segment->p_memsz, FULL_HEX);
+		}
+
+	      printf (" %c%c%c ",
+		      (segment->p_flags & PF_R ? 'R' : ' '),
+		      (segment->p_flags & PF_W ? 'W' : ' '),
+		      (segment->p_flags & PF_X ? 'E' : ' '));
+
+	      if ((unsigned long) segment->p_align == segment->p_align)
+		printf ("%#lx", (unsigned long) segment->p_align);
+	      else
+		{
+		  print_vma (segment->p_align, PREFIX_HEX);
+		}
+	    }
+	  else
+	    {
+	      print_vma (segment->p_offset, FULL_HEX);
+	      putchar (' ');
+	      print_vma (segment->p_vaddr, FULL_HEX);
+	      putchar (' ');
+	      print_vma (segment->p_paddr, FULL_HEX);
+	      printf ("\n                 ");
+	      print_vma (segment->p_filesz, FULL_HEX);
+	      putchar (' ');
+	      print_vma (segment->p_memsz, FULL_HEX);
+	      printf ("  %c%c%c    ",
+		      (segment->p_flags & PF_R ? 'R' : ' '),
+		      (segment->p_flags & PF_W ? 'W' : ' '),
+		      (segment->p_flags & PF_X ? 'E' : ' '));
+	      print_vma (segment->p_align, PREFIX_HEX);
+	    }
+
+	  putc ('\n', stdout);
+	}
+
+      switch (segment->p_type)
+	{
+	case PT_LOAD:
+#if 0 /* Do not warn about out of order PT_LOAD segments.  Although officially
+	 required by the ELF standard, several programs, including the Linux
+	 kernel, make use of non-ordered segments.  */
+	  if (previous_load
+	      && previous_load->p_vaddr > segment->p_vaddr)
+	    error (_("LOAD segments must be sorted in order of increasing VirtAddr\n"));
+#endif
+	  if (segment->p_memsz < segment->p_filesz)
+	    error (_("the segment's file size is larger than its memory size\n"));
+	  previous_load = segment;
+	  break;
+
+	case PT_PHDR:
+	  /* PR 20815 - Verify that the program header is loaded into memory.  */
+	  if (i > 0 && previous_load != NULL)
+	    error (_("the PHDR segment must occur before any LOAD segment\n"));
+	  if (filedata->file_header.e_machine != EM_PARISC)
+	    {
+	      unsigned int j;
+
+	      for (j = 1; j < filedata->file_header.e_phnum; j++)
+		{
+		  Elf_Internal_Phdr *load = filedata->program_headers + j;
+		  if (load->p_type == PT_LOAD
+		      && load->p_offset <= segment->p_offset
+		      && (load->p_offset + load->p_filesz
+			  >= segment->p_offset + segment->p_filesz)
+		      && load->p_vaddr <= segment->p_vaddr
+		      && (load->p_vaddr + load->p_filesz
+			  >= segment->p_vaddr + segment->p_filesz))
+		    break;
+		}
+	      if (j == filedata->file_header.e_phnum)
+		error (_("the PHDR segment is not covered by a LOAD segment\n"));
+	    }
+	  break;
+
+	case PT_DYNAMIC:
+	  if (dynamic_addr)
+	    error (_("more than one dynamic segment\n"));
+
+	  /* By default, assume that the .dynamic section is the first
+	     section in the DYNAMIC segment.  */
+	  dynamic_addr = segment->p_offset;
+	  dynamic_size = segment->p_filesz;
+
+	  /* Try to locate the .dynamic section. If there is
+	     a section header table, we can easily locate it.  */
+	  if (filedata->section_headers != NULL)
+	    {
+	      Elf_Internal_Shdr * sec;
+
+	      sec = find_section (filedata, ".dynamic");
+	      if (sec == NULL || sec->sh_size == 0)
+		{
+		  /* A corresponding .dynamic section is expected, but on
+		     IA-64/OpenVMS it is OK for it to be missing.  */
+		  if (!is_ia64_vms (filedata))
+		    error (_("no .dynamic section in the dynamic segment\n"));
+		  break;
+		}
+
+	      if (sec->sh_type == SHT_NOBITS)
+		{
+		  dynamic_addr = 0;
+		  dynamic_size = 0;
+		  break;
+		}
+
+	      dynamic_addr = sec->sh_offset;
+	      dynamic_size = sec->sh_size;
+
+	      /* The PT_DYNAMIC segment, which is used by the run-time
+		 loader,  should exactly match the .dynamic section.  */
+	      if (do_checks
+		  && (dynamic_addr != segment->p_offset
+		      || dynamic_size != segment->p_filesz))
+		warn (_("\
+the .dynamic section is not the same as the dynamic segment\n"));
+	    }
+
+	  /* PR binutils/17512: Avoid corrupt dynamic section info in the
+	     segment.  Check this after matching against the section headers
+	     so we don't warn on debuginfo file (which have NOBITS .dynamic
+	     sections).  */
+	  if (dynamic_addr > filedata->file_size
+	      || (dynamic_size > filedata->file_size - dynamic_addr))
+	    {
+	      error (_("the dynamic segment offset + size exceeds the size of the file\n"));
+	      dynamic_addr = 0;
+	      dynamic_size = 0;
+	    }
+	  break;
+
+	case PT_INTERP:
+	  if (segment->p_offset >= filedata->file_size
+	      || segment->p_filesz > filedata->file_size - segment->p_offset
+	      || segment->p_filesz - 1 >= (size_t) -2
+	      || fseek (filedata->handle,
+			filedata->archive_file_offset + (long) segment->p_offset,
+			SEEK_SET))
+	    error (_("Unable to find program interpreter name\n"));
+	  else
+	    {
+	      size_t len = segment->p_filesz;
+	      free (filedata->program_interpreter);
+	      filedata->program_interpreter = xmalloc (len + 1);
+	      len = fread (filedata->program_interpreter, 1, len,
+			   filedata->handle);
+	      filedata->program_interpreter[len] = 0;
+
+	      if (do_segments)
+		printf (_("      [Requesting program interpreter: %s]\n"),
+		    filedata->program_interpreter);
+	    }
+	  break;
+	}
+    }
+
+  if (do_segments
+      && filedata->section_headers != NULL
+      && filedata->string_table != NULL)
+    {
+      printf (_("\n Section to Segment mapping:\n"));
+      printf (_("  Segment Sections...\n"));
+
+      for (i = 0; i < filedata->file_header.e_phnum; i++)
+	{
+	  unsigned int j;
+	  Elf_Internal_Shdr * section;
+
+	  segment = filedata->program_headers + i;
+	  section = filedata->section_headers + 1;
+
+	  printf ("   %2.2d     ", i);
+
+	  for (j = 1; j < filedata->file_header.e_shnum; j++, section++)
+	    {
+	      if (!ELF_TBSS_SPECIAL (section, segment)
+		  && ELF_SECTION_IN_SEGMENT_STRICT (section, segment))
+		printf ("%s ", printable_section_name (filedata, section));
+	    }
+
+	  putc ('\n',stdout);
+	}
+    }
+
+  filedata->dynamic_addr = dynamic_addr;
+  filedata->dynamic_size = dynamic_size ? dynamic_size : 1;
+  return;
+
+ no_headers:
+  filedata->dynamic_addr = 0;
+  filedata->dynamic_size = 1;
+}
+
+
+/* Find the file offset corresponding to VMA by using the program headers.  */
+
+static long
+offset_from_vma (Filedata * filedata, bfd_vma vma, bfd_size_type size)
+{
+  Elf_Internal_Phdr * seg;
+
+  if (! get_program_headers (filedata))
+    {
+      warn (_("Cannot interpret virtual addresses without program headers.\n"));
+      return (long) vma;
+    }
+
+  for (seg = filedata->program_headers;
+       seg < filedata->program_headers + filedata->file_header.e_phnum;
+       ++seg)
+    {
+      if (seg->p_type != PT_LOAD)
+	continue;
+
+      if (vma >= (seg->p_vaddr & -seg->p_align)
+	  && vma + size <= seg->p_vaddr + seg->p_filesz)
+	return vma - seg->p_vaddr + seg->p_offset;
+    }
+
+  warn (_("Virtual address 0x%lx not located in any PT_LOAD segment.\n"),
+	(unsigned long) vma);
+  return (long) vma;
+}
+
+
+/* Allocate memory and load the sections headers into FILEDATA->filedata->section_headers.
+   If PROBE is true, this is just a probe and we do not generate any error
+   messages if the load fails.  */
+
+static bool
+get_32bit_section_headers (Filedata * filedata, bool probe)
+{
+  Elf32_External_Shdr * shdrs;
+  Elf_Internal_Shdr *   internal;
+  unsigned int          i;
+  unsigned int          size = filedata->file_header.e_shentsize;
+  unsigned int          num = probe ? 1 : filedata->file_header.e_shnum;
+
+  /* PR binutils/17531: Cope with unexpected section header sizes.  */
+  if (size == 0 || num == 0)
+    return false;
+  if (size < sizeof * shdrs)
+    {
+      if (! probe)
+	error (_("The e_shentsize field in the ELF header is less than the size of an ELF section header\n"));
+      return false;
+    }
+  if (!probe && size > sizeof * shdrs)
+    warn (_("The e_shentsize field in the ELF header is larger than the size of an ELF section header\n"));
+
+  shdrs = (Elf32_External_Shdr *) get_data (NULL, filedata, filedata->file_header.e_shoff,
+                                            size, num,
+					    probe ? NULL : _("section headers"));
+  if (shdrs == NULL)
+    return false;
+
+  filedata->section_headers = (Elf_Internal_Shdr *)
+    cmalloc (num, sizeof (Elf_Internal_Shdr));
+  if (filedata->section_headers == NULL)
+    {
+      if (!probe)
+	error (_("Out of memory reading %u section headers\n"), num);
+      free (shdrs);
+      return false;
+    }
+
+  for (i = 0, internal = filedata->section_headers;
+       i < num;
+       i++, internal++)
+    {
+      internal->sh_name      = BYTE_GET (shdrs[i].sh_name);
+      internal->sh_type      = BYTE_GET (shdrs[i].sh_type);
+      internal->sh_flags     = BYTE_GET (shdrs[i].sh_flags);
+      internal->sh_addr      = BYTE_GET (shdrs[i].sh_addr);
+      internal->sh_offset    = BYTE_GET (shdrs[i].sh_offset);
+      internal->sh_size      = BYTE_GET (shdrs[i].sh_size);
+      internal->sh_link      = BYTE_GET (shdrs[i].sh_link);
+      internal->sh_info      = BYTE_GET (shdrs[i].sh_info);
+      internal->sh_addralign = BYTE_GET (shdrs[i].sh_addralign);
+      internal->sh_entsize   = BYTE_GET (shdrs[i].sh_entsize);
+      if (!probe && internal->sh_link > num)
+	warn (_("Section %u has an out of range sh_link value of %u\n"), i, internal->sh_link);
+      if (!probe && internal->sh_flags & SHF_INFO_LINK && internal->sh_info > num)
+	warn (_("Section %u has an out of range sh_info value of %u\n"), i, internal->sh_info);
+    }
+
+  free (shdrs);
+  return true;
+}
+
+/* Like get_32bit_section_headers, except that it fetches 64-bit headers.  */
+
+static bool
+get_64bit_section_headers (Filedata * filedata, bool probe)
+{
+  Elf64_External_Shdr *  shdrs;
+  Elf_Internal_Shdr *    internal;
+  unsigned int           i;
+  unsigned int           size = filedata->file_header.e_shentsize;
+  unsigned int           num = probe ? 1 : filedata->file_header.e_shnum;
+
+  /* PR binutils/17531: Cope with unexpected section header sizes.  */
+  if (size == 0 || num == 0)
+    return false;
+
+  if (size < sizeof * shdrs)
+    {
+      if (! probe)
+	error (_("The e_shentsize field in the ELF header is less than the size of an ELF section header\n"));
+      return false;
+    }
+
+  if (! probe && size > sizeof * shdrs)
+    warn (_("The e_shentsize field in the ELF header is larger than the size of an ELF section header\n"));
+
+  shdrs = (Elf64_External_Shdr *) get_data (NULL, filedata,
+					    filedata->file_header.e_shoff,
+                                            size, num,
+					    probe ? NULL : _("section headers"));
+  if (shdrs == NULL)
+    return false;
+
+  filedata->section_headers = (Elf_Internal_Shdr *)
+    cmalloc (num, sizeof (Elf_Internal_Shdr));
+  if (filedata->section_headers == NULL)
+    {
+      if (! probe)
+	error (_("Out of memory reading %u section headers\n"), num);
+      free (shdrs);
+      return false;
+    }
+
+  for (i = 0, internal = filedata->section_headers;
+       i < num;
+       i++, internal++)
+    {
+      internal->sh_name      = BYTE_GET (shdrs[i].sh_name);
+      internal->sh_type      = BYTE_GET (shdrs[i].sh_type);
+      internal->sh_flags     = BYTE_GET (shdrs[i].sh_flags);
+      internal->sh_addr      = BYTE_GET (shdrs[i].sh_addr);
+      internal->sh_size      = BYTE_GET (shdrs[i].sh_size);
+      internal->sh_entsize   = BYTE_GET (shdrs[i].sh_entsize);
+      internal->sh_link      = BYTE_GET (shdrs[i].sh_link);
+      internal->sh_info      = BYTE_GET (shdrs[i].sh_info);
+      internal->sh_offset    = BYTE_GET (shdrs[i].sh_offset);
+      internal->sh_addralign = BYTE_GET (shdrs[i].sh_addralign);
+      if (!probe && internal->sh_link > num)
+	warn (_("Section %u has an out of range sh_link value of %u\n"), i, internal->sh_link);
+      if (!probe && internal->sh_flags & SHF_INFO_LINK && internal->sh_info > num)
+	warn (_("Section %u has an out of range sh_info value of %u\n"), i, internal->sh_info);
+    }
+
+  free (shdrs);
+  return true;
+}
+
+static bool
+get_section_headers (Filedata *filedata, bool probe)
+{
+  if (filedata->section_headers != NULL)
+    return true;
+
+  if (is_32bit_elf)
+    return get_32bit_section_headers (filedata, probe);
+  else
+    return get_64bit_section_headers (filedata, probe);
+}
+
+static Elf_Internal_Sym *
+get_32bit_elf_symbols (Filedata *           filedata,
+		       Elf_Internal_Shdr *  section,
+		       unsigned long *      num_syms_return)
+{
+  unsigned long number = 0;
+  Elf32_External_Sym * esyms = NULL;
+  Elf_External_Sym_Shndx * shndx = NULL;
+  Elf_Internal_Sym * isyms = NULL;
+  Elf_Internal_Sym * psym;
+  unsigned int j;
+  elf_section_list * entry;
+
+  if (section->sh_size == 0)
+    {
+      if (num_syms_return != NULL)
+	* num_syms_return = 0;
+      return NULL;
+    }
+
+  /* Run some sanity checks first.  */
+  if (section->sh_entsize == 0 || section->sh_entsize > section->sh_size)
+    {
+      error (_("Section %s has an invalid sh_entsize of 0x%lx\n"),
+	     printable_section_name (filedata, section),
+	     (unsigned long) section->sh_entsize);
+      goto exit_point;
+    }
+
+  if (section->sh_size > filedata->file_size)
+    {
+      error (_("Section %s has an invalid sh_size of 0x%lx\n"),
+	     printable_section_name (filedata, section),
+	     (unsigned long) section->sh_size);
+      goto exit_point;
+    }
+
+  number = section->sh_size / section->sh_entsize;
+
+  if (number * sizeof (Elf32_External_Sym) > section->sh_size + 1)
+    {
+      error (_("Size (0x%lx) of section %s is not a multiple of its sh_entsize (0x%lx)\n"),
+	     (unsigned long) section->sh_size,
+	     printable_section_name (filedata, section),
+	     (unsigned long) section->sh_entsize);
+      goto exit_point;
+    }
+
+  esyms = (Elf32_External_Sym *) get_data (NULL, filedata, section->sh_offset, 1,
+                                           section->sh_size, _("symbols"));
+  if (esyms == NULL)
+    goto exit_point;
+
+  shndx = NULL;
+  for (entry = filedata->symtab_shndx_list; entry != NULL; entry = entry->next)
+    {
+      if (entry->hdr->sh_link != (unsigned long) (section - filedata->section_headers))
+	continue;
+
+      if (shndx != NULL)
+	{
+	  error (_("Multiple symbol table index sections associated with the same symbol section\n"));
+	  free (shndx);
+	}
+
+      shndx = (Elf_External_Sym_Shndx *) get_data (NULL, filedata,
+						   entry->hdr->sh_offset,
+						   1, entry->hdr->sh_size,
+						   _("symbol table section indices"));
+      if (shndx == NULL)
+	goto exit_point;
+
+      /* PR17531: file: heap-buffer-overflow */
+      if (entry->hdr->sh_size / sizeof (Elf_External_Sym_Shndx) < number)
+	{
+	  error (_("Index section %s has an sh_size of 0x%lx - expected 0x%lx\n"),
+		 printable_section_name (filedata, entry->hdr),
+		 (unsigned long) entry->hdr->sh_size,
+		 (unsigned long) section->sh_size);
+	  goto exit_point;
+	}
+    }
+
+  isyms = (Elf_Internal_Sym *) cmalloc (number, sizeof (Elf_Internal_Sym));
+
+  if (isyms == NULL)
+    {
+      error (_("Out of memory reading %lu symbols\n"),
+	     (unsigned long) number);
+      goto exit_point;
+    }
+
+  for (j = 0, psym = isyms; j < number; j++, psym++)
+    {
+      psym->st_name  = BYTE_GET (esyms[j].st_name);
+      psym->st_value = BYTE_GET (esyms[j].st_value);
+      psym->st_size  = BYTE_GET (esyms[j].st_size);
+      psym->st_shndx = BYTE_GET (esyms[j].st_shndx);
+      if (psym->st_shndx == (SHN_XINDEX & 0xffff) && shndx != NULL)
+	psym->st_shndx
+	  = byte_get ((unsigned char *) &shndx[j], sizeof (shndx[j]));
+      else if (psym->st_shndx >= (SHN_LORESERVE & 0xffff))
+	psym->st_shndx += SHN_LORESERVE - (SHN_LORESERVE & 0xffff);
+      psym->st_info  = BYTE_GET (esyms[j].st_info);
+      psym->st_other = BYTE_GET (esyms[j].st_other);
+    }
+
+ exit_point:
+  free (shndx);
+  free (esyms);
+
+  if (num_syms_return != NULL)
+    * num_syms_return = isyms == NULL ? 0 : number;
+
+  return isyms;
+}
+
+static Elf_Internal_Sym *
+get_64bit_elf_symbols (Filedata *           filedata,
+		       Elf_Internal_Shdr *  section,
+		       unsigned long *      num_syms_return)
+{
+  unsigned long number = 0;
+  Elf64_External_Sym * esyms = NULL;
+  Elf_External_Sym_Shndx * shndx = NULL;
+  Elf_Internal_Sym * isyms = NULL;
+  Elf_Internal_Sym * psym;
+  unsigned int j;
+  elf_section_list * entry;
+
+  if (section->sh_size == 0)
+    {
+      if (num_syms_return != NULL)
+	* num_syms_return = 0;
+      return NULL;
+    }
+
+  /* Run some sanity checks first.  */
+  if (section->sh_entsize == 0 || section->sh_entsize > section->sh_size)
+    {
+      error (_("Section %s has an invalid sh_entsize of 0x%lx\n"),
+	     printable_section_name (filedata, section),
+	     (unsigned long) section->sh_entsize);
+      goto exit_point;
+    }
+
+  if (section->sh_size > filedata->file_size)
+    {
+      error (_("Section %s has an invalid sh_size of 0x%lx\n"),
+	     printable_section_name (filedata, section),
+	     (unsigned long) section->sh_size);
+      goto exit_point;
+    }
+
+  number = section->sh_size / section->sh_entsize;
+
+  if (number * sizeof (Elf64_External_Sym) > section->sh_size + 1)
+    {
+      error (_("Size (0x%lx) of section %s is not a multiple of its sh_entsize (0x%lx)\n"),
+	     (unsigned long) section->sh_size,
+	     printable_section_name (filedata, section),
+	     (unsigned long) section->sh_entsize);
+      goto exit_point;
+    }
+
+  esyms = (Elf64_External_Sym *) get_data (NULL, filedata, section->sh_offset, 1,
+                                           section->sh_size, _("symbols"));
+  if (!esyms)
+    goto exit_point;
+
+  shndx = NULL;
+  for (entry = filedata->symtab_shndx_list; entry != NULL; entry = entry->next)
+    {
+      if (entry->hdr->sh_link != (unsigned long) (section - filedata->section_headers))
+	continue;
+
+      if (shndx != NULL)
+	{
+	  error (_("Multiple symbol table index sections associated with the same symbol section\n"));
+	  free (shndx);
+	}
+
+      shndx = (Elf_External_Sym_Shndx *) get_data (NULL, filedata,
+						   entry->hdr->sh_offset,
+						   1, entry->hdr->sh_size,
+						   _("symbol table section indices"));
+      if (shndx == NULL)
+	goto exit_point;
+
+      /* PR17531: file: heap-buffer-overflow */
+      if (entry->hdr->sh_size / sizeof (Elf_External_Sym_Shndx) < number)
+	{
+	  error (_("Index section %s has an sh_size of 0x%lx - expected 0x%lx\n"),
+		 printable_section_name (filedata, entry->hdr),
+		 (unsigned long) entry->hdr->sh_size,
+		 (unsigned long) section->sh_size);
+	  goto exit_point;
+	}
+    }
+
+  isyms = (Elf_Internal_Sym *) cmalloc (number, sizeof (Elf_Internal_Sym));
+
+  if (isyms == NULL)
+    {
+      error (_("Out of memory reading %lu symbols\n"),
+	     (unsigned long) number);
+      goto exit_point;
+    }
+
+  for (j = 0, psym = isyms; j < number; j++, psym++)
+    {
+      psym->st_name  = BYTE_GET (esyms[j].st_name);
+      psym->st_info  = BYTE_GET (esyms[j].st_info);
+      psym->st_other = BYTE_GET (esyms[j].st_other);
+      psym->st_shndx = BYTE_GET (esyms[j].st_shndx);
+
+      if (psym->st_shndx == (SHN_XINDEX & 0xffff) && shndx != NULL)
+	psym->st_shndx
+	  = byte_get ((unsigned char *) &shndx[j], sizeof (shndx[j]));
+      else if (psym->st_shndx >= (SHN_LORESERVE & 0xffff))
+	psym->st_shndx += SHN_LORESERVE - (SHN_LORESERVE & 0xffff);
+
+      psym->st_value = BYTE_GET (esyms[j].st_value);
+      psym->st_size  = BYTE_GET (esyms[j].st_size);
+    }
+
+ exit_point:
+  free (shndx);
+  free (esyms);
+
+  if (num_syms_return != NULL)
+    * num_syms_return = isyms == NULL ? 0 : number;
+
+  return isyms;
+}
+
+static Elf_Internal_Sym *
+get_elf_symbols (Filedata *filedata,
+		 Elf_Internal_Shdr *section,
+		 unsigned long *num_syms_return)
+{
+  if (is_32bit_elf)
+    return get_32bit_elf_symbols (filedata, section, num_syms_return);
+  else
+    return get_64bit_elf_symbols (filedata, section, num_syms_return);
+}
+
+static const char *
+get_elf_section_flags (Filedata * filedata, bfd_vma sh_flags)
+{
+  static char buff[1024];
+  char * p = buff;
+  unsigned int field_size = is_32bit_elf ? 8 : 16;
+  signed int sindex;
+  unsigned int size = sizeof (buff) - (field_size + 4 + 1);
+  bfd_vma os_flags = 0;
+  bfd_vma proc_flags = 0;
+  bfd_vma unknown_flags = 0;
+  static const struct
+    {
+      const char * str;
+      unsigned int len;
+    }
+  flags [] =
+    {
+      /*  0 */ { STRING_COMMA_LEN ("WRITE") },
+      /*  1 */ { STRING_COMMA_LEN ("ALLOC") },
+      /*  2 */ { STRING_COMMA_LEN ("EXEC") },
+      /*  3 */ { STRING_COMMA_LEN ("MERGE") },
+      /*  4 */ { STRING_COMMA_LEN ("STRINGS") },
+      /*  5 */ { STRING_COMMA_LEN ("INFO LINK") },
+      /*  6 */ { STRING_COMMA_LEN ("LINK ORDER") },
+      /*  7 */ { STRING_COMMA_LEN ("OS NONCONF") },
+      /*  8 */ { STRING_COMMA_LEN ("GROUP") },
+      /*  9 */ { STRING_COMMA_LEN ("TLS") },
+      /* IA-64 specific.  */
+      /* 10 */ { STRING_COMMA_LEN ("SHORT") },
+      /* 11 */ { STRING_COMMA_LEN ("NORECOV") },
+      /* IA-64 OpenVMS specific.  */
+      /* 12 */ { STRING_COMMA_LEN ("VMS_GLOBAL") },
+      /* 13 */ { STRING_COMMA_LEN ("VMS_OVERLAID") },
+      /* 14 */ { STRING_COMMA_LEN ("VMS_SHARED") },
+      /* 15 */ { STRING_COMMA_LEN ("VMS_VECTOR") },
+      /* 16 */ { STRING_COMMA_LEN ("VMS_ALLOC_64BIT") },
+      /* 17 */ { STRING_COMMA_LEN ("VMS_PROTECTED") },
+      /* Generic.  */
+      /* 18 */ { STRING_COMMA_LEN ("EXCLUDE") },
+      /* SPARC specific.  */
+      /* 19 */ { STRING_COMMA_LEN ("ORDERED") },
+      /* 20 */ { STRING_COMMA_LEN ("COMPRESSED") },
+      /* ARM specific.  */
+      /* 21 */ { STRING_COMMA_LEN ("ENTRYSECT") },
+      /* 22 */ { STRING_COMMA_LEN ("ARM_PURECODE") },
+      /* 23 */ { STRING_COMMA_LEN ("COMDEF") },
+      /* GNU specific.  */
+      /* 24 */ { STRING_COMMA_LEN ("GNU_MBIND") },
+      /* VLE specific.  */
+      /* 25 */ { STRING_COMMA_LEN ("VLE") },
+      /* GNU specific.  */
+      /* 26 */ { STRING_COMMA_LEN ("GNU_RETAIN") },
+    };
+
+  if (do_section_details)
+    {
+      sprintf (buff, "[%*.*lx]: ",
+	       field_size, field_size, (unsigned long) sh_flags);
+      p += field_size + 4;
+    }
+
+  while (sh_flags)
+    {
+      bfd_vma flag;
+
+      flag = sh_flags & - sh_flags;
+      sh_flags &= ~ flag;
+
+      if (do_section_details)
+	{
+	  switch (flag)
+	    {
+	    case SHF_WRITE:		sindex = 0; break;
+	    case SHF_ALLOC:		sindex = 1; break;
+	    case SHF_EXECINSTR:		sindex = 2; break;
+	    case SHF_MERGE:		sindex = 3; break;
+	    case SHF_STRINGS:		sindex = 4; break;
+	    case SHF_INFO_LINK:		sindex = 5; break;
+	    case SHF_LINK_ORDER:	sindex = 6; break;
+	    case SHF_OS_NONCONFORMING:	sindex = 7; break;
+	    case SHF_GROUP:		sindex = 8; break;
+	    case SHF_TLS:		sindex = 9; break;
+	    case SHF_EXCLUDE:		sindex = 18; break;
+	    case SHF_COMPRESSED:	sindex = 20; break;
+
+	    default:
+	      sindex = -1;
+	      switch (filedata->file_header.e_machine)
+		{
+		case EM_IA_64:
+		  if (flag == SHF_IA_64_SHORT)
+		    sindex = 10;
+		  else if (flag == SHF_IA_64_NORECOV)
+		    sindex = 11;
+#ifdef BFD64
+		  else if (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_OPENVMS)
+		    switch (flag)
+		      {
+		      case SHF_IA_64_VMS_GLOBAL:      sindex = 12; break;
+		      case SHF_IA_64_VMS_OVERLAID:    sindex = 13; break;
+		      case SHF_IA_64_VMS_SHARED:      sindex = 14; break;
+		      case SHF_IA_64_VMS_VECTOR:      sindex = 15; break;
+		      case SHF_IA_64_VMS_ALLOC_64BIT: sindex = 16; break;
+		      case SHF_IA_64_VMS_PROTECTED:   sindex = 17; break;
+		      default:                        break;
+		      }
+#endif
+		  break;
+
+		case EM_386:
+		case EM_IAMCU:
+		case EM_X86_64:
+		case EM_L1OM:
+		case EM_K1OM:
+		case EM_OLD_SPARCV9:
+		case EM_SPARC32PLUS:
+		case EM_SPARCV9:
+		case EM_SPARC:
+		  if (flag == SHF_ORDERED)
+		    sindex = 19;
+		  break;
+
+		case EM_ARM:
+		  switch (flag)
+		    {
+		    case SHF_ENTRYSECT: sindex = 21; break;
+		    case SHF_ARM_PURECODE: sindex = 22; break;
+		    case SHF_COMDEF: sindex = 23; break;
+		    default: break;
+		    }
+		  break;
+		case EM_PPC:
+		  if (flag == SHF_PPC_VLE)
+		    sindex = 25;
+		  break;
+		default:
+		  break;
+		}
+
+	      switch (filedata->file_header.e_ident[EI_OSABI])
+		{
+		case ELFOSABI_GNU:
+		case ELFOSABI_FREEBSD:
+		  if (flag == SHF_GNU_RETAIN)
+		    sindex = 26;
+		  /* Fall through */
+		case ELFOSABI_NONE:
+		  if (flag == SHF_GNU_MBIND)
+		    /* We should not recognize SHF_GNU_MBIND for
+		       ELFOSABI_NONE, but binutils as of 2019-07-23 did
+		       not set the EI_OSABI header byte.  */
+		    sindex = 24;
+		  break;
+		default:
+		  break;
+		}
+	      break;
+	    }
+
+	  if (sindex != -1)
+	    {
+	      if (p != buff + field_size + 4)
+		{
+		  if (size < (10 + 2))
+		    {
+		      warn (_("Internal error: not enough buffer room for section flag info"));
+		      return _("<unknown>");
+		    }
+		  size -= 2;
+		  *p++ = ',';
+		  *p++ = ' ';
+		}
+
+	      size -= flags [sindex].len;
+	      p = stpcpy (p, flags [sindex].str);
+	    }
+	  else if (flag & SHF_MASKOS)
+	    os_flags |= flag;
+	  else if (flag & SHF_MASKPROC)
+	    proc_flags |= flag;
+	  else
+	    unknown_flags |= flag;
+	}
+      else
+	{
+	  switch (flag)
+	    {
+	    case SHF_WRITE:		*p = 'W'; break;
+	    case SHF_ALLOC:		*p = 'A'; break;
+	    case SHF_EXECINSTR:		*p = 'X'; break;
+	    case SHF_MERGE:		*p = 'M'; break;
+	    case SHF_STRINGS:		*p = 'S'; break;
+	    case SHF_INFO_LINK:		*p = 'I'; break;
+	    case SHF_LINK_ORDER:	*p = 'L'; break;
+	    case SHF_OS_NONCONFORMING:	*p = 'O'; break;
+	    case SHF_GROUP:		*p = 'G'; break;
+	    case SHF_TLS:		*p = 'T'; break;
+	    case SHF_EXCLUDE:		*p = 'E'; break;
+	    case SHF_COMPRESSED:	*p = 'C'; break;
+
+	    default:
+	      if ((filedata->file_header.e_machine == EM_X86_64
+		   || filedata->file_header.e_machine == EM_L1OM
+		   || filedata->file_header.e_machine == EM_K1OM)
+		  && flag == SHF_X86_64_LARGE)
+		*p = 'l';
+	      else if (filedata->file_header.e_machine == EM_ARM
+		       && flag == SHF_ARM_PURECODE)
+		*p = 'y';
+	      else if (filedata->file_header.e_machine == EM_PPC
+		       && flag == SHF_PPC_VLE)
+		*p = 'v';
+	      else if (flag & SHF_MASKOS)
+		{
+		  switch (filedata->file_header.e_ident[EI_OSABI])
+		    {
+		    case ELFOSABI_GNU:
+		    case ELFOSABI_FREEBSD:
+		      if (flag == SHF_GNU_RETAIN)
+			{
+			  *p = 'R';
+			  break;
+			}
+		      /* Fall through */
+		    case ELFOSABI_NONE:
+		      if (flag == SHF_GNU_MBIND)
+			{
+			  /* We should not recognize SHF_GNU_MBIND for
+			     ELFOSABI_NONE, but binutils as of 2019-07-23 did
+			     not set the EI_OSABI header byte.  */
+			  *p = 'D';
+			  break;
+			}
+		      /* Fall through */
+		    default:
+		      *p = 'o';
+		      sh_flags &= ~SHF_MASKOS;
+		      break;
+		    }
+		}
+	      else if (flag & SHF_MASKPROC)
+		{
+		  *p = 'p';
+		  sh_flags &= ~ SHF_MASKPROC;
+		}
+	      else
+		*p = 'x';
+	      break;
+	    }
+	  p++;
+	}
+    }
+
+  if (do_section_details)
+    {
+      if (os_flags)
+	{
+	  size -= 5 + field_size;
+	  if (p != buff + field_size + 4)
+	    {
+	      if (size < (2 + 1))
+		{
+		  warn (_("Internal error: not enough buffer room for section flag info"));
+		  return _("<unknown>");
+		}
+	      size -= 2;
+	      *p++ = ',';
+	      *p++ = ' ';
+	    }
+	  sprintf (p, "OS (%*.*lx)", field_size, field_size,
+		   (unsigned long) os_flags);
+	  p += 5 + field_size;
+	}
+      if (proc_flags)
+	{
+	  size -= 7 + field_size;
+	  if (p != buff + field_size + 4)
+	    {
+	      if (size < (2 + 1))
+		{
+		  warn (_("Internal error: not enough buffer room for section flag info"));
+		  return _("<unknown>");
+		}
+	      size -= 2;
+	      *p++ = ',';
+	      *p++ = ' ';
+	    }
+	  sprintf (p, "PROC (%*.*lx)", field_size, field_size,
+		   (unsigned long) proc_flags);
+	  p += 7 + field_size;
+	}
+      if (unknown_flags)
+	{
+	  size -= 10 + field_size;
+	  if (p != buff + field_size + 4)
+	    {
+	      if (size < (2 + 1))
+		{
+		  warn (_("Internal error: not enough buffer room for section flag info"));
+		  return _("<unknown>");
+		}
+	      size -= 2;
+	      *p++ = ',';
+	      *p++ = ' ';
+	    }
+	  sprintf (p, _("UNKNOWN (%*.*lx)"), field_size, field_size,
+		   (unsigned long) unknown_flags);
+	  p += 10 + field_size;
+	}
+    }
+
+  *p = '\0';
+  return buff;
+}
+
+static unsigned int ATTRIBUTE_WARN_UNUSED_RESULT
+get_compression_header (Elf_Internal_Chdr *chdr, unsigned char *buf, bfd_size_type size)
+{
+  if (is_32bit_elf)
+    {
+      Elf32_External_Chdr *echdr = (Elf32_External_Chdr *) buf;
+
+      if (size < sizeof (* echdr))
+	{
+	  error (_("Compressed section is too small even for a compression header\n"));
+	  return 0;
+	}
+
+      chdr->ch_type = BYTE_GET (echdr->ch_type);
+      chdr->ch_size = BYTE_GET (echdr->ch_size);
+      chdr->ch_addralign = BYTE_GET (echdr->ch_addralign);
+      return sizeof (*echdr);
+    }
+  else
+    {
+      Elf64_External_Chdr *echdr = (Elf64_External_Chdr *) buf;
+
+      if (size < sizeof (* echdr))
+	{
+	  error (_("Compressed section is too small even for a compression header\n"));
+	  return 0;
+	}
+
+      chdr->ch_type = BYTE_GET (echdr->ch_type);
+      chdr->ch_size = BYTE_GET (echdr->ch_size);
+      chdr->ch_addralign = BYTE_GET (echdr->ch_addralign);
+      return sizeof (*echdr);
+    }
+}
+
+static bool
+process_section_headers (Filedata * filedata)
+{
+  Elf_Internal_Shdr * section;
+  unsigned int i;
+
+  if (filedata->file_header.e_shnum == 0)
+    {
+      /* PR binutils/12467.  */
+      if (filedata->file_header.e_shoff != 0)
+	{
+	  warn (_("possibly corrupt ELF file header - it has a non-zero"
+		  " section header offset, but no section headers\n"));
+	  return false;
+	}
+      else if (do_sections)
+	printf (_("\nThere are no sections in this file.\n"));
+
+      return true;
+    }
+
+  if (do_sections && !do_header)
+    {
+      if (filedata->is_separate && process_links)
+	printf (_("In linked file '%s': "), filedata->file_name);
+      if (! filedata->is_separate || process_links)
+	printf (ngettext ("There is %d section header, "
+			  "starting at offset 0x%lx:\n",
+			  "There are %d section headers, "
+			  "starting at offset 0x%lx:\n",
+			  filedata->file_header.e_shnum),
+		filedata->file_header.e_shnum,
+		(unsigned long) filedata->file_header.e_shoff);
+    }
+
+  if (!get_section_headers (filedata, false))
+    return false;
+
+  /* Read in the string table, so that we have names to display.  */
+  if (filedata->file_header.e_shstrndx != SHN_UNDEF
+       && filedata->file_header.e_shstrndx < filedata->file_header.e_shnum)
+    {
+      section = filedata->section_headers + filedata->file_header.e_shstrndx;
+
+      if (section->sh_size != 0)
+	{
+	  filedata->string_table = (char *) get_data (NULL, filedata, section->sh_offset,
+						      1, section->sh_size,
+						      _("string table"));
+
+	  filedata->string_table_length = filedata->string_table != NULL ? section->sh_size : 0;
+	}
+    }
+
+  /* Scan the sections for the dynamic symbol table
+     and dynamic string table and debug sections.  */
+  eh_addr_size = is_32bit_elf ? 4 : 8;
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_MIPS:
+    case EM_MIPS_RS3_LE:
+      /* The 64-bit MIPS EABI uses a combination of 32-bit ELF and 64-bit
+	 FDE addresses.  However, the ABI also has a semi-official ILP32
+	 variant for which the normal FDE address size rules apply.
+
+	 GCC 4.0 marks EABI64 objects with a dummy .gcc_compiled_longXX
+	 section, where XX is the size of longs in bits.  Unfortunately,
+	 earlier compilers provided no way of distinguishing ILP32 objects
+	 from LP64 objects, so if there's any doubt, we should assume that
+	 the official LP64 form is being used.  */
+      if ((filedata->file_header.e_flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI64
+	  && find_section (filedata, ".gcc_compiled_long32") == NULL)
+	eh_addr_size = 8;
+      break;
+
+    case EM_H8_300:
+    case EM_H8_300H:
+      switch (filedata->file_header.e_flags & EF_H8_MACH)
+	{
+	case E_H8_MACH_H8300:
+	case E_H8_MACH_H8300HN:
+	case E_H8_MACH_H8300SN:
+	case E_H8_MACH_H8300SXN:
+	  eh_addr_size = 2;
+	  break;
+	case E_H8_MACH_H8300H:
+	case E_H8_MACH_H8300S:
+	case E_H8_MACH_H8300SX:
+	  eh_addr_size = 4;
+	  break;
+	}
+      break;
+
+    case EM_M32C_OLD:
+    case EM_M32C:
+      switch (filedata->file_header.e_flags & EF_M32C_CPU_MASK)
+	{
+	case EF_M32C_CPU_M16C:
+	  eh_addr_size = 2;
+	  break;
+	}
+      break;
+    }
+
+#define CHECK_ENTSIZE_VALUES(section, i, size32, size64)		\
+  do									\
+    {									\
+      bfd_size_type expected_entsize = is_32bit_elf ? size32 : size64;	\
+      if (section->sh_entsize != expected_entsize)			\
+	{								\
+	  char buf[40];							\
+	  sprintf_vma (buf, section->sh_entsize);			\
+	  /* Note: coded this way so that there is a single string for  \
+	     translation.  */ \
+	  error (_("Section %d has invalid sh_entsize of %s\n"), i, buf); \
+	  error (_("(Using the expected size of %u for the rest of this dump)\n"), \
+		   (unsigned) expected_entsize);			\
+	  section->sh_entsize = expected_entsize;			\
+	}								\
+    }									\
+  while (0)
+
+#define CHECK_ENTSIZE(section, i, type)					\
+  CHECK_ENTSIZE_VALUES (section, i, sizeof (Elf32_External_##type),	\
+			sizeof (Elf64_External_##type))
+
+  for (i = 0, section = filedata->section_headers;
+       i < filedata->file_header.e_shnum;
+       i++, section++)
+    {
+      char * name = SECTION_NAME_PRINT (section);
+
+      /* Run some sanity checks on the headers and
+	 possibly fill in some file data as well.  */
+      switch (section->sh_type)
+	{
+	case SHT_DYNSYM:
+	  if (filedata->dynamic_symbols != NULL)
+	    {
+	      error (_("File contains multiple dynamic symbol tables\n"));
+	      continue;
+	    }
+
+	  CHECK_ENTSIZE (section, i, Sym);
+	  filedata->dynamic_symbols
+	    = get_elf_symbols (filedata, section, &filedata->num_dynamic_syms);
+	  filedata->dynamic_symtab_section = section;
+	  break;
+
+	case SHT_STRTAB:
+	  if (streq (name, ".dynstr"))
+	    {
+	      if (filedata->dynamic_strings != NULL)
+		{
+		  error (_("File contains multiple dynamic string tables\n"));
+		  continue;
+		}
+
+	      filedata->dynamic_strings
+		= (char *) get_data (NULL, filedata, section->sh_offset,
+				     1, section->sh_size, _("dynamic strings"));
+	      filedata->dynamic_strings_length
+		= filedata->dynamic_strings == NULL ? 0 : section->sh_size;
+	      filedata->dynamic_strtab_section = section;
+	    }
+	  break;
+
+	case SHT_SYMTAB_SHNDX:
+	  {
+	    elf_section_list * entry = xmalloc (sizeof * entry);
+
+	    entry->hdr = section;
+	    entry->next = filedata->symtab_shndx_list;
+	    filedata->symtab_shndx_list = entry;
+	  }
+	  break;
+
+	case SHT_SYMTAB:
+	  CHECK_ENTSIZE (section, i, Sym);
+	  break;
+
+	case SHT_GROUP:
+	  CHECK_ENTSIZE_VALUES (section, i, GRP_ENTRY_SIZE, GRP_ENTRY_SIZE);
+	  break;
+
+	case SHT_REL:
+	  CHECK_ENTSIZE (section, i, Rel);
+	  if (do_checks && section->sh_size == 0)
+	    warn (_("Section '%s': zero-sized relocation section\n"), name);
+	  break;
+
+	case SHT_RELA:
+	  CHECK_ENTSIZE (section, i, Rela);
+	  if (do_checks && section->sh_size == 0)
+	    warn (_("Section '%s': zero-sized relocation section\n"), name);
+	  break;
+
+	case SHT_NOTE:
+	case SHT_PROGBITS:
+	  /* Having a zero sized section is not illegal according to the
+	     ELF standard, but it might be an indication that something
+	     is wrong.  So issue a warning if we are running in lint mode.  */
+	  if (do_checks && section->sh_size == 0)
+	    warn (_("Section '%s': has a size of zero - is this intended ?\n"), name);
+	  break;
+
+	default:
+	  break;
+	}
+
+      if ((do_debugging || do_debug_info || do_debug_abbrevs
+	   || do_debug_lines || do_debug_pubnames || do_debug_pubtypes
+	   || do_debug_aranges || do_debug_frames || do_debug_macinfo
+	   || do_debug_str || do_debug_str_offsets || do_debug_loc
+	   || do_debug_ranges
+	   || do_debug_addr || do_debug_cu_index || do_debug_links)
+	  && (startswith (name, ".debug_")
+	      || startswith (name, ".zdebug_")))
+	{
+          if (name[1] == 'z')
+            name += sizeof (".zdebug_") - 1;
+          else
+            name += sizeof (".debug_") - 1;
+
+	  if (do_debugging
+	      || (do_debug_info     && startswith (name, "info"))
+	      || (do_debug_info     && startswith (name, "types"))
+	      || (do_debug_abbrevs  && startswith (name, "abbrev"))
+	      || (do_debug_lines    && strcmp (name, "line") == 0)
+	      || (do_debug_lines    && startswith (name, "line."))
+	      || (do_debug_pubnames && startswith (name, "pubnames"))
+	      || (do_debug_pubtypes && startswith (name, "pubtypes"))
+	      || (do_debug_pubnames && startswith (name, "gnu_pubnames"))
+	      || (do_debug_pubtypes && startswith (name, "gnu_pubtypes"))
+	      || (do_debug_aranges  && startswith (name, "aranges"))
+	      || (do_debug_ranges   && startswith (name, "ranges"))
+	      || (do_debug_ranges   && startswith (name, "rnglists"))
+	      || (do_debug_frames   && startswith (name, "frame"))
+	      || (do_debug_macinfo  && startswith (name, "macinfo"))
+	      || (do_debug_macinfo  && startswith (name, "macro"))
+	      || (do_debug_str      && startswith (name, "str"))
+	      || (do_debug_links    && startswith (name, "sup"))
+	      || (do_debug_str_offsets && startswith (name, "str_offsets"))
+	      || (do_debug_loc      && startswith (name, "loc"))
+	      || (do_debug_loc      && startswith (name, "loclists"))
+	      || (do_debug_addr     && startswith (name, "addr"))
+	      || (do_debug_cu_index && startswith (name, "cu_index"))
+	      || (do_debug_cu_index && startswith (name, "tu_index"))
+	      )
+	    request_dump_bynumber (&filedata->dump, i, DEBUG_DUMP);
+	}
+      /* Linkonce section to be combined with .debug_info at link time.  */
+      else if ((do_debugging || do_debug_info)
+	       && startswith (name, ".gnu.linkonce.wi."))
+	request_dump_bynumber (&filedata->dump, i, DEBUG_DUMP);
+      else if (do_debug_frames && streq (name, ".eh_frame"))
+	request_dump_bynumber (&filedata->dump, i, DEBUG_DUMP);
+      else if (do_gdb_index && (streq (name, ".gdb_index")
+				|| streq (name, ".debug_names")))
+	request_dump_bynumber (&filedata->dump, i, DEBUG_DUMP);
+      /* Trace sections for Itanium VMS.  */
+      else if ((do_debugging || do_trace_info || do_trace_abbrevs
+                || do_trace_aranges)
+	       && startswith (name, ".trace_"))
+	{
+          name += sizeof (".trace_") - 1;
+
+	  if (do_debugging
+	      || (do_trace_info     && streq (name, "info"))
+	      || (do_trace_abbrevs  && streq (name, "abbrev"))
+	      || (do_trace_aranges  && streq (name, "aranges"))
+	      )
+	    request_dump_bynumber (&filedata->dump, i, DEBUG_DUMP);
+	}
+      else if ((do_debugging || do_debug_links)
+	       && (startswith (name, ".gnu_debuglink")
+		   || startswith (name, ".gnu_debugaltlink")))
+	request_dump_bynumber (&filedata->dump, i, DEBUG_DUMP);
+    }
+
+  if (! do_sections)
+    return true;
+
+  if (filedata->is_separate && ! process_links)
+    return true;
+
+  if (filedata->is_separate)
+    printf (_("\nSection Headers in linked file '%s':\n"), filedata->file_name);
+  else if (filedata->file_header.e_shnum > 1)
+    printf (_("\nSection Headers:\n"));
+  else
+    printf (_("\nSection Header:\n"));
+
+  if (is_32bit_elf)
+    {
+      if (do_section_details)
+	{
+	  printf (_("  [Nr] Name\n"));
+	  printf (_("       Type            Addr     Off    Size   ES   Lk Inf Al\n"));
+	}
+      else
+	printf
+	  (_("  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n"));
+    }
+  else if (do_wide)
+    {
+      if (do_section_details)
+	{
+	  printf (_("  [Nr] Name\n"));
+	  printf (_("       Type            Address          Off    Size   ES   Lk Inf Al\n"));
+	}
+      else
+	printf
+	  (_("  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n"));
+    }
+  else
+    {
+      if (do_section_details)
+	{
+	  printf (_("  [Nr] Name\n"));
+	  printf (_("       Type              Address          Offset            Link\n"));
+	  printf (_("       Size              EntSize          Info              Align\n"));
+	}
+      else
+	{
+	  printf (_("  [Nr] Name              Type             Address           Offset\n"));
+	  printf (_("       Size              EntSize          Flags  Link  Info  Align\n"));
+	}
+    }
+
+  if (do_section_details)
+    printf (_("       Flags\n"));
+
+  for (i = 0, section = filedata->section_headers;
+       i < filedata->file_header.e_shnum;
+       i++, section++)
+    {
+      /* Run some sanity checks on the section header.  */
+
+      /* Check the sh_link field.  */
+      switch (section->sh_type)
+	{
+	case SHT_REL:
+	case SHT_RELA:
+	  if (section->sh_link == 0
+	      && (filedata->file_header.e_type == ET_EXEC
+		  || filedata->file_header.e_type == ET_DYN))
+	    /* A dynamic relocation section where all entries use a
+	       zero symbol index need not specify a symtab section.  */
+	    break;
+	  /* Fall through.  */
+	case SHT_SYMTAB_SHNDX:
+	case SHT_GROUP:
+	case SHT_HASH:
+	case SHT_GNU_HASH:
+	case SHT_GNU_versym:
+	  if (section->sh_link == 0
+	      || section->sh_link >= filedata->file_header.e_shnum
+	      || (filedata->section_headers[section->sh_link].sh_type != SHT_SYMTAB
+		  && filedata->section_headers[section->sh_link].sh_type != SHT_DYNSYM))
+	    warn (_("[%2u]: Link field (%u) should index a symtab section.\n"),
+		  i, section->sh_link);
+	  break;
+
+	case SHT_DYNAMIC:
+	case SHT_SYMTAB:
+	case SHT_DYNSYM:
+	case SHT_GNU_verneed:
+	case SHT_GNU_verdef:
+	case SHT_GNU_LIBLIST:
+	  if (section->sh_link == 0
+	      || section->sh_link >= filedata->file_header.e_shnum
+	      || filedata->section_headers[section->sh_link].sh_type != SHT_STRTAB)
+	    warn (_("[%2u]: Link field (%u) should index a string section.\n"),
+		  i, section->sh_link);
+	  break;
+
+	case SHT_INIT_ARRAY:
+	case SHT_FINI_ARRAY:
+	case SHT_PREINIT_ARRAY:
+	  if (section->sh_type < SHT_LOOS && section->sh_link != 0)
+	    warn (_("[%2u]: Unexpected value (%u) in link field.\n"),
+		  i, section->sh_link);
+	  break;
+
+	default:
+	  /* FIXME: Add support for target specific section types.  */
+#if 0 	  /* Currently we do not check other section types as there are too
+	     many special cases.  Stab sections for example have a type
+	     of SHT_PROGBITS but an sh_link field that links to the .stabstr
+	     section.  */
+	  if (section->sh_type < SHT_LOOS && section->sh_link != 0)
+	    warn (_("[%2u]: Unexpected value (%u) in link field.\n"),
+		  i, section->sh_link);
+#endif
+	  break;
+	}
+
+      /* Check the sh_info field.  */
+      switch (section->sh_type)
+	{
+	case SHT_REL:
+	case SHT_RELA:
+	  if (section->sh_info == 0
+	      && (filedata->file_header.e_type == ET_EXEC
+		  || filedata->file_header.e_type == ET_DYN))
+	    /* Dynamic relocations apply to segments, so they do not
+	       need to specify the section they relocate.  */
+	    break;
+	  if (section->sh_info == 0
+	      || section->sh_info >= filedata->file_header.e_shnum
+	      || (filedata->section_headers[section->sh_info].sh_type != SHT_PROGBITS
+		  && filedata->section_headers[section->sh_info].sh_type != SHT_NOBITS
+		  && filedata->section_headers[section->sh_info].sh_type != SHT_NOTE
+		  && filedata->section_headers[section->sh_info].sh_type != SHT_INIT_ARRAY
+		  && filedata->section_headers[section->sh_info].sh_type != SHT_FINI_ARRAY
+		  && filedata->section_headers[section->sh_info].sh_type != SHT_PREINIT_ARRAY
+		  /* FIXME: Are other section types valid ?  */
+		  && filedata->section_headers[section->sh_info].sh_type < SHT_LOOS))
+	    warn (_("[%2u]: Info field (%u) should index a relocatable section.\n"),
+		  i, section->sh_info);
+	  break;
+
+	case SHT_DYNAMIC:
+	case SHT_HASH:
+	case SHT_SYMTAB_SHNDX:
+	case SHT_INIT_ARRAY:
+	case SHT_FINI_ARRAY:
+	case SHT_PREINIT_ARRAY:
+	  if (section->sh_info != 0)
+	    warn (_("[%2u]: Unexpected value (%u) in info field.\n"),
+		  i, section->sh_info);
+	  break;
+
+	case SHT_GROUP:
+	case SHT_SYMTAB:
+	case SHT_DYNSYM:
+	  /* A symbol index - we assume that it is valid.  */
+	  break;
+
+	default:
+	  /* FIXME: Add support for target specific section types.  */
+	  if (section->sh_type == SHT_NOBITS)
+	    /* NOBITS section headers with non-zero sh_info fields can be
+	       created when a binary is stripped of everything but its debug
+	       information.  The stripped sections have their headers
+	       preserved but their types set to SHT_NOBITS.  So do not check
+	       this type of section.  */
+	    ;
+	  else if (section->sh_flags & SHF_INFO_LINK)
+	    {
+	      if (section->sh_info < 1 || section->sh_info >= filedata->file_header.e_shnum)
+		warn (_("[%2u]: Expected link to another section in info field"), i);
+	    }
+	  else if (section->sh_type < SHT_LOOS
+		   && (section->sh_flags & SHF_GNU_MBIND) == 0
+		   && section->sh_info != 0)
+	    warn (_("[%2u]: Unexpected value (%u) in info field.\n"),
+		  i, section->sh_info);
+	  break;
+	}
+
+      /* Check the sh_size field.  */
+      if (section->sh_size > filedata->file_size
+	  && section->sh_type != SHT_NOBITS
+	  && section->sh_type != SHT_NULL
+	  && section->sh_type < SHT_LOOS)
+	warn (_("Size of section %u is larger than the entire file!\n"), i);
+
+      printf ("  [%2u] ", i);
+      if (do_section_details)
+	printf ("%s\n      ", printable_section_name (filedata, section));
+      else
+	print_symbol (-17, SECTION_NAME_PRINT (section));
+
+      printf (do_wide ? " %-15s " : " %-15.15s ",
+	      get_section_type_name (filedata, section->sh_type));
+
+      if (is_32bit_elf)
+	{
+	  const char * link_too_big = NULL;
+
+	  print_vma (section->sh_addr, LONG_HEX);
+
+	  printf ( " %6.6lx %6.6lx %2.2lx",
+		   (unsigned long) section->sh_offset,
+		   (unsigned long) section->sh_size,
+		   (unsigned long) section->sh_entsize);
+
+	  if (do_section_details)
+	    fputs ("  ", stdout);
+	  else
+	    printf (" %3s ", get_elf_section_flags (filedata, section->sh_flags));
+
+	  if (section->sh_link >= filedata->file_header.e_shnum)
+	    {
+	      link_too_big = "";
+	      /* The sh_link value is out of range.  Normally this indicates
+		 an error but it can have special values in Solaris binaries.  */
+	      switch (filedata->file_header.e_machine)
+		{
+		case EM_386:
+		case EM_IAMCU:
+		case EM_X86_64:
+		case EM_L1OM:
+		case EM_K1OM:
+		case EM_OLD_SPARCV9:
+		case EM_SPARC32PLUS:
+		case EM_SPARCV9:
+		case EM_SPARC:
+		  if (section->sh_link == (SHN_BEFORE & 0xffff))
+		    link_too_big = "BEFORE";
+		  else if (section->sh_link == (SHN_AFTER & 0xffff))
+		    link_too_big = "AFTER";
+		  break;
+		default:
+		  break;
+		}
+	    }
+
+	  if (do_section_details)
+	    {
+	      if (link_too_big != NULL && * link_too_big)
+		printf ("<%s> ", link_too_big);
+	      else
+		printf ("%2u ", section->sh_link);
+	      printf ("%3u %2lu\n", section->sh_info,
+		      (unsigned long) section->sh_addralign);
+	    }
+	  else
+	    printf ("%2u %3u %2lu\n",
+		    section->sh_link,
+		    section->sh_info,
+		    (unsigned long) section->sh_addralign);
+
+	  if (link_too_big && ! * link_too_big)
+	    warn (_("section %u: sh_link value of %u is larger than the number of sections\n"),
+		  i, section->sh_link);
+	}
+      else if (do_wide)
+	{
+	  print_vma (section->sh_addr, LONG_HEX);
+
+	  if ((long) section->sh_offset == section->sh_offset)
+	    printf (" %6.6lx", (unsigned long) section->sh_offset);
+	  else
+	    {
+	      putchar (' ');
+	      print_vma (section->sh_offset, LONG_HEX);
+	    }
+
+	  if ((unsigned long) section->sh_size == section->sh_size)
+	    printf (" %6.6lx", (unsigned long) section->sh_size);
+	  else
+	    {
+	      putchar (' ');
+	      print_vma (section->sh_size, LONG_HEX);
+	    }
+
+	  if ((unsigned long) section->sh_entsize == section->sh_entsize)
+	    printf (" %2.2lx", (unsigned long) section->sh_entsize);
+	  else
+	    {
+	      putchar (' ');
+	      print_vma (section->sh_entsize, LONG_HEX);
+	    }
+
+	  if (do_section_details)
+	    fputs ("  ", stdout);
+	  else
+	    printf (" %3s ", get_elf_section_flags (filedata, section->sh_flags));
+
+	  printf ("%2u %3u ", section->sh_link, section->sh_info);
+
+	  if ((unsigned long) section->sh_addralign == section->sh_addralign)
+	    printf ("%2lu\n", (unsigned long) section->sh_addralign);
+	  else
+	    {
+	      print_vma (section->sh_addralign, DEC);
+	      putchar ('\n');
+	    }
+	}
+      else if (do_section_details)
+	{
+	  putchar (' ');
+	  print_vma (section->sh_addr, LONG_HEX);
+	  if ((long) section->sh_offset == section->sh_offset)
+	    printf ("  %16.16lx", (unsigned long) section->sh_offset);
+	  else
+	    {
+	      printf ("  ");
+	      print_vma (section->sh_offset, LONG_HEX);
+	    }
+	  printf ("  %u\n       ", section->sh_link);
+	  print_vma (section->sh_size, LONG_HEX);
+	  putchar (' ');
+	  print_vma (section->sh_entsize, LONG_HEX);
+
+	  printf ("  %-16u  %lu\n",
+		  section->sh_info,
+		  (unsigned long) section->sh_addralign);
+	}
+      else
+	{
+	  putchar (' ');
+	  print_vma (section->sh_addr, LONG_HEX);
+	  if ((long) section->sh_offset == section->sh_offset)
+	    printf ("  %8.8lx", (unsigned long) section->sh_offset);
+	  else
+	    {
+	      printf ("  ");
+	      print_vma (section->sh_offset, LONG_HEX);
+	    }
+	  printf ("\n       ");
+	  print_vma (section->sh_size, LONG_HEX);
+	  printf ("  ");
+	  print_vma (section->sh_entsize, LONG_HEX);
+
+	  printf (" %3s ", get_elf_section_flags (filedata, section->sh_flags));
+
+	  printf ("     %2u   %3u     %lu\n",
+		  section->sh_link,
+		  section->sh_info,
+		  (unsigned long) section->sh_addralign);
+	}
+
+      if (do_section_details)
+	{
+	  printf ("       %s\n", get_elf_section_flags (filedata, section->sh_flags));
+	  if ((section->sh_flags & SHF_COMPRESSED) != 0)
+	    {
+	      /* Minimum section size is 12 bytes for 32-bit compression
+		 header + 12 bytes for compressed data header.  */
+	      unsigned char buf[24];
+
+	      assert (sizeof (buf) >= sizeof (Elf64_External_Chdr));
+	      if (get_data (&buf, filedata, section->sh_offset, 1,
+			    sizeof (buf), _("compression header")))
+		{
+		  Elf_Internal_Chdr chdr;
+
+		  if (get_compression_header (&chdr, buf, sizeof (buf)) == 0)
+		    printf (_("       [<corrupt>]\n"));
+		  else
+		    {
+		      if (chdr.ch_type == ELFCOMPRESS_ZLIB)
+			printf ("       ZLIB, ");
+		      else
+			printf (_("       [<unknown>: 0x%x], "),
+				chdr.ch_type);
+		      print_vma (chdr.ch_size, LONG_HEX);
+		      printf (", %lu\n", (unsigned long) chdr.ch_addralign);
+		    }
+		}
+	    }
+	}
+    }
+
+  if (!do_section_details)
+    {
+      /* The ordering of the letters shown here matches the ordering of the
+	 corresponding SHF_xxx values, and hence the order in which these
+	 letters will be displayed to the user.  */
+      printf (_("Key to Flags:\n\
+  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n\
+  L (link order), O (extra OS processing required), G (group), T (TLS),\n\
+  C (compressed), x (unknown), o (OS specific), E (exclude),\n  "));
+      switch (filedata->file_header.e_ident[EI_OSABI])
+	{
+	case ELFOSABI_GNU:
+	case ELFOSABI_FREEBSD:
+	  printf (_("R (retain), "));
+	  /* Fall through */
+	case ELFOSABI_NONE:
+	  printf (_("D (mbind), "));
+	  break;
+	default:
+	  break;
+	}
+      if (filedata->file_header.e_machine == EM_X86_64
+	  || filedata->file_header.e_machine == EM_L1OM
+	  || filedata->file_header.e_machine == EM_K1OM)
+	printf (_("l (large), "));
+      else if (filedata->file_header.e_machine == EM_ARM)
+	printf (_("y (purecode), "));
+      else if (filedata->file_header.e_machine == EM_PPC)
+	printf (_("v (VLE), "));
+      printf ("p (processor specific)\n");
+    }
+
+  return true;
+}
+
+static bool
+get_symtab (Filedata *filedata, Elf_Internal_Shdr *symsec,
+	    Elf_Internal_Sym **symtab, unsigned long *nsyms,
+	    char **strtab, unsigned long *strtablen)
+{
+  *strtab = NULL;
+  *strtablen = 0;
+  *symtab = get_elf_symbols (filedata, symsec, nsyms);
+
+  if (*symtab == NULL)
+    return false;
+
+  if (symsec->sh_link != 0)
+    {
+      Elf_Internal_Shdr *strsec;
+
+      if (symsec->sh_link >= filedata->file_header.e_shnum)
+	{
+	  error (_("Bad sh_link in symbol table section\n"));
+	  free (*symtab);
+	  *symtab = NULL;
+	  *nsyms = 0;
+	  return false;
+	}
+
+      strsec = filedata->section_headers + symsec->sh_link;
+
+      *strtab = (char *) get_data (NULL, filedata, strsec->sh_offset,
+				   1, strsec->sh_size, _("string table"));
+      if (*strtab == NULL)
+	{
+	  free (*symtab);
+	  *symtab = NULL;
+	  *nsyms = 0;
+	  return false;
+	}
+      *strtablen = strsec->sh_size;
+    }
+  return true;
+}
+
+static const char *
+get_group_flags (unsigned int flags)
+{
+  static char buff[128];
+
+  if (flags == 0)
+    return "";
+  else if (flags == GRP_COMDAT)
+    return "COMDAT ";
+
+  snprintf (buff, sizeof buff, "[0x%x: %s%s%s]",
+	    flags,
+	    flags & GRP_MASKOS ? _("<OS specific>") : "",
+	    flags & GRP_MASKPROC ? _("<PROC specific>") : "",
+	    (flags & ~(GRP_COMDAT | GRP_MASKOS | GRP_MASKPROC)
+	     ? _("<unknown>") : ""));
+
+  return buff;
+}
+
+static bool
+process_section_groups (Filedata * filedata)
+{
+  Elf_Internal_Shdr * section;
+  unsigned int i;
+  struct group * group;
+  Elf_Internal_Shdr * symtab_sec;
+  Elf_Internal_Shdr * strtab_sec;
+  Elf_Internal_Sym * symtab;
+  unsigned long num_syms;
+  char * strtab;
+  size_t strtab_size;
+
+  /* Don't process section groups unless needed.  */
+  if (!do_unwind && !do_section_groups)
+    return true;
+
+  if (filedata->file_header.e_shnum == 0)
+    {
+      if (do_section_groups)
+	{
+	  if (filedata->is_separate)
+	    printf (_("\nThere are no sections group in linked file '%s'.\n"),
+		    filedata->file_name);
+	  else
+	    printf (_("\nThere are no section groups in this file.\n"));
+	}
+      return true;
+    }
+
+  if (filedata->section_headers == NULL)
+    {
+      error (_("Section headers are not available!\n"));
+      /* PR 13622: This can happen with a corrupt ELF header.  */
+      return false;
+    }
+
+  filedata->section_headers_groups
+    = (struct group **) calloc (filedata->file_header.e_shnum,
+				sizeof (struct group *));
+
+  if (filedata->section_headers_groups == NULL)
+    {
+      error (_("Out of memory reading %u section group headers\n"),
+	     filedata->file_header.e_shnum);
+      return false;
+    }
+
+  /* Scan the sections for the group section.  */
+  filedata->group_count = 0;
+  for (i = 0, section = filedata->section_headers;
+       i < filedata->file_header.e_shnum;
+       i++, section++)
+    if (section->sh_type == SHT_GROUP)
+      filedata->group_count++;
+
+  if (filedata->group_count == 0)
+    {
+      if (do_section_groups)
+	{
+	  if (filedata->is_separate)
+	    printf (_("\nThere are no section groups in linked file '%s'.\n"),
+		    filedata->file_name);
+	  else
+	    printf (_("\nThere are no section groups in this file.\n"));
+	}
+
+      return true;
+    }
+
+  filedata->section_groups = (struct group *) calloc (filedata->group_count,
+						      sizeof (struct group));
+
+  if (filedata->section_groups == NULL)
+    {
+      error (_("Out of memory reading %lu groups\n"),
+	     (unsigned long) filedata->group_count);
+      return false;
+    }
+
+  symtab_sec = NULL;
+  strtab_sec = NULL;
+  symtab = NULL;
+  num_syms = 0;
+  strtab = NULL;
+  strtab_size = 0;
+
+  if (filedata->is_separate)
+    printf (_("Section groups in linked file '%s'\n"), filedata->file_name);
+
+  for (i = 0, section = filedata->section_headers, group = filedata->section_groups;
+       i < filedata->file_header.e_shnum;
+       i++, section++)
+    {
+      if (section->sh_type == SHT_GROUP)
+	{
+	  const char * name = printable_section_name (filedata, section);
+	  const char * group_name;
+	  unsigned char * start;
+	  unsigned char * indices;
+	  unsigned int entry, j, size;
+	  Elf_Internal_Shdr * sec;
+	  Elf_Internal_Sym * sym;
+
+	  /* Get the symbol table.  */
+	  if (section->sh_link >= filedata->file_header.e_shnum
+	      || ((sec = filedata->section_headers + section->sh_link)->sh_type
+		  != SHT_SYMTAB))
+	    {
+	      error (_("Bad sh_link in group section `%s'\n"), name);
+	      continue;
+	    }
+
+	  if (symtab_sec != sec)
+	    {
+	      symtab_sec = sec;
+	      free (symtab);
+	      symtab = get_elf_symbols (filedata, symtab_sec, & num_syms);
+	    }
+
+	  if (symtab == NULL)
+	    {
+	      error (_("Corrupt header in group section `%s'\n"), name);
+	      continue;
+	    }
+
+	  if (section->sh_info >= num_syms)
+	    {
+	      error (_("Bad sh_info in group section `%s'\n"), name);
+	      continue;
+	    }
+
+	  sym = symtab + section->sh_info;
+
+	  if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
+	    {
+	      if (sym->st_shndx == 0
+		  || sym->st_shndx >= filedata->file_header.e_shnum)
+		{
+		  error (_("Bad sh_info in group section `%s'\n"), name);
+		  continue;
+		}
+
+	      group_name = SECTION_NAME_PRINT (filedata->section_headers
+					       + sym->st_shndx);
+	      strtab_sec = NULL;
+	      free (strtab);
+	      strtab = NULL;
+	      strtab_size = 0;
+	    }
+	  else
+	    {
+	      /* Get the string table.  */
+	      if (symtab_sec->sh_link >= filedata->file_header.e_shnum)
+		{
+		  strtab_sec = NULL;
+		  free (strtab);
+		  strtab = NULL;
+		  strtab_size = 0;
+		}
+	      else if (strtab_sec
+		       != (sec = filedata->section_headers + symtab_sec->sh_link))
+		{
+		  strtab_sec = sec;
+		  free (strtab);
+
+		  strtab = (char *) get_data (NULL, filedata, strtab_sec->sh_offset,
+					      1, strtab_sec->sh_size,
+					      _("string table"));
+		  strtab_size = strtab != NULL ? strtab_sec->sh_size : 0;
+		}
+	      group_name = sym->st_name < strtab_size
+		? strtab + sym->st_name : _("<corrupt>");
+	    }
+
+	  /* PR 17531: file: loop.  */
+	  if (section->sh_entsize > section->sh_size)
+	    {
+	      error (_("Section %s has sh_entsize (0x%lx) which is larger than its size (0x%lx)\n"),
+		     printable_section_name (filedata, section),
+		     (unsigned long) section->sh_entsize,
+		     (unsigned long) section->sh_size);
+	      continue;
+	    }
+
+	  start = (unsigned char *) get_data (NULL, filedata, section->sh_offset,
+                                              1, section->sh_size,
+                                              _("section data"));
+	  if (start == NULL)
+	    continue;
+
+	  indices = start;
+	  size = (section->sh_size / section->sh_entsize) - 1;
+	  entry = byte_get (indices, 4);
+	  indices += 4;
+
+	  if (do_section_groups)
+	    {
+	      printf (_("\n%sgroup section [%5u] `%s' [%s] contains %u sections:\n"),
+		      get_group_flags (entry), i, name, group_name, size);
+
+	      printf (_("   [Index]    Name\n"));
+	    }
+
+	  group->group_index = i;
+
+	  for (j = 0; j < size; j++)
+	    {
+	      struct group_list * g;
+
+	      entry = byte_get (indices, 4);
+	      indices += 4;
+
+	      if (entry >= filedata->file_header.e_shnum)
+		{
+		  static unsigned num_group_errors = 0;
+
+		  if (num_group_errors ++ < 10)
+		    {
+		      error (_("section [%5u] in group section [%5u] > maximum section [%5u]\n"),
+			     entry, i, filedata->file_header.e_shnum - 1);
+		      if (num_group_errors == 10)
+			warn (_("Further error messages about overlarge group section indices suppressed\n"));
+		    }
+		  continue;
+		}
+
+	      if (filedata->section_headers_groups [entry] != NULL)
+		{
+		  if (entry)
+		    {
+		      static unsigned num_errs = 0;
+
+		      if (num_errs ++ < 10)
+			{
+			  error (_("section [%5u] in group section [%5u] already in group section [%5u]\n"),
+				 entry, i,
+				 filedata->section_headers_groups [entry]->group_index);
+			  if (num_errs == 10)
+			    warn (_("Further error messages about already contained group sections suppressed\n"));
+			}
+		      continue;
+		    }
+		  else
+		    {
+		      /* Intel C/C++ compiler may put section 0 in a
+			 section group.  We just warn it the first time
+			 and ignore it afterwards.  */
+		      static bool warned = false;
+		      if (!warned)
+			{
+			  error (_("section 0 in group section [%5u]\n"),
+				 filedata->section_headers_groups [entry]->group_index);
+			  warned = true;
+			}
+		    }
+		}
+
+	      filedata->section_headers_groups [entry] = group;
+
+	      if (do_section_groups)
+		{
+		  sec = filedata->section_headers + entry;
+		  printf ("   [%5u]   %s\n", entry, printable_section_name (filedata, sec));
+		}
+
+	      g = (struct group_list *) xmalloc (sizeof (struct group_list));
+	      g->section_index = entry;
+	      g->next = group->root;
+	      group->root = g;
+	    }
+
+	  free (start);
+
+	  group++;
+	}
+    }
+
+  free (symtab);
+  free (strtab);
+  return true;
+}
+
+/* Data used to display dynamic fixups.  */
+
+struct ia64_vms_dynfixup
+{
+  bfd_vma needed_ident;		/* Library ident number.  */
+  bfd_vma needed;		/* Index in the dstrtab of the library name.  */
+  bfd_vma fixup_needed;		/* Index of the library.  */
+  bfd_vma fixup_rela_cnt;	/* Number of fixups.  */
+  bfd_vma fixup_rela_off;	/* Fixups offset in the dynamic segment.  */
+};
+
+/* Data used to display dynamic relocations.  */
+
+struct ia64_vms_dynimgrela
+{
+  bfd_vma img_rela_cnt;		/* Number of relocations.  */
+  bfd_vma img_rela_off;		/* Reloc offset in the dynamic segment.  */
+};
+
+/* Display IA-64 OpenVMS dynamic fixups (used to dynamically link a shared
+   library).  */
+
+static bool
+dump_ia64_vms_dynamic_fixups (Filedata *                  filedata,
+			      struct ia64_vms_dynfixup *  fixup,
+                              const char *                strtab,
+			      unsigned int                strtab_sz)
+{
+  Elf64_External_VMS_IMAGE_FIXUP * imfs;
+  long i;
+  const char * lib_name;
+
+  imfs = get_data (NULL, filedata,
+		   filedata->dynamic_addr + fixup->fixup_rela_off,
+		   sizeof (*imfs), fixup->fixup_rela_cnt,
+		   _("dynamic section image fixups"));
+  if (!imfs)
+    return false;
+
+  if (fixup->needed < strtab_sz)
+    lib_name = strtab + fixup->needed;
+  else
+    {
+      warn (_("corrupt library name index of 0x%lx found in dynamic entry"),
+            (unsigned long) fixup->needed);
+      lib_name = "???";
+    }
+
+  printf (_("\nImage fixups for needed library #%d: %s - ident: %lx\n"),
+	  (int) fixup->fixup_needed, lib_name, (long) fixup->needed_ident);
+  printf
+    (_("Seg Offset           Type                             SymVec DataType\n"));
+
+  for (i = 0; i < (long) fixup->fixup_rela_cnt; i++)
+    {
+      unsigned int type;
+      const char *rtype;
+
+      printf ("%3u ", (unsigned) BYTE_GET (imfs [i].fixup_seg));
+      printf_vma ((bfd_vma) BYTE_GET (imfs [i].fixup_offset));
+      type = BYTE_GET (imfs [i].type);
+      rtype = elf_ia64_reloc_type (type);
+      if (rtype == NULL)
+        printf (" 0x%08x                       ", type);
+      else
+        printf (" %-32s ", rtype);
+      printf ("%6u ", (unsigned) BYTE_GET (imfs [i].symvec_index));
+      printf ("0x%08x\n", (unsigned) BYTE_GET (imfs [i].data_type));
+    }
+
+  free (imfs);
+  return true;
+}
+
+/* Display IA-64 OpenVMS dynamic relocations (used to relocate an image).  */
+
+static bool
+dump_ia64_vms_dynamic_relocs (Filedata * filedata, struct ia64_vms_dynimgrela *imgrela)
+{
+  Elf64_External_VMS_IMAGE_RELA *imrs;
+  long i;
+
+  imrs = get_data (NULL, filedata,
+		   filedata->dynamic_addr + imgrela->img_rela_off,
+		   sizeof (*imrs), imgrela->img_rela_cnt,
+		   _("dynamic section image relocations"));
+  if (!imrs)
+    return false;
+
+  printf (_("\nImage relocs\n"));
+  printf
+    (_("Seg Offset   Type                            Addend            Seg Sym Off\n"));
+
+  for (i = 0; i < (long) imgrela->img_rela_cnt; i++)
+    {
+      unsigned int type;
+      const char *rtype;
+
+      printf ("%3u ", (unsigned) BYTE_GET (imrs [i].rela_seg));
+      printf ("%08" BFD_VMA_FMT "x ",
+              (bfd_vma) BYTE_GET (imrs [i].rela_offset));
+      type = BYTE_GET (imrs [i].type);
+      rtype = elf_ia64_reloc_type (type);
+      if (rtype == NULL)
+        printf ("0x%08x                      ", type);
+      else
+        printf ("%-31s ", rtype);
+      print_vma (BYTE_GET (imrs [i].addend), FULL_HEX);
+      printf ("%3u ", (unsigned) BYTE_GET (imrs [i].sym_seg));
+      printf ("%08" BFD_VMA_FMT "x\n",
+              (bfd_vma) BYTE_GET (imrs [i].sym_offset));
+    }
+
+  free (imrs);
+  return true;
+}
+
+/* Display IA-64 OpenVMS dynamic relocations and fixups.  */
+
+static bool
+process_ia64_vms_dynamic_relocs (Filedata * filedata)
+{
+  struct ia64_vms_dynfixup fixup;
+  struct ia64_vms_dynimgrela imgrela;
+  Elf_Internal_Dyn *entry;
+  bfd_vma strtab_off = 0;
+  bfd_vma strtab_sz = 0;
+  char *strtab = NULL;
+  bool res = true;
+
+  memset (&fixup, 0, sizeof (fixup));
+  memset (&imgrela, 0, sizeof (imgrela));
+
+  /* Note: the order of the entries is specified by the OpenVMS specs.  */
+  for (entry = filedata->dynamic_section;
+       entry < filedata->dynamic_section + filedata->dynamic_nent;
+       entry++)
+    {
+      switch (entry->d_tag)
+        {
+        case DT_IA_64_VMS_STRTAB_OFFSET:
+          strtab_off = entry->d_un.d_val;
+          break;
+        case DT_STRSZ:
+          strtab_sz = entry->d_un.d_val;
+          if (strtab == NULL)
+	    strtab = get_data (NULL, filedata,
+			       filedata->dynamic_addr + strtab_off,
+                               1, strtab_sz, _("dynamic string section"));
+	  if (strtab == NULL)
+	    strtab_sz = 0;
+          break;
+
+        case DT_IA_64_VMS_NEEDED_IDENT:
+          fixup.needed_ident = entry->d_un.d_val;
+          break;
+        case DT_NEEDED:
+          fixup.needed = entry->d_un.d_val;
+          break;
+        case DT_IA_64_VMS_FIXUP_NEEDED:
+          fixup.fixup_needed = entry->d_un.d_val;
+          break;
+        case DT_IA_64_VMS_FIXUP_RELA_CNT:
+          fixup.fixup_rela_cnt = entry->d_un.d_val;
+          break;
+        case DT_IA_64_VMS_FIXUP_RELA_OFF:
+          fixup.fixup_rela_off = entry->d_un.d_val;
+          if (! dump_ia64_vms_dynamic_fixups (filedata, &fixup, strtab, strtab_sz))
+	    res = false;
+          break;
+        case DT_IA_64_VMS_IMG_RELA_CNT:
+	  imgrela.img_rela_cnt = entry->d_un.d_val;
+          break;
+        case DT_IA_64_VMS_IMG_RELA_OFF:
+	  imgrela.img_rela_off = entry->d_un.d_val;
+          if (! dump_ia64_vms_dynamic_relocs (filedata, &imgrela))
+	    res = false;
+          break;
+
+        default:
+          break;
+	}
+    }
+
+  free (strtab);
+
+  return res;
+}
+
+static struct
+{
+  const char * name;
+  int reloc;
+  int size;
+  int rela;
+}
+  dynamic_relocations [] =
+{
+  { "REL", DT_REL, DT_RELSZ, false },
+  { "RELA", DT_RELA, DT_RELASZ, true },
+  { "PLT", DT_JMPREL, DT_PLTRELSZ, UNKNOWN }
+};
+
+/* Process the reloc section.  */
+
+static bool
+process_relocs (Filedata * filedata)
+{
+  unsigned long rel_size;
+  unsigned long rel_offset;
+
+  if (!do_reloc)
+    return true;
+
+  if (do_using_dynamic)
+    {
+      int          is_rela;
+      const char * name;
+      bool  has_dynamic_reloc;
+      unsigned int i;
+
+      has_dynamic_reloc = false;
+
+      for (i = 0; i < ARRAY_SIZE (dynamic_relocations); i++)
+	{
+	  is_rela = dynamic_relocations [i].rela;
+	  name = dynamic_relocations [i].name;
+	  rel_size = filedata->dynamic_info[dynamic_relocations [i].size];
+	  rel_offset = filedata->dynamic_info[dynamic_relocations [i].reloc];
+
+	  if (rel_size)
+	    has_dynamic_reloc = true;
+
+	  if (is_rela == UNKNOWN)
+	    {
+	      if (dynamic_relocations [i].reloc == DT_JMPREL)
+		switch (filedata->dynamic_info[DT_PLTREL])
+		  {
+		  case DT_REL:
+		    is_rela = false;
+		    break;
+		  case DT_RELA:
+		    is_rela = true;
+		    break;
+		  }
+	    }
+
+	  if (rel_size)
+	    {
+	      if (filedata->is_separate)
+		printf
+		  (_("\nIn linked file '%s' section '%s' at offset 0x%lx contains %ld bytes:\n"),
+		   filedata->file_name, name, rel_offset, rel_size);
+	      else
+		printf
+		  (_("\n'%s' relocation section at offset 0x%lx contains %ld bytes:\n"),
+		   name, rel_offset, rel_size);
+
+	      dump_relocations (filedata,
+				offset_from_vma (filedata, rel_offset, rel_size),
+				rel_size,
+				filedata->dynamic_symbols,
+				filedata->num_dynamic_syms,
+				filedata->dynamic_strings,
+				filedata->dynamic_strings_length,
+				is_rela, true /* is_dynamic */);
+	    }
+	}
+
+      if (is_ia64_vms (filedata))
+        if (process_ia64_vms_dynamic_relocs (filedata))
+	  has_dynamic_reloc = true;
+
+      if (! has_dynamic_reloc)
+	{
+	  if (filedata->is_separate)
+	    printf (_("\nThere are no dynamic relocations in linked file '%s'.\n"),
+		    filedata->file_name);
+	  else
+	    printf (_("\nThere are no dynamic relocations in this file.\n"));
+	}
+    }
+  else
+    {
+      Elf_Internal_Shdr * section;
+      unsigned long i;
+      bool found = false;
+
+      for (i = 0, section = filedata->section_headers;
+	   i < filedata->file_header.e_shnum;
+	   i++, section++)
+	{
+	  if (   section->sh_type != SHT_RELA
+	      && section->sh_type != SHT_REL)
+	    continue;
+
+	  rel_offset = section->sh_offset;
+	  rel_size   = section->sh_size;
+
+	  if (rel_size)
+	    {
+	      int is_rela;
+	      unsigned long num_rela;
+
+	      if (filedata->is_separate)
+		printf (_("\nIn linked file '%s' relocation section "),
+			filedata->file_name);
+	      else
+		printf (_("\nRelocation section "));
+
+	      if (filedata->string_table == NULL)
+		printf ("%d", section->sh_name);
+	      else
+		printf ("'%s'", printable_section_name (filedata, section));
+
+	      num_rela = rel_size / section->sh_entsize;
+	      printf (ngettext (" at offset 0x%lx contains %lu entry:\n",
+				" at offset 0x%lx contains %lu entries:\n",
+				num_rela),
+		      rel_offset, num_rela);
+
+	      is_rela = section->sh_type == SHT_RELA;
+
+	      if (section->sh_link != 0
+		  && section->sh_link < filedata->file_header.e_shnum)
+		{
+		  Elf_Internal_Shdr * symsec;
+		  Elf_Internal_Sym *  symtab;
+		  unsigned long nsyms;
+		  unsigned long strtablen = 0;
+		  char * strtab = NULL;
+
+		  symsec = filedata->section_headers + section->sh_link;
+		  if (symsec->sh_type != SHT_SYMTAB
+		      && symsec->sh_type != SHT_DYNSYM)
+                    continue;
+
+		  if (!get_symtab (filedata, symsec,
+				   &symtab, &nsyms, &strtab, &strtablen))
+		    continue;
+
+		  dump_relocations (filedata, rel_offset, rel_size,
+				    symtab, nsyms, strtab, strtablen,
+				    is_rela,
+				    symsec->sh_type == SHT_DYNSYM);
+		  free (strtab);
+		  free (symtab);
+		}
+	      else
+		dump_relocations (filedata, rel_offset, rel_size,
+				  NULL, 0, NULL, 0, is_rela,
+				  false /* is_dynamic */);
+
+	      found = true;
+	    }
+	}
+
+      if (! found)
+	{
+	  /* Users sometimes forget the -D option, so try to be helpful.  */
+	  for (i = 0; i < ARRAY_SIZE (dynamic_relocations); i++)
+	    {
+	      if (filedata->dynamic_info[dynamic_relocations [i].size])
+		{
+		  if (filedata->is_separate)
+		    printf (_("\nThere are no static relocations in linked file '%s'."),
+			    filedata->file_name);
+		  else
+		    printf (_("\nThere are no static relocations in this file."));
+		  printf (_("\nTo see the dynamic relocations add --use-dynamic to the command line.\n"));
+
+		  break;
+		}
+	    }
+	  if (i == ARRAY_SIZE (dynamic_relocations))
+	    {
+	      if (filedata->is_separate)
+		printf (_("\nThere are no relocations in linked file '%s'.\n"),
+			filedata->file_name);
+	      else
+		printf (_("\nThere are no relocations in this file.\n"));
+	    }
+	}
+    }
+
+  return true;
+}
+
+/* An absolute address consists of a section and an offset.  If the
+   section is NULL, the offset itself is the address, otherwise, the
+   address equals to LOAD_ADDRESS(section) + offset.  */
+
+struct absaddr
+{
+  unsigned short section;
+  bfd_vma offset;
+};
+
+/* Find the nearest symbol at or below ADDR.  Returns the symbol
+   name, if found, and the offset from the symbol to ADDR.  */
+
+static void
+find_symbol_for_address (Filedata *          filedata,
+			 Elf_Internal_Sym *  symtab,
+			 unsigned long       nsyms,
+			 const char *        strtab,
+			 unsigned long       strtab_size,
+			 struct absaddr      addr,
+			 const char **       symname,
+			 bfd_vma *           offset)
+{
+  bfd_vma dist = 0x100000;
+  Elf_Internal_Sym * sym;
+  Elf_Internal_Sym * beg;
+  Elf_Internal_Sym * end;
+  Elf_Internal_Sym * best = NULL;
+
+  REMOVE_ARCH_BITS (addr.offset);
+  beg = symtab;
+  end = symtab + nsyms;
+
+  while (beg < end)
+    {
+      bfd_vma value;
+
+      sym = beg + (end - beg) / 2;
+
+      value = sym->st_value;
+      REMOVE_ARCH_BITS (value);
+
+      if (sym->st_name != 0
+	  && (addr.section == SHN_UNDEF || addr.section == sym->st_shndx)
+	  && addr.offset >= value
+	  && addr.offset - value < dist)
+	{
+	  best = sym;
+	  dist = addr.offset - value;
+	  if (!dist)
+	    break;
+	}
+
+      if (addr.offset < value)
+	end = sym;
+      else
+	beg = sym + 1;
+    }
+
+  if (best)
+    {
+      *symname = (best->st_name >= strtab_size
+		  ? _("<corrupt>") : strtab + best->st_name);
+      *offset = dist;
+      return;
+    }
+
+  *symname = NULL;
+  *offset = addr.offset;
+}
+
+static /* signed */ int
+symcmp (const void *p, const void *q)
+{
+  Elf_Internal_Sym *sp = (Elf_Internal_Sym *) p;
+  Elf_Internal_Sym *sq = (Elf_Internal_Sym *) q;
+
+  return sp->st_value > sq->st_value ? 1 : (sp->st_value < sq->st_value ? -1 : 0);
+}
+
+/* Process the unwind section.  */
+
+#include "unwind-ia64.h"
+
+struct ia64_unw_table_entry
+{
+  struct absaddr start;
+  struct absaddr end;
+  struct absaddr info;
+};
+
+struct ia64_unw_aux_info
+{
+  struct ia64_unw_table_entry * table;		/* Unwind table.  */
+  unsigned long                 table_len;	/* Length of unwind table.  */
+  unsigned char *               info;		/* Unwind info.  */
+  unsigned long                 info_size;	/* Size of unwind info.  */
+  bfd_vma                       info_addr;	/* Starting address of unwind info.  */
+  bfd_vma                       seg_base;	/* Starting address of segment.  */
+  Elf_Internal_Sym *            symtab;		/* The symbol table.  */
+  unsigned long                 nsyms;		/* Number of symbols.  */
+  Elf_Internal_Sym *            funtab;		/* Sorted table of STT_FUNC symbols.  */
+  unsigned long                 nfuns;		/* Number of entries in funtab.  */
+  char *                        strtab;		/* The string table.  */
+  unsigned long                 strtab_size;	/* Size of string table.  */
+};
+
+static bool
+dump_ia64_unwind (Filedata * filedata, struct ia64_unw_aux_info * aux)
+{
+  struct ia64_unw_table_entry * tp;
+  unsigned long j, nfuns;
+  int in_body;
+  bool res = true;
+
+  aux->funtab = xmalloc (aux->nsyms * sizeof (Elf_Internal_Sym));
+  for (nfuns = 0, j = 0; j < aux->nsyms; j++)
+    if (aux->symtab[j].st_value && ELF_ST_TYPE (aux->symtab[j].st_info) == STT_FUNC)
+      aux->funtab[nfuns++] = aux->symtab[j];
+  aux->nfuns = nfuns;
+  qsort (aux->funtab, aux->nfuns, sizeof (Elf_Internal_Sym), symcmp);
+
+  for (tp = aux->table; tp < aux->table + aux->table_len; ++tp)
+    {
+      bfd_vma stamp;
+      bfd_vma offset;
+      const unsigned char * dp;
+      const unsigned char * head;
+      const unsigned char * end;
+      const char * procname;
+
+      find_symbol_for_address (filedata, aux->funtab, aux->nfuns, aux->strtab,
+			       aux->strtab_size, tp->start, &procname, &offset);
+
+      fputs ("\n<", stdout);
+
+      if (procname)
+	{
+	  fputs (procname, stdout);
+
+	  if (offset)
+	    printf ("+%lx", (unsigned long) offset);
+	}
+
+      fputs (">: [", stdout);
+      print_vma (tp->start.offset, PREFIX_HEX);
+      fputc ('-', stdout);
+      print_vma (tp->end.offset, PREFIX_HEX);
+      printf ("], info at +0x%lx\n",
+	      (unsigned long) (tp->info.offset - aux->seg_base));
+
+      /* PR 17531: file: 86232b32.  */
+      if (aux->info == NULL)
+	continue;
+
+      offset = tp->info.offset;
+      if (tp->info.section)
+	{
+	  if (tp->info.section >= filedata->file_header.e_shnum)
+	    {
+	      warn (_("Invalid section %u in table entry %ld\n"),
+		    tp->info.section, (long) (tp - aux->table));
+	      res = false;
+	      continue;
+	    }
+	  offset += filedata->section_headers[tp->info.section].sh_addr;
+	}
+      offset -= aux->info_addr;
+      /* PR 17531: file: 0997b4d1.  */
+      if (offset >= aux->info_size
+	  || aux->info_size - offset < 8)
+	{
+	  warn (_("Invalid offset %lx in table entry %ld\n"),
+		(long) tp->info.offset, (long) (tp - aux->table));
+	  res = false;
+	  continue;
+	}
+
+      head = aux->info + offset;
+      stamp = byte_get ((unsigned char *) head, sizeof (stamp));
+
+      printf ("  v%u, flags=0x%lx (%s%s), len=%lu bytes\n",
+	      (unsigned) UNW_VER (stamp),
+	      (unsigned long) ((stamp & UNW_FLAG_MASK) >> 32),
+	      UNW_FLAG_EHANDLER (stamp) ? " ehandler" : "",
+	      UNW_FLAG_UHANDLER (stamp) ? " uhandler" : "",
+	      (unsigned long) (eh_addr_size * UNW_LENGTH (stamp)));
+
+      if (UNW_VER (stamp) != 1)
+	{
+	  printf (_("\tUnknown version.\n"));
+	  continue;
+	}
+
+      in_body = 0;
+      end = head + 8 + eh_addr_size * UNW_LENGTH (stamp);
+      /* PR 17531: file: 16ceda89.  */
+      if (end > aux->info + aux->info_size)
+	end = aux->info + aux->info_size;
+      for (dp = head + 8; dp < end;)
+	dp = unw_decode (dp, in_body, & in_body, end);
+    }
+
+  free (aux->funtab);
+
+  return res;
+}
+
+static bool
+slurp_ia64_unwind_table (Filedata *                  filedata,
+			 struct ia64_unw_aux_info *  aux,
+			 Elf_Internal_Shdr *         sec)
+{
+  unsigned long size, nrelas, i;
+  Elf_Internal_Phdr * seg;
+  struct ia64_unw_table_entry * tep;
+  Elf_Internal_Shdr * relsec;
+  Elf_Internal_Rela * rela;
+  Elf_Internal_Rela * rp;
+  unsigned char * table;
+  unsigned char * tp;
+  Elf_Internal_Sym * sym;
+  const char * relname;
+
+  aux->table_len = 0;
+
+  /* First, find the starting address of the segment that includes
+     this section: */
+
+  if (filedata->file_header.e_phnum)
+    {
+      if (! get_program_headers (filedata))
+	  return false;
+
+      for (seg = filedata->program_headers;
+	   seg < filedata->program_headers + filedata->file_header.e_phnum;
+	   ++seg)
+	{
+	  if (seg->p_type != PT_LOAD)
+	    continue;
+
+	  if (sec->sh_addr >= seg->p_vaddr
+	      && (sec->sh_addr + sec->sh_size <= seg->p_vaddr + seg->p_memsz))
+	    {
+	      aux->seg_base = seg->p_vaddr;
+	      break;
+	    }
+	}
+    }
+
+  /* Second, build the unwind table from the contents of the unwind section:  */
+  size = sec->sh_size;
+  table = (unsigned char *) get_data (NULL, filedata, sec->sh_offset, 1, size,
+                                      _("unwind table"));
+  if (!table)
+    return false;
+
+  aux->table_len = size / (3 * eh_addr_size);
+  aux->table = (struct ia64_unw_table_entry *)
+    xcmalloc (aux->table_len, sizeof (aux->table[0]));
+  tep = aux->table;
+
+  for (tp = table; tp <= table + size - (3 * eh_addr_size); ++tep)
+    {
+      tep->start.section = SHN_UNDEF;
+      tep->end.section   = SHN_UNDEF;
+      tep->info.section  = SHN_UNDEF;
+      tep->start.offset = byte_get (tp, eh_addr_size); tp += eh_addr_size;
+      tep->end.offset   = byte_get (tp, eh_addr_size); tp += eh_addr_size;
+      tep->info.offset  = byte_get (tp, eh_addr_size); tp += eh_addr_size;
+      tep->start.offset += aux->seg_base;
+      tep->end.offset   += aux->seg_base;
+      tep->info.offset  += aux->seg_base;
+    }
+  free (table);
+
+  /* Third, apply any relocations to the unwind table:  */
+  for (relsec = filedata->section_headers;
+       relsec < filedata->section_headers + filedata->file_header.e_shnum;
+       ++relsec)
+    {
+      if (relsec->sh_type != SHT_RELA
+	  || relsec->sh_info >= filedata->file_header.e_shnum
+	  || filedata->section_headers + relsec->sh_info != sec)
+	continue;
+
+      if (!slurp_rela_relocs (filedata, relsec->sh_offset, relsec->sh_size,
+			      & rela, & nrelas))
+	{
+	  free (aux->table);
+	  aux->table = NULL;
+	  aux->table_len = 0;
+	  return false;
+	}
+
+      for (rp = rela; rp < rela + nrelas; ++rp)
+	{
+	  unsigned int sym_ndx;
+	  unsigned int r_type = get_reloc_type (filedata, rp->r_info);
+	  relname = elf_ia64_reloc_type (r_type);
+
+	  /* PR 17531: file: 9fa67536.  */
+	  if (relname == NULL)
+	    {
+	      warn (_("Skipping unknown relocation type: %u\n"), r_type);
+	      continue;
+	    }
+
+	  if (! startswith (relname, "R_IA64_SEGREL"))
+	    {
+	      warn (_("Skipping unexpected relocation type: %s\n"), relname);
+	      continue;
+	    }
+
+	  i = rp->r_offset / (3 * eh_addr_size);
+
+	  /* PR 17531: file: 5bc8d9bf.  */
+	  if (i >= aux->table_len)
+	    {
+	      warn (_("Skipping reloc with overlarge offset: %lx\n"), i);
+	      continue;
+	    }
+
+	  sym_ndx = get_reloc_symindex (rp->r_info);
+	  if (sym_ndx >= aux->nsyms)
+	    {
+	      warn (_("Skipping reloc with invalid symbol index: %u\n"),
+		    sym_ndx);
+	      continue;
+	    }
+	  sym = aux->symtab + sym_ndx;
+
+	  switch (rp->r_offset / eh_addr_size % 3)
+	    {
+	    case 0:
+	      aux->table[i].start.section = sym->st_shndx;
+	      aux->table[i].start.offset  = rp->r_addend + sym->st_value;
+	      break;
+	    case 1:
+	      aux->table[i].end.section   = sym->st_shndx;
+	      aux->table[i].end.offset    = rp->r_addend + sym->st_value;
+	      break;
+	    case 2:
+	      aux->table[i].info.section  = sym->st_shndx;
+	      aux->table[i].info.offset   = rp->r_addend + sym->st_value;
+	      break;
+	    default:
+	      break;
+	    }
+	}
+
+      free (rela);
+    }
+
+  return true;
+}
+
+static bool
+ia64_process_unwind (Filedata * filedata)
+{
+  Elf_Internal_Shdr * sec;
+  Elf_Internal_Shdr * unwsec = NULL;
+  unsigned long i, unwcount = 0, unwstart = 0;
+  struct ia64_unw_aux_info aux;
+  bool res = true;
+
+  memset (& aux, 0, sizeof (aux));
+
+  for (i = 0, sec = filedata->section_headers; i < filedata->file_header.e_shnum; ++i, ++sec)
+    {
+      if (sec->sh_type == SHT_SYMTAB)
+	{
+	  if (aux.symtab)
+	    {
+	      error (_("Multiple symbol tables encountered\n"));
+	      free (aux.symtab);
+	      aux.symtab = NULL;
+	      free (aux.strtab);
+	      aux.strtab = NULL;
+	    }
+	  if (!get_symtab (filedata, sec, &aux.symtab, &aux.nsyms,
+			   &aux.strtab, &aux.strtab_size))
+	    return false;
+	}
+      else if (sec->sh_type == SHT_IA_64_UNWIND)
+	unwcount++;
+    }
+
+  if (!unwcount)
+    printf (_("\nThere are no unwind sections in this file.\n"));
+
+  while (unwcount-- > 0)
+    {
+      char * suffix;
+      size_t len, len2;
+
+      for (i = unwstart, sec = filedata->section_headers + unwstart, unwsec = NULL;
+	   i < filedata->file_header.e_shnum; ++i, ++sec)
+	if (sec->sh_type == SHT_IA_64_UNWIND)
+	  {
+	    unwsec = sec;
+	    break;
+	  }
+      /* We have already counted the number of SHT_IA64_UNWIND
+	 sections so the loop above should never fail.  */
+      assert (unwsec != NULL);
+
+      unwstart = i + 1;
+      len = sizeof (ELF_STRING_ia64_unwind_once) - 1;
+
+      if ((unwsec->sh_flags & SHF_GROUP) != 0)
+	{
+	  /* We need to find which section group it is in.  */
+	  struct group_list * g;
+
+	  if (filedata->section_headers_groups == NULL
+	      || filedata->section_headers_groups[i] == NULL)
+	    i = filedata->file_header.e_shnum;
+	  else
+	    {
+	      g = filedata->section_headers_groups[i]->root;
+
+	      for (; g != NULL; g = g->next)
+		{
+		  sec = filedata->section_headers + g->section_index;
+
+		  if (SECTION_NAME_VALID (sec)
+		      && streq (SECTION_NAME (sec), ELF_STRING_ia64_unwind_info))
+		    break;
+		}
+
+	      if (g == NULL)
+		i = filedata->file_header.e_shnum;
+	    }
+	}
+      else if (SECTION_NAME_VALID (unwsec)
+	       && startswith (SECTION_NAME (unwsec),
+			      ELF_STRING_ia64_unwind_once))
+	{
+	  /* .gnu.linkonce.ia64unw.FOO -> .gnu.linkonce.ia64unwi.FOO.  */
+	  len2 = sizeof (ELF_STRING_ia64_unwind_info_once) - 1;
+	  suffix = SECTION_NAME (unwsec) + len;
+	  for (i = 0, sec = filedata->section_headers;
+	       i < filedata->file_header.e_shnum;
+	       ++i, ++sec)
+	    if (SECTION_NAME_VALID (sec)
+		&& startswith (SECTION_NAME (sec),
+			       ELF_STRING_ia64_unwind_info_once)
+		&& streq (SECTION_NAME (sec) + len2, suffix))
+	      break;
+	}
+      else
+	{
+	  /* .IA_64.unwindFOO -> .IA_64.unwind_infoFOO
+	     .IA_64.unwind or BAR -> .IA_64.unwind_info.  */
+	  len = sizeof (ELF_STRING_ia64_unwind) - 1;
+	  len2 = sizeof (ELF_STRING_ia64_unwind_info) - 1;
+	  suffix = "";
+	  if (SECTION_NAME_VALID (unwsec)
+	      && startswith (SECTION_NAME (unwsec), ELF_STRING_ia64_unwind))
+	    suffix = SECTION_NAME (unwsec) + len;
+	  for (i = 0, sec = filedata->section_headers;
+	       i < filedata->file_header.e_shnum;
+	       ++i, ++sec)
+	    if (SECTION_NAME_VALID (sec)
+		&& startswith (SECTION_NAME (sec), ELF_STRING_ia64_unwind_info)
+		&& streq (SECTION_NAME (sec) + len2, suffix))
+	      break;
+	}
+
+      if (i == filedata->file_header.e_shnum)
+	{
+	  printf (_("\nCould not find unwind info section for "));
+
+	  if (filedata->string_table == NULL)
+	    printf ("%d", unwsec->sh_name);
+	  else
+	    printf ("'%s'", printable_section_name (filedata, unwsec));
+	}
+      else
+	{
+	  aux.info_addr = sec->sh_addr;
+	  aux.info = (unsigned char *) get_data (NULL, filedata, sec->sh_offset, 1,
+						 sec->sh_size,
+						 _("unwind info"));
+	  aux.info_size = aux.info == NULL ? 0 : sec->sh_size;
+
+	  printf (_("\nUnwind section "));
+
+	  if (filedata->string_table == NULL)
+	    printf ("%d", unwsec->sh_name);
+	  else
+	    printf ("'%s'", printable_section_name (filedata, unwsec));
+
+	  printf (_(" at offset 0x%lx contains %lu entries:\n"),
+		  (unsigned long) unwsec->sh_offset,
+		  (unsigned long) (unwsec->sh_size / (3 * eh_addr_size)));
+
+	  if (slurp_ia64_unwind_table (filedata, & aux, unwsec)
+	      && aux.table_len > 0)
+	    dump_ia64_unwind (filedata, & aux);
+
+	  free ((char *) aux.table);
+	  free ((char *) aux.info);
+	  aux.table = NULL;
+	  aux.info = NULL;
+	}
+    }
+
+  free (aux.symtab);
+  free ((char *) aux.strtab);
+
+  return res;
+}
+
+struct hppa_unw_table_entry
+{
+  struct absaddr start;
+  struct absaddr end;
+  unsigned int Cannot_unwind:1;			/* 0 */
+  unsigned int Millicode:1;			/* 1 */
+  unsigned int Millicode_save_sr0:1;		/* 2 */
+  unsigned int Region_description:2;		/* 3..4 */
+  unsigned int reserved1:1;			/* 5 */
+  unsigned int Entry_SR:1;			/* 6 */
+  unsigned int Entry_FR:4;     /* Number saved     7..10 */
+  unsigned int Entry_GR:5;     /* Number saved     11..15 */
+  unsigned int Args_stored:1;			/* 16 */
+  unsigned int Variable_Frame:1;		/* 17 */
+  unsigned int Separate_Package_Body:1;		/* 18 */
+  unsigned int Frame_Extension_Millicode:1;	/* 19 */
+  unsigned int Stack_Overflow_Check:1;		/* 20 */
+  unsigned int Two_Instruction_SP_Increment:1;	/* 21 */
+  unsigned int Ada_Region:1;			/* 22 */
+  unsigned int cxx_info:1;			/* 23 */
+  unsigned int cxx_try_catch:1;			/* 24 */
+  unsigned int sched_entry_seq:1;		/* 25 */
+  unsigned int reserved2:1;			/* 26 */
+  unsigned int Save_SP:1;			/* 27 */
+  unsigned int Save_RP:1;			/* 28 */
+  unsigned int Save_MRP_in_frame:1;		/* 29 */
+  unsigned int extn_ptr_defined:1;		/* 30 */
+  unsigned int Cleanup_defined:1;		/* 31 */
+
+  unsigned int MPE_XL_interrupt_marker:1;	/* 0 */
+  unsigned int HP_UX_interrupt_marker:1;	/* 1 */
+  unsigned int Large_frame:1;			/* 2 */
+  unsigned int Pseudo_SP_Set:1;			/* 3 */
+  unsigned int reserved4:1;			/* 4 */
+  unsigned int Total_frame_size:27;		/* 5..31 */
+};
+
+struct hppa_unw_aux_info
+{
+  struct hppa_unw_table_entry *  table;		/* Unwind table.  */
+  unsigned long                  table_len;	/* Length of unwind table.  */
+  bfd_vma                        seg_base;	/* Starting address of segment.  */
+  Elf_Internal_Sym *             symtab;	/* The symbol table.  */
+  unsigned long                  nsyms;		/* Number of symbols.  */
+  Elf_Internal_Sym *             funtab;	/* Sorted table of STT_FUNC symbols.  */
+  unsigned long                  nfuns;		/* Number of entries in funtab.  */
+  char *                         strtab;	/* The string table.  */
+  unsigned long                  strtab_size;	/* Size of string table.  */
+};
+
+static bool
+dump_hppa_unwind (Filedata * filedata, struct hppa_unw_aux_info * aux)
+{
+  struct hppa_unw_table_entry * tp;
+  unsigned long j, nfuns;
+  bool res = true;
+
+  aux->funtab = xmalloc (aux->nsyms * sizeof (Elf_Internal_Sym));
+  for (nfuns = 0, j = 0; j < aux->nsyms; j++)
+    if (aux->symtab[j].st_value && ELF_ST_TYPE (aux->symtab[j].st_info) == STT_FUNC)
+      aux->funtab[nfuns++] = aux->symtab[j];
+  aux->nfuns = nfuns;
+  qsort (aux->funtab, aux->nfuns, sizeof (Elf_Internal_Sym), symcmp);
+
+  for (tp = aux->table; tp < aux->table + aux->table_len; ++tp)
+    {
+      bfd_vma offset;
+      const char * procname;
+
+      find_symbol_for_address (filedata, aux->funtab, aux->nfuns, aux->strtab,
+			       aux->strtab_size, tp->start, &procname,
+			       &offset);
+
+      fputs ("\n<", stdout);
+
+      if (procname)
+	{
+	  fputs (procname, stdout);
+
+	  if (offset)
+	    printf ("+%lx", (unsigned long) offset);
+	}
+
+      fputs (">: [", stdout);
+      print_vma (tp->start.offset, PREFIX_HEX);
+      fputc ('-', stdout);
+      print_vma (tp->end.offset, PREFIX_HEX);
+      printf ("]\n\t");
+
+#define PF(_m) if (tp->_m) printf (#_m " ");
+#define PV(_m) if (tp->_m) printf (#_m "=%d ", tp->_m);
+      PF(Cannot_unwind);
+      PF(Millicode);
+      PF(Millicode_save_sr0);
+      /* PV(Region_description);  */
+      PF(Entry_SR);
+      PV(Entry_FR);
+      PV(Entry_GR);
+      PF(Args_stored);
+      PF(Variable_Frame);
+      PF(Separate_Package_Body);
+      PF(Frame_Extension_Millicode);
+      PF(Stack_Overflow_Check);
+      PF(Two_Instruction_SP_Increment);
+      PF(Ada_Region);
+      PF(cxx_info);
+      PF(cxx_try_catch);
+      PF(sched_entry_seq);
+      PF(Save_SP);
+      PF(Save_RP);
+      PF(Save_MRP_in_frame);
+      PF(extn_ptr_defined);
+      PF(Cleanup_defined);
+      PF(MPE_XL_interrupt_marker);
+      PF(HP_UX_interrupt_marker);
+      PF(Large_frame);
+      PF(Pseudo_SP_Set);
+      PV(Total_frame_size);
+#undef PF
+#undef PV
+    }
+
+  printf ("\n");
+
+  free (aux->funtab);
+
+  return res;
+}
+
+static bool
+slurp_hppa_unwind_table (Filedata *                  filedata,
+			 struct hppa_unw_aux_info *  aux,
+			 Elf_Internal_Shdr *         sec)
+{
+  unsigned long size, unw_ent_size, nentries, nrelas, i;
+  Elf_Internal_Phdr * seg;
+  struct hppa_unw_table_entry * tep;
+  Elf_Internal_Shdr * relsec;
+  Elf_Internal_Rela * rela;
+  Elf_Internal_Rela * rp;
+  unsigned char * table;
+  unsigned char * tp;
+  Elf_Internal_Sym * sym;
+  const char * relname;
+
+  /* First, find the starting address of the segment that includes
+     this section.  */
+  if (filedata->file_header.e_phnum)
+    {
+      if (! get_program_headers (filedata))
+	return false;
+
+      for (seg = filedata->program_headers;
+	   seg < filedata->program_headers + filedata->file_header.e_phnum;
+	   ++seg)
+	{
+	  if (seg->p_type != PT_LOAD)
+	    continue;
+
+	  if (sec->sh_addr >= seg->p_vaddr
+	      && (sec->sh_addr + sec->sh_size <= seg->p_vaddr + seg->p_memsz))
+	    {
+	      aux->seg_base = seg->p_vaddr;
+	      break;
+	    }
+	}
+    }
+
+  /* Second, build the unwind table from the contents of the unwind
+     section.  */
+  size = sec->sh_size;
+  table = (unsigned char *) get_data (NULL, filedata, sec->sh_offset, 1, size,
+                                      _("unwind table"));
+  if (!table)
+    return false;
+
+  unw_ent_size = 16;
+  nentries = size / unw_ent_size;
+  size = unw_ent_size * nentries;
+
+  aux->table_len = nentries;
+  tep = aux->table = (struct hppa_unw_table_entry *)
+      xcmalloc (nentries, sizeof (aux->table[0]));
+
+  for (tp = table; tp < table + size; tp += unw_ent_size, ++tep)
+    {
+      unsigned int tmp1, tmp2;
+
+      tep->start.section = SHN_UNDEF;
+      tep->end.section   = SHN_UNDEF;
+
+      tep->start.offset = byte_get ((unsigned char *) tp + 0, 4);
+      tep->end.offset = byte_get ((unsigned char *) tp + 4, 4);
+      tmp1 = byte_get ((unsigned char *) tp + 8, 4);
+      tmp2 = byte_get ((unsigned char *) tp + 12, 4);
+
+      tep->start.offset += aux->seg_base;
+      tep->end.offset   += aux->seg_base;
+
+      tep->Cannot_unwind = (tmp1 >> 31) & 0x1;
+      tep->Millicode = (tmp1 >> 30) & 0x1;
+      tep->Millicode_save_sr0 = (tmp1 >> 29) & 0x1;
+      tep->Region_description = (tmp1 >> 27) & 0x3;
+      tep->reserved1 = (tmp1 >> 26) & 0x1;
+      tep->Entry_SR = (tmp1 >> 25) & 0x1;
+      tep->Entry_FR = (tmp1 >> 21) & 0xf;
+      tep->Entry_GR = (tmp1 >> 16) & 0x1f;
+      tep->Args_stored = (tmp1 >> 15) & 0x1;
+      tep->Variable_Frame = (tmp1 >> 14) & 0x1;
+      tep->Separate_Package_Body = (tmp1 >> 13) & 0x1;
+      tep->Frame_Extension_Millicode = (tmp1 >> 12) & 0x1;
+      tep->Stack_Overflow_Check = (tmp1 >> 11) & 0x1;
+      tep->Two_Instruction_SP_Increment = (tmp1 >> 10) & 0x1;
+      tep->Ada_Region = (tmp1 >> 9) & 0x1;
+      tep->cxx_info = (tmp1 >> 8) & 0x1;
+      tep->cxx_try_catch = (tmp1 >> 7) & 0x1;
+      tep->sched_entry_seq = (tmp1 >> 6) & 0x1;
+      tep->reserved2 = (tmp1 >> 5) & 0x1;
+      tep->Save_SP = (tmp1 >> 4) & 0x1;
+      tep->Save_RP = (tmp1 >> 3) & 0x1;
+      tep->Save_MRP_in_frame = (tmp1 >> 2) & 0x1;
+      tep->extn_ptr_defined = (tmp1 >> 1) & 0x1;
+      tep->Cleanup_defined = tmp1 & 0x1;
+
+      tep->MPE_XL_interrupt_marker = (tmp2 >> 31) & 0x1;
+      tep->HP_UX_interrupt_marker = (tmp2 >> 30) & 0x1;
+      tep->Large_frame = (tmp2 >> 29) & 0x1;
+      tep->Pseudo_SP_Set = (tmp2 >> 28) & 0x1;
+      tep->reserved4 = (tmp2 >> 27) & 0x1;
+      tep->Total_frame_size = tmp2 & 0x7ffffff;
+    }
+  free (table);
+
+  /* Third, apply any relocations to the unwind table.  */
+  for (relsec = filedata->section_headers;
+       relsec < filedata->section_headers + filedata->file_header.e_shnum;
+       ++relsec)
+    {
+      if (relsec->sh_type != SHT_RELA
+	  || relsec->sh_info >= filedata->file_header.e_shnum
+	  || filedata->section_headers + relsec->sh_info != sec)
+	continue;
+
+      if (!slurp_rela_relocs (filedata, relsec->sh_offset, relsec->sh_size,
+			      & rela, & nrelas))
+	return false;
+
+      for (rp = rela; rp < rela + nrelas; ++rp)
+	{
+	  unsigned int sym_ndx;
+	  unsigned int r_type = get_reloc_type (filedata, rp->r_info);
+	  relname = elf_hppa_reloc_type (r_type);
+
+	  if (relname == NULL)
+	    {
+	      warn (_("Skipping unknown relocation type: %u\n"), r_type);
+	      continue;
+	    }
+
+	  /* R_PARISC_SEGREL32 or R_PARISC_SEGREL64.  */
+	  if (! startswith (relname, "R_PARISC_SEGREL"))
+	    {
+	      warn (_("Skipping unexpected relocation type: %s\n"), relname);
+	      continue;
+	    }
+
+	  i = rp->r_offset / unw_ent_size;
+	  if (i >= aux->table_len)
+	    {
+	      warn (_("Skipping reloc with overlarge offset: %lx\n"), i);
+	      continue;
+	    }
+
+	  sym_ndx = get_reloc_symindex (rp->r_info);
+	  if (sym_ndx >= aux->nsyms)
+	    {
+	      warn (_("Skipping reloc with invalid symbol index: %u\n"),
+		    sym_ndx);
+	      continue;
+	    }
+	  sym = aux->symtab + sym_ndx;
+
+	  switch ((rp->r_offset % unw_ent_size) / 4)
+	    {
+	    case 0:
+	      aux->table[i].start.section = sym->st_shndx;
+	      aux->table[i].start.offset  = sym->st_value + rp->r_addend;
+	      break;
+	    case 1:
+	      aux->table[i].end.section   = sym->st_shndx;
+	      aux->table[i].end.offset    = sym->st_value + rp->r_addend;
+	      break;
+	    default:
+	      break;
+	    }
+	}
+
+      free (rela);
+    }
+
+  return true;
+}
+
+static bool
+hppa_process_unwind (Filedata * filedata)
+{
+  struct hppa_unw_aux_info aux;
+  Elf_Internal_Shdr * unwsec = NULL;
+  Elf_Internal_Shdr * sec;
+  unsigned long i;
+  bool res = true;
+
+  if (filedata->string_table == NULL)
+    return false;
+
+  memset (& aux, 0, sizeof (aux));
+
+  for (i = 0, sec = filedata->section_headers; i < filedata->file_header.e_shnum; ++i, ++sec)
+    {
+      if (sec->sh_type == SHT_SYMTAB)
+	{
+	  if (aux.symtab)
+	    {
+	      error (_("Multiple symbol tables encountered\n"));
+	      free (aux.symtab);
+	      aux.symtab = NULL;
+	      free (aux.strtab);
+	      aux.strtab = NULL;
+	    }
+	  if (!get_symtab (filedata, sec, &aux.symtab, &aux.nsyms,
+			   &aux.strtab, &aux.strtab_size))
+	    return false;
+	}
+      else if (SECTION_NAME_VALID (sec)
+	       && streq (SECTION_NAME (sec), ".PARISC.unwind"))
+	unwsec = sec;
+    }
+
+  if (!unwsec)
+    printf (_("\nThere are no unwind sections in this file.\n"));
+
+  for (i = 0, sec = filedata->section_headers; i < filedata->file_header.e_shnum; ++i, ++sec)
+    {
+      if (SECTION_NAME_VALID (sec)
+	  && streq (SECTION_NAME (sec), ".PARISC.unwind"))
+	{
+	  unsigned long num_unwind = sec->sh_size / 16;
+
+	  printf (ngettext ("\nUnwind section '%s' at offset 0x%lx "
+			    "contains %lu entry:\n",
+			    "\nUnwind section '%s' at offset 0x%lx "
+			    "contains %lu entries:\n",
+			    num_unwind),
+		  printable_section_name (filedata, sec),
+		  (unsigned long) sec->sh_offset,
+		  num_unwind);
+
+          if (! slurp_hppa_unwind_table (filedata, &aux, sec))
+	    res = false;
+
+	  if (res && aux.table_len > 0)
+	    {
+	      if (! dump_hppa_unwind (filedata, &aux))
+		res = false;
+	    }
+
+	  free ((char *) aux.table);
+	  aux.table = NULL;
+	}
+    }
+
+  free (aux.symtab);
+  free ((char *) aux.strtab);
+
+  return res;
+}
+
+struct arm_section
+{
+  unsigned char *      data;		/* The unwind data.  */
+  Elf_Internal_Shdr *  sec;		/* The cached unwind section header.  */
+  Elf_Internal_Rela *  rela;		/* The cached relocations for this section.  */
+  unsigned long        nrelas;		/* The number of relocations.  */
+  unsigned int         rel_type;	/* REL or RELA ?  */
+  Elf_Internal_Rela *  next_rela;	/* Cyclic pointer to the next reloc to process.  */
+};
+
+struct arm_unw_aux_info
+{
+  Filedata *          filedata;		/* The file containing the unwind sections.  */
+  Elf_Internal_Sym *  symtab;		/* The file's symbol table.  */
+  unsigned long       nsyms;		/* Number of symbols.  */
+  Elf_Internal_Sym *  funtab;		/* Sorted table of STT_FUNC symbols.  */
+  unsigned long       nfuns;		/* Number of these symbols.  */
+  char *              strtab;		/* The file's string table.  */
+  unsigned long       strtab_size;	/* Size of string table.  */
+};
+
+static const char *
+arm_print_vma_and_name (Filedata *                 filedata,
+			struct arm_unw_aux_info *  aux,
+			bfd_vma                    fn,
+			struct absaddr             addr)
+{
+  const char *procname;
+  bfd_vma sym_offset;
+
+  if (addr.section == SHN_UNDEF)
+    addr.offset = fn;
+
+  find_symbol_for_address (filedata, aux->funtab, aux->nfuns, aux->strtab,
+			   aux->strtab_size, addr, &procname,
+			   &sym_offset);
+
+  print_vma (fn, PREFIX_HEX);
+
+  if (procname)
+    {
+      fputs (" <", stdout);
+      fputs (procname, stdout);
+
+      if (sym_offset)
+	printf ("+0x%lx", (unsigned long) sym_offset);
+      fputc ('>', stdout);
+    }
+
+  return procname;
+}
+
+static void
+arm_free_section (struct arm_section *arm_sec)
+{
+  free (arm_sec->data);
+  free (arm_sec->rela);
+}
+
+/* 1) If SEC does not match the one cached in ARM_SEC, then free the current
+      cached section and install SEC instead.
+   2) Locate the 32-bit word at WORD_OFFSET in unwind section SEC
+      and return its valued in * WORDP, relocating if necessary.
+   3) Update the NEXT_RELA field in ARM_SEC and store the section index and
+      relocation's offset in ADDR.
+   4) If SYM_NAME is non-NULL and a relocation was applied, record the offset
+      into the string table of the symbol associated with the reloc.  If no
+      reloc was applied store -1 there.
+   5) Return TRUE upon success, FALSE otherwise.  */
+
+static bool
+get_unwind_section_word (Filedata *                 filedata,
+			 struct arm_unw_aux_info *  aux,
+			 struct arm_section *       arm_sec,
+			 Elf_Internal_Shdr *        sec,
+			 bfd_vma 		    word_offset,
+			 unsigned int *             wordp,
+			 struct absaddr *           addr,
+			 bfd_vma *		    sym_name)
+{
+  Elf_Internal_Rela *rp;
+  Elf_Internal_Sym *sym;
+  const char * relname;
+  unsigned int word;
+  bool wrapped;
+
+  if (sec == NULL || arm_sec == NULL)
+    return false;
+
+  addr->section = SHN_UNDEF;
+  addr->offset = 0;
+
+  if (sym_name != NULL)
+    *sym_name = (bfd_vma) -1;
+
+  /* If necessary, update the section cache.  */
+  if (sec != arm_sec->sec)
+    {
+      Elf_Internal_Shdr *relsec;
+
+      arm_free_section (arm_sec);
+
+      arm_sec->sec = sec;
+      arm_sec->data = get_data (NULL, aux->filedata, sec->sh_offset, 1,
+				sec->sh_size, _("unwind data"));
+      arm_sec->rela = NULL;
+      arm_sec->nrelas = 0;
+
+      for (relsec = filedata->section_headers;
+	   relsec < filedata->section_headers + filedata->file_header.e_shnum;
+	   ++relsec)
+	{
+	  if (relsec->sh_info >= filedata->file_header.e_shnum
+	      || filedata->section_headers + relsec->sh_info != sec
+	      /* PR 15745: Check the section type as well.  */
+	      || (relsec->sh_type != SHT_REL
+		  && relsec->sh_type != SHT_RELA))
+	    continue;
+
+	  arm_sec->rel_type = relsec->sh_type;
+	  if (relsec->sh_type == SHT_REL)
+	    {
+	      if (!slurp_rel_relocs (aux->filedata, relsec->sh_offset,
+				     relsec->sh_size,
+				     & arm_sec->rela, & arm_sec->nrelas))
+		return false;
+	    }
+	  else /* relsec->sh_type == SHT_RELA */
+	    {
+	      if (!slurp_rela_relocs (aux->filedata, relsec->sh_offset,
+				      relsec->sh_size,
+				      & arm_sec->rela, & arm_sec->nrelas))
+		return false;
+	    }
+	  break;
+	}
+
+      arm_sec->next_rela = arm_sec->rela;
+    }
+
+  /* If there is no unwind data we can do nothing.  */
+  if (arm_sec->data == NULL)
+    return false;
+
+  /* If the offset is invalid then fail.  */
+  if (/* PR 21343 *//* PR 18879 */
+      sec->sh_size < 4
+      || word_offset > (sec->sh_size - 4)
+      || ((bfd_signed_vma) word_offset) < 0)
+    return false;
+
+  /* Get the word at the required offset.  */
+  word = byte_get (arm_sec->data + word_offset, 4);
+
+  /* PR 17531: file: id:000001,src:001266+003044,op:splice,rep:128.  */
+  if (arm_sec->rela == NULL)
+    {
+      * wordp = word;
+      return true;
+    }
+
+  /* Look through the relocs to find the one that applies to the provided offset.  */
+  wrapped = false;
+  for (rp = arm_sec->next_rela; rp != arm_sec->rela + arm_sec->nrelas; rp++)
+    {
+      bfd_vma prelval, offset;
+
+      if (rp->r_offset > word_offset && !wrapped)
+	{
+	  rp = arm_sec->rela;
+	  wrapped = true;
+	}
+      if (rp->r_offset > word_offset)
+	break;
+
+      if (rp->r_offset & 3)
+	{
+	  warn (_("Skipping unexpected relocation at offset 0x%lx\n"),
+		(unsigned long) rp->r_offset);
+	  continue;
+	}
+
+      if (rp->r_offset < word_offset)
+	continue;
+
+      /* PR 17531: file: 027-161405-0.004  */
+      if (aux->symtab == NULL)
+	continue;
+
+      if (arm_sec->rel_type == SHT_REL)
+	{
+	  offset = word & 0x7fffffff;
+	  if (offset & 0x40000000)
+	    offset |= ~ (bfd_vma) 0x7fffffff;
+	}
+      else if (arm_sec->rel_type == SHT_RELA)
+	offset = rp->r_addend;
+      else
+	{
+	  error (_("Unknown section relocation type %d encountered\n"),
+		 arm_sec->rel_type);
+	  break;
+	}
+
+      /* PR 17531 file: 027-1241568-0.004.  */
+      if (ELF32_R_SYM (rp->r_info) >= aux->nsyms)
+	{
+	  error (_("Bad symbol index in unwind relocation (%lu > %lu)\n"),
+		 (unsigned long) ELF32_R_SYM (rp->r_info), aux->nsyms);
+	  break;
+	}
+
+      sym = aux->symtab + ELF32_R_SYM (rp->r_info);
+      offset += sym->st_value;
+      prelval = offset - (arm_sec->sec->sh_addr + rp->r_offset);
+
+      /* Check that we are processing the expected reloc type.  */
+      if (filedata->file_header.e_machine == EM_ARM)
+	{
+	  relname = elf_arm_reloc_type (ELF32_R_TYPE (rp->r_info));
+	  if (relname == NULL)
+	    {
+	      warn (_("Skipping unknown ARM relocation type: %d\n"),
+		    (int) ELF32_R_TYPE (rp->r_info));
+	      continue;
+	    }
+
+	  if (streq (relname, "R_ARM_NONE"))
+	      continue;
+
+	  if (! streq (relname, "R_ARM_PREL31"))
+	    {
+	      warn (_("Skipping unexpected ARM relocation type %s\n"), relname);
+	      continue;
+	    }
+	}
+      else if (filedata->file_header.e_machine == EM_TI_C6000)
+	{
+	  relname = elf_tic6x_reloc_type (ELF32_R_TYPE (rp->r_info));
+	  if (relname == NULL)
+	    {
+	      warn (_("Skipping unknown C6000 relocation type: %d\n"),
+		    (int) ELF32_R_TYPE (rp->r_info));
+	      continue;
+	    }
+
+	  if (streq (relname, "R_C6000_NONE"))
+	    continue;
+
+	  if (! streq (relname, "R_C6000_PREL31"))
+	    {
+	      warn (_("Skipping unexpected C6000 relocation type %s\n"), relname);
+	      continue;
+	    }
+
+	  prelval >>= 1;
+	}
+      else
+	{
+	  /* This function currently only supports ARM and TI unwinders.  */
+	  warn (_("Only TI and ARM unwinders are currently supported\n"));
+	  break;
+	}
+
+      word = (word & ~ (bfd_vma) 0x7fffffff) | (prelval & 0x7fffffff);
+      addr->section = sym->st_shndx;
+      addr->offset = offset;
+
+      if (sym_name)
+	* sym_name = sym->st_name;
+      break;
+    }
+
+  *wordp = word;
+  arm_sec->next_rela = rp;
+
+  return true;
+}
+
+static const char *tic6x_unwind_regnames[16] =
+{
+  "A15", "B15", "B14", "B13", "B12", "B11", "B10", "B3",
+  "A14", "A13", "A12", "A11", "A10",
+  "[invalid reg 13]", "[invalid reg 14]", "[invalid reg 15]"
+};
+
+static void
+decode_tic6x_unwind_regmask (unsigned int mask)
+{
+  int i;
+
+  for (i = 12; mask; mask >>= 1, i--)
+    {
+      if (mask & 1)
+	{
+	  fputs (tic6x_unwind_regnames[i], stdout);
+	  if (mask > 1)
+	    fputs (", ", stdout);
+	}
+    }
+}
+
+#define ADVANCE							\
+  if (remaining == 0 && more_words)				\
+    {								\
+      data_offset += 4;						\
+      if (! get_unwind_section_word (filedata, aux, data_arm_sec, data_sec,	\
+				     data_offset, & word, & addr, NULL))	\
+	return false;						\
+      remaining = 4;						\
+      more_words--;						\
+    }								\
+
+#define GET_OP(OP)			\
+  ADVANCE;				\
+  if (remaining)			\
+    {					\
+      remaining--;			\
+      (OP) = word >> 24;		\
+      word <<= 8;			\
+    }					\
+  else					\
+    {					\
+      printf (_("[Truncated opcode]\n"));	\
+      return false;			\
+    }					\
+  printf ("0x%02x ", OP)
+
+static bool
+decode_arm_unwind_bytecode (Filedata *                 filedata,
+			    struct arm_unw_aux_info *  aux,
+			    unsigned int               word,
+			    unsigned int               remaining,
+			    unsigned int               more_words,
+			    bfd_vma                    data_offset,
+			    Elf_Internal_Shdr *        data_sec,
+			    struct arm_section *       data_arm_sec)
+{
+  struct absaddr addr;
+  bool res = true;
+
+  /* Decode the unwinding instructions.  */
+  while (1)
+    {
+      unsigned int op, op2;
+
+      ADVANCE;
+      if (remaining == 0)
+	break;
+      remaining--;
+      op = word >> 24;
+      word <<= 8;
+
+      printf ("  0x%02x ", op);
+
+      if ((op & 0xc0) == 0x00)
+	{
+	  int offset = ((op & 0x3f) << 2) + 4;
+
+	  printf ("     vsp = vsp + %d", offset);
+	}
+      else if ((op & 0xc0) == 0x40)
+	{
+	  int offset = ((op & 0x3f) << 2) + 4;
+
+	  printf ("     vsp = vsp - %d", offset);
+	}
+      else if ((op & 0xf0) == 0x80)
+	{
+	  GET_OP (op2);
+	  if (op == 0x80 && op2 == 0)
+	    printf (_("Refuse to unwind"));
+	  else
+	    {
+	      unsigned int mask = ((op & 0x0f) << 8) | op2;
+	      bool first = true;
+	      int i;
+
+	      printf ("pop {");
+	      for (i = 0; i < 12; i++)
+		if (mask & (1 << i))
+		  {
+		    if (first)
+		      first = false;
+		    else
+		      printf (", ");
+		    printf ("r%d", 4 + i);
+		  }
+	      printf ("}");
+	    }
+	}
+      else if ((op & 0xf0) == 0x90)
+	{
+	  if (op == 0x9d || op == 0x9f)
+	    printf (_("     [Reserved]"));
+	  else
+	    printf ("     vsp = r%d", op & 0x0f);
+	}
+      else if ((op & 0xf0) == 0xa0)
+	{
+	  int end = 4 + (op & 0x07);
+	  bool first = true;
+	  int i;
+
+	  printf ("     pop {");
+	  for (i = 4; i <= end; i++)
+	    {
+	      if (first)
+		first = false;
+	      else
+		printf (", ");
+	      printf ("r%d", i);
+	    }
+	  if (op & 0x08)
+	    {
+	      if (!first)
+		printf (", ");
+	      printf ("r14");
+	    }
+	  printf ("}");
+	}
+      else if (op == 0xb0)
+	printf (_("     finish"));
+      else if (op == 0xb1)
+	{
+	  GET_OP (op2);
+	  if (op2 == 0 || (op2 & 0xf0) != 0)
+	    printf (_("[Spare]"));
+	  else
+	    {
+	      unsigned int mask = op2 & 0x0f;
+	      bool first = true;
+	      int i;
+
+	      printf ("pop {");
+	      for (i = 0; i < 12; i++)
+		if (mask & (1 << i))
+		  {
+		    if (first)
+		      first = false;
+		    else
+		      printf (", ");
+		    printf ("r%d", i);
+		  }
+	      printf ("}");
+	    }
+	}
+      else if (op == 0xb2)
+	{
+	  unsigned char buf[9];
+	  unsigned int i, len;
+	  unsigned long offset;
+
+	  for (i = 0; i < sizeof (buf); i++)
+	    {
+	      GET_OP (buf[i]);
+	      if ((buf[i] & 0x80) == 0)
+		break;
+	    }
+	  if (i == sizeof (buf))
+	    {
+	      error (_("corrupt change to vsp\n"));
+	      res = false;
+	    }
+	  else
+	    {
+	      offset = read_leb128 (buf, buf + i + 1, false, &len, NULL);
+	      assert (len == i + 1);
+	      offset = offset * 4 + 0x204;
+	      printf ("vsp = vsp + %ld", offset);
+	    }
+	}
+      else if (op == 0xb3 || op == 0xc8 || op == 0xc9)
+	{
+	  unsigned int first, last;
+
+	  GET_OP (op2);
+	  first = op2 >> 4;
+	  last = op2 & 0x0f;
+	  if (op == 0xc8)
+	    first = first + 16;
+	  printf ("pop {D%d", first);
+	  if (last)
+	    printf ("-D%d", first + last);
+	  printf ("}");
+	}
+      else if ((op & 0xf8) == 0xb8 || (op & 0xf8) == 0xd0)
+	{
+	  unsigned int count = op & 0x07;
+
+	  printf ("pop {D8");
+	  if (count)
+	    printf ("-D%d", 8 + count);
+	  printf ("}");
+	}
+      else if (op >= 0xc0 && op <= 0xc5)
+	{
+	  unsigned int count = op & 0x07;
+
+	  printf ("     pop {wR10");
+	  if (count)
+	    printf ("-wR%d", 10 + count);
+	  printf ("}");
+	}
+      else if (op == 0xc6)
+	{
+	  unsigned int first, last;
+
+	  GET_OP (op2);
+	  first = op2 >> 4;
+	  last = op2 & 0x0f;
+	  printf ("pop {wR%d", first);
+	  if (last)
+	    printf ("-wR%d", first + last);
+	  printf ("}");
+	}
+      else if (op == 0xc7)
+	{
+	  GET_OP (op2);
+	  if (op2 == 0 || (op2 & 0xf0) != 0)
+	    printf (_("[Spare]"));
+	  else
+	    {
+	      unsigned int mask = op2 & 0x0f;
+	      bool first = true;
+	      int i;
+
+	      printf ("pop {");
+	      for (i = 0; i < 4; i++)
+		if (mask & (1 << i))
+		  {
+		    if (first)
+		      first = false;
+		    else
+		      printf (", ");
+		    printf ("wCGR%d", i);
+		  }
+	      printf ("}");
+	    }
+	}
+      else
+	{
+	  printf (_("     [unsupported opcode]"));
+	  res = false;
+	}
+
+      printf ("\n");
+    }
+
+  return res;
+}
+
+static bool
+decode_tic6x_unwind_bytecode (Filedata *                 filedata,
+			      struct arm_unw_aux_info *  aux,
+			      unsigned int               word,
+			      unsigned int               remaining,
+			      unsigned int               more_words,
+			      bfd_vma                    data_offset,
+			      Elf_Internal_Shdr *        data_sec,
+			      struct arm_section *       data_arm_sec)
+{
+  struct absaddr addr;
+
+  /* Decode the unwinding instructions.  */
+  while (1)
+    {
+      unsigned int op, op2;
+
+      ADVANCE;
+      if (remaining == 0)
+	break;
+      remaining--;
+      op = word >> 24;
+      word <<= 8;
+
+      printf ("  0x%02x ", op);
+
+      if ((op & 0xc0) == 0x00)
+	{
+	  int offset = ((op & 0x3f) << 3) + 8;
+	  printf ("     sp = sp + %d", offset);
+	}
+      else if ((op & 0xc0) == 0x80)
+	{
+	  GET_OP (op2);
+	  if (op == 0x80 && op2 == 0)
+	    printf (_("Refuse to unwind"));
+	  else
+	    {
+	      unsigned int mask = ((op & 0x1f) << 8) | op2;
+	      if (op & 0x20)
+		printf ("pop compact {");
+	      else
+		printf ("pop {");
+
+	      decode_tic6x_unwind_regmask (mask);
+	      printf("}");
+	    }
+	}
+      else if ((op & 0xf0) == 0xc0)
+	{
+	  unsigned int reg;
+	  unsigned int nregs;
+	  unsigned int i;
+	  const char *name;
+	  struct
+	  {
+	    unsigned int offset;
+	    unsigned int reg;
+	  } regpos[16];
+
+	  /* Scan entire instruction first so that GET_OP output is not
+	     interleaved with disassembly.  */
+	  nregs = 0;
+	  for (i = 0; nregs < (op & 0xf); i++)
+	    {
+	      GET_OP (op2);
+	      reg = op2 >> 4;
+	      if (reg != 0xf)
+		{
+		  regpos[nregs].offset = i * 2;
+		  regpos[nregs].reg = reg;
+		  nregs++;
+		}
+
+	      reg = op2 & 0xf;
+	      if (reg != 0xf)
+		{
+		  regpos[nregs].offset = i * 2 + 1;
+		  regpos[nregs].reg = reg;
+		  nregs++;
+		}
+	    }
+
+	  printf (_("pop frame {"));
+	  if (nregs == 0)
+	    {
+	      printf (_("*corrupt* - no registers specified"));
+	    }
+	  else
+	    {
+	      reg = nregs - 1;
+	      for (i = i * 2; i > 0; i--)
+		{
+		  if (regpos[reg].offset == i - 1)
+		    {
+		      name = tic6x_unwind_regnames[regpos[reg].reg];
+		      if (reg > 0)
+			reg--;
+		    }
+		  else
+		    name = _("[pad]");
+
+		  fputs (name, stdout);
+		  if (i > 1)
+		    printf (", ");
+		}
+	    }
+
+	  printf ("}");
+	}
+      else if (op == 0xd0)
+	printf ("     MOV FP, SP");
+      else if (op == 0xd1)
+	printf ("     __c6xabi_pop_rts");
+      else if (op == 0xd2)
+	{
+	  unsigned char buf[9];
+	  unsigned int i, len;
+	  unsigned long offset;
+
+	  for (i = 0; i < sizeof (buf); i++)
+	    {
+	      GET_OP (buf[i]);
+	      if ((buf[i] & 0x80) == 0)
+		break;
+	    }
+	  /* PR 17531: file: id:000001,src:001906+004739,op:splice,rep:2.  */
+	  if (i == sizeof (buf))
+	    {
+	      warn (_("Corrupt stack pointer adjustment detected\n"));
+	      return false;
+	    }
+
+	  offset = read_leb128 (buf, buf + i + 1, false, &len, NULL);
+	  assert (len == i + 1);
+	  offset = offset * 8 + 0x408;
+	  printf (_("sp = sp + %ld"), offset);
+	}
+      else if ((op & 0xf0) == 0xe0)
+	{
+	  if ((op & 0x0f) == 7)
+	    printf ("     RETURN");
+	  else
+	    printf ("     MV %s, B3", tic6x_unwind_regnames[op & 0x0f]);
+	}
+      else
+	{
+	  printf (_("     [unsupported opcode]"));
+	}
+      putchar ('\n');
+    }
+
+  return true;
+}
+
+static bfd_vma
+arm_expand_prel31 (Filedata * filedata, bfd_vma word, bfd_vma where)
+{
+  bfd_vma offset;
+
+  offset = word & 0x7fffffff;
+  if (offset & 0x40000000)
+    offset |= ~ (bfd_vma) 0x7fffffff;
+
+  if (filedata->file_header.e_machine == EM_TI_C6000)
+    offset <<= 1;
+
+  return offset + where;
+}
+
+static bool
+decode_arm_unwind (Filedata *                 filedata,
+		   struct arm_unw_aux_info *  aux,
+		   unsigned int               word,
+		   unsigned int               remaining,
+		   bfd_vma                    data_offset,
+		   Elf_Internal_Shdr *        data_sec,
+		   struct arm_section *       data_arm_sec)
+{
+  int per_index;
+  unsigned int more_words = 0;
+  struct absaddr addr;
+  bfd_vma sym_name = (bfd_vma) -1;
+  bool res = true;
+
+  if (remaining == 0)
+    {
+      /* Fetch the first word.
+	 Note - when decoding an object file the address extracted
+	 here will always be 0.  So we also pass in the sym_name
+	 parameter so that we can find the symbol associated with
+	 the personality routine.  */
+      if (! get_unwind_section_word (filedata, aux, data_arm_sec, data_sec, data_offset,
+				     & word, & addr, & sym_name))
+	return false;
+
+      remaining = 4;
+    }
+  else
+    {
+      addr.section = SHN_UNDEF;
+      addr.offset = 0;
+    }
+
+  if ((word & 0x80000000) == 0)
+    {
+      /* Expand prel31 for personality routine.  */
+      bfd_vma fn;
+      const char *procname;
+
+      fn = arm_expand_prel31 (filedata, word, data_sec->sh_addr + data_offset);
+      printf (_("  Personality routine: "));
+      if (fn == 0
+	  && addr.section == SHN_UNDEF && addr.offset == 0
+	  && sym_name != (bfd_vma) -1 && sym_name < aux->strtab_size)
+	{
+	  procname = aux->strtab + sym_name;
+	  print_vma (fn, PREFIX_HEX);
+	  if (procname)
+	    {
+	      fputs (" <", stdout);
+	      fputs (procname, stdout);
+	      fputc ('>', stdout);
+	    }
+	}
+      else
+	procname = arm_print_vma_and_name (filedata, aux, fn, addr);
+      fputc ('\n', stdout);
+
+      /* The GCC personality routines use the standard compact
+	 encoding, starting with one byte giving the number of
+	 words.  */
+      if (procname != NULL
+	  && (startswith (procname, "__gcc_personality_v0")
+	      || startswith (procname, "__gxx_personality_v0")
+	      || startswith (procname, "__gcj_personality_v0")
+	      || startswith (procname, "__gnu_objc_personality_v0")))
+	{
+	  remaining = 0;
+	  more_words = 1;
+	  ADVANCE;
+	  if (!remaining)
+	    {
+	      printf (_("  [Truncated data]\n"));
+	      return false;
+	    }
+	  more_words = word >> 24;
+	  word <<= 8;
+	  remaining--;
+	  per_index = -1;
+	}
+      else
+	return true;
+    }
+  else
+    {
+      /* ARM EHABI Section 6.3:
+
+	 An exception-handling table entry for the compact model looks like:
+
+           31 30-28 27-24 23-0
+	   -- ----- ----- ----
+            1   0   index Data for personalityRoutine[index]    */
+
+      if (filedata->file_header.e_machine == EM_ARM
+	  && (word & 0x70000000))
+	{
+	  warn (_("Corrupt ARM compact model table entry: %x \n"), word);
+	  res = false;
+	}
+
+      per_index = (word >> 24) & 0x7f;
+      printf (_("  Compact model index: %d\n"), per_index);
+      if (per_index == 0)
+	{
+	  more_words = 0;
+	  word <<= 8;
+	  remaining--;
+	}
+      else if (per_index < 3)
+	{
+	  more_words = (word >> 16) & 0xff;
+	  word <<= 16;
+	  remaining -= 2;
+	}
+    }
+
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_ARM:
+      if (per_index < 3)
+	{
+	  if (! decode_arm_unwind_bytecode (filedata, aux, word, remaining, more_words,
+					    data_offset, data_sec, data_arm_sec))
+	    res = false;
+	}
+      else
+	{
+	  warn (_("Unknown ARM compact model index encountered\n"));
+	  printf (_("  [reserved]\n"));
+	  res = false;
+	}
+      break;
+
+    case EM_TI_C6000:
+      if (per_index < 3)
+	{
+	  if (! decode_tic6x_unwind_bytecode (filedata, aux, word, remaining, more_words,
+					      data_offset, data_sec, data_arm_sec))
+	    res = false;
+	}
+      else if (per_index < 5)
+	{
+	  if (((word >> 17) & 0x7f) == 0x7f)
+	    printf (_("  Restore stack from frame pointer\n"));
+	  else
+	    printf (_("  Stack increment %d\n"), (word >> 14) & 0x1fc);
+	  printf (_("  Registers restored: "));
+	  if (per_index == 4)
+	    printf (" (compact) ");
+	  decode_tic6x_unwind_regmask ((word >> 4) & 0x1fff);
+	  putchar ('\n');
+	  printf (_("  Return register: %s\n"),
+		  tic6x_unwind_regnames[word & 0xf]);
+	}
+      else
+	printf (_("  [reserved (%d)]\n"), per_index);
+      break;
+
+    default:
+      error (_("Unsupported architecture type %d encountered when decoding unwind table\n"),
+	     filedata->file_header.e_machine);
+      res = false;
+    }
+
+  /* Decode the descriptors.  Not implemented.  */
+
+  return res;
+}
+
+static bool
+dump_arm_unwind (Filedata *                 filedata,
+		 struct arm_unw_aux_info *  aux,
+		 Elf_Internal_Shdr *        exidx_sec)
+{
+  struct arm_section exidx_arm_sec, extab_arm_sec;
+  unsigned int i, exidx_len;
+  unsigned long j, nfuns;
+  bool res = true;
+
+  memset (&exidx_arm_sec, 0, sizeof (exidx_arm_sec));
+  memset (&extab_arm_sec, 0, sizeof (extab_arm_sec));
+  exidx_len = exidx_sec->sh_size / 8;
+
+  aux->funtab = xmalloc (aux->nsyms * sizeof (Elf_Internal_Sym));
+  for (nfuns = 0, j = 0; j < aux->nsyms; j++)
+    if (aux->symtab[j].st_value && ELF_ST_TYPE (aux->symtab[j].st_info) == STT_FUNC)
+      aux->funtab[nfuns++] = aux->symtab[j];
+  aux->nfuns = nfuns;
+  qsort (aux->funtab, aux->nfuns, sizeof (Elf_Internal_Sym), symcmp);
+
+  for (i = 0; i < exidx_len; i++)
+    {
+      unsigned int exidx_fn, exidx_entry;
+      struct absaddr fn_addr, entry_addr;
+      bfd_vma fn;
+
+      fputc ('\n', stdout);
+
+      if (! get_unwind_section_word (filedata, aux, & exidx_arm_sec, exidx_sec,
+				     8 * i, & exidx_fn, & fn_addr, NULL)
+	  || ! get_unwind_section_word (filedata, aux, & exidx_arm_sec, exidx_sec,
+					8 * i + 4, & exidx_entry, & entry_addr, NULL))
+	{
+	  free (aux->funtab);
+	  arm_free_section (& exidx_arm_sec);
+	  arm_free_section (& extab_arm_sec);
+	  return false;
+	}
+
+      /* ARM EHABI, Section 5:
+	 An index table entry consists of 2 words.
+         The first word contains a prel31 offset to the start of a function, with bit 31 clear.  */
+      if (exidx_fn & 0x80000000)
+	{
+	  warn (_("corrupt index table entry: %x\n"), exidx_fn);
+	  res = false;
+	}
+
+      fn = arm_expand_prel31 (filedata, exidx_fn, exidx_sec->sh_addr + 8 * i);
+
+      arm_print_vma_and_name (filedata, aux, fn, fn_addr);
+      fputs (": ", stdout);
+
+      if (exidx_entry == 1)
+	{
+	  print_vma (exidx_entry, PREFIX_HEX);
+	  fputs (" [cantunwind]\n", stdout);
+	}
+      else if (exidx_entry & 0x80000000)
+	{
+	  print_vma (exidx_entry, PREFIX_HEX);
+	  fputc ('\n', stdout);
+	  decode_arm_unwind (filedata, aux, exidx_entry, 4, 0, NULL, NULL);
+	}
+      else
+	{
+	  bfd_vma table, table_offset = 0;
+	  Elf_Internal_Shdr *table_sec;
+
+	  fputs ("@", stdout);
+	  table = arm_expand_prel31 (filedata, exidx_entry, exidx_sec->sh_addr + 8 * i + 4);
+	  print_vma (table, PREFIX_HEX);
+	  printf ("\n");
+
+	  /* Locate the matching .ARM.extab.  */
+	  if (entry_addr.section != SHN_UNDEF
+	      && entry_addr.section < filedata->file_header.e_shnum)
+	    {
+	      table_sec = filedata->section_headers + entry_addr.section;
+	      table_offset = entry_addr.offset;
+	      /* PR 18879 */
+	      if (table_offset > table_sec->sh_size
+		  || ((bfd_signed_vma) table_offset) < 0)
+		{
+		  warn (_("Unwind entry contains corrupt offset (0x%lx) into section %s\n"),
+			(unsigned long) table_offset,
+			printable_section_name (filedata, table_sec));
+		  res = false;
+		  continue;
+		}
+	    }
+	  else
+	    {
+	      table_sec = find_section_by_address (filedata, table);
+	      if (table_sec != NULL)
+		table_offset = table - table_sec->sh_addr;
+	    }
+
+	  if (table_sec == NULL)
+	    {
+	      warn (_("Could not locate .ARM.extab section containing 0x%lx.\n"),
+		    (unsigned long) table);
+	      res = false;
+	      continue;
+	    }
+
+	  if (! decode_arm_unwind (filedata, aux, 0, 0, table_offset, table_sec,
+				   &extab_arm_sec))
+	    res = false;
+	}
+    }
+
+  printf ("\n");
+
+  free (aux->funtab);
+  arm_free_section (&exidx_arm_sec);
+  arm_free_section (&extab_arm_sec);
+
+  return res;
+}
+
+/* Used for both ARM and C6X unwinding tables.  */
+
+static bool
+arm_process_unwind (Filedata * filedata)
+{
+  struct arm_unw_aux_info aux;
+  Elf_Internal_Shdr *unwsec = NULL;
+  Elf_Internal_Shdr *sec;
+  unsigned long i;
+  unsigned int sec_type;
+  bool res = true;
+
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_ARM:
+      sec_type = SHT_ARM_EXIDX;
+      break;
+
+    case EM_TI_C6000:
+      sec_type = SHT_C6000_UNWIND;
+      break;
+
+    default:
+      error (_("Unsupported architecture type %d encountered when processing unwind table\n"),
+	     filedata->file_header.e_machine);
+      return false;
+    }
+
+  if (filedata->string_table == NULL)
+    return false;
+
+  memset (& aux, 0, sizeof (aux));
+  aux.filedata = filedata;
+
+  for (i = 0, sec = filedata->section_headers; i < filedata->file_header.e_shnum; ++i, ++sec)
+    {
+      if (sec->sh_type == SHT_SYMTAB)
+	{
+	  if (aux.symtab)
+	    {
+	      error (_("Multiple symbol tables encountered\n"));
+	      free (aux.symtab);
+	      aux.symtab = NULL;
+	      free (aux.strtab);
+	      aux.strtab = NULL;
+	    }
+	  if (!get_symtab (filedata, sec, &aux.symtab, &aux.nsyms,
+			   &aux.strtab, &aux.strtab_size))
+	    return false;
+	}
+      else if (sec->sh_type == sec_type)
+	unwsec = sec;
+    }
+
+  if (unwsec == NULL)
+    printf (_("\nThere are no unwind sections in this file.\n"));
+  else
+    for (i = 0, sec = filedata->section_headers; i < filedata->file_header.e_shnum; ++i, ++sec)
+      {
+	if (sec->sh_type == sec_type)
+	  {
+	    unsigned long num_unwind = sec->sh_size / (2 * eh_addr_size);
+	    printf (ngettext ("\nUnwind section '%s' at offset 0x%lx "
+			      "contains %lu entry:\n",
+			      "\nUnwind section '%s' at offset 0x%lx "
+			      "contains %lu entries:\n",
+			      num_unwind),
+		    printable_section_name (filedata, sec),
+		    (unsigned long) sec->sh_offset,
+		    num_unwind);
+
+	    if (! dump_arm_unwind (filedata, &aux, sec))
+	      res = false;
+	  }
+      }
+
+  free (aux.symtab);
+  free ((char *) aux.strtab);
+
+  return res;
+}
+
+static bool
+no_processor_specific_unwind (Filedata * filedata ATTRIBUTE_UNUSED)
+{
+  printf (_("No processor specific unwind information to decode\n"));
+  return true;
+}
+
+static bool
+process_unwind (Filedata * filedata)
+{
+  struct unwind_handler
+  {
+    unsigned int machtype;
+    bool (* handler)(Filedata *);
+  } handlers[] =
+  {
+    { EM_ARM, arm_process_unwind },
+    { EM_IA_64, ia64_process_unwind },
+    { EM_PARISC, hppa_process_unwind },
+    { EM_TI_C6000, arm_process_unwind },
+    { EM_386, no_processor_specific_unwind },
+    { EM_X86_64, no_processor_specific_unwind },
+    { 0, NULL }
+  };
+  int i;
+
+  if (!do_unwind)
+    return true;
+
+  for (i = 0; handlers[i].handler != NULL; i++)
+    if (filedata->file_header.e_machine == handlers[i].machtype)
+      return handlers[i].handler (filedata);
+
+  printf (_("\nThe decoding of unwind sections for machine type %s is not currently supported.\n"),
+	  get_machine_name (filedata->file_header.e_machine));
+  return true;
+}
+
+static void
+dynamic_section_aarch64_val (Elf_Internal_Dyn * entry)
+{
+  switch (entry->d_tag)
+    {
+    case DT_AARCH64_BTI_PLT:
+    case DT_AARCH64_PAC_PLT:
+      break;
+    default:
+      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
+      break;
+    }
+  putchar ('\n');
+}
+
+static void
+dynamic_section_mips_val (Filedata * filedata, Elf_Internal_Dyn * entry)
+{
+  switch (entry->d_tag)
+    {
+    case DT_MIPS_FLAGS:
+      if (entry->d_un.d_val == 0)
+	printf (_("NONE"));
+      else
+	{
+	  static const char * opts[] =
+	  {
+	    "QUICKSTART", "NOTPOT", "NO_LIBRARY_REPLACEMENT",
+	    "NO_MOVE", "SGI_ONLY", "GUARANTEE_INIT", "DELTA_C_PLUS_PLUS",
+	    "GUARANTEE_START_INIT", "PIXIE", "DEFAULT_DELAY_LOAD",
+	    "REQUICKSTART", "REQUICKSTARTED", "CORD", "NO_UNRES_UNDEF",
+	    "RLD_ORDER_SAFE"
+	  };
+	  unsigned int cnt;
+	  bool first = true;
+
+	  for (cnt = 0; cnt < ARRAY_SIZE (opts); ++cnt)
+	    if (entry->d_un.d_val & (1 << cnt))
+	      {
+		printf ("%s%s", first ? "" : " ", opts[cnt]);
+		first = false;
+	      }
+	}
+      break;
+
+    case DT_MIPS_IVERSION:
+      if (VALID_DYNAMIC_NAME (filedata, entry->d_un.d_val))
+	printf (_("Interface Version: %s"),
+		GET_DYNAMIC_NAME (filedata, entry->d_un.d_val));
+      else
+	{
+	  char buf[40];
+	  sprintf_vma (buf, entry->d_un.d_ptr);
+	  /* Note: coded this way so that there is a single string for translation.  */
+	  printf (_("<corrupt: %s>"), buf);
+	}
+      break;
+
+    case DT_MIPS_TIME_STAMP:
+      {
+	char timebuf[128];
+	struct tm * tmp;
+	time_t atime = entry->d_un.d_val;
+
+	tmp = gmtime (&atime);
+	/* PR 17531: file: 6accc532.  */
+	if (tmp == NULL)
+	  snprintf (timebuf, sizeof (timebuf), _("<corrupt>"));
+	else
+	  snprintf (timebuf, sizeof (timebuf), "%04u-%02u-%02uT%02u:%02u:%02u",
+		    tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
+		    tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
+	printf (_("Time Stamp: %s"), timebuf);
+      }
+      break;
+
+    case DT_MIPS_RLD_VERSION:
+    case DT_MIPS_LOCAL_GOTNO:
+    case DT_MIPS_CONFLICTNO:
+    case DT_MIPS_LIBLISTNO:
+    case DT_MIPS_SYMTABNO:
+    case DT_MIPS_UNREFEXTNO:
+    case DT_MIPS_HIPAGENO:
+    case DT_MIPS_DELTA_CLASS_NO:
+    case DT_MIPS_DELTA_INSTANCE_NO:
+    case DT_MIPS_DELTA_RELOC_NO:
+    case DT_MIPS_DELTA_SYM_NO:
+    case DT_MIPS_DELTA_CLASSSYM_NO:
+    case DT_MIPS_COMPACT_SIZE:
+      print_vma (entry->d_un.d_val, DEC);
+      break;
+
+    case DT_MIPS_XHASH:
+      filedata->dynamic_info_DT_MIPS_XHASH = entry->d_un.d_val;
+      filedata->dynamic_info_DT_GNU_HASH = entry->d_un.d_val;
+      /* Falls through.  */
+
+    default:
+      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
+    }
+    putchar ('\n');
+}
+
+static void
+dynamic_section_parisc_val (Elf_Internal_Dyn * entry)
+{
+  switch (entry->d_tag)
+    {
+    case DT_HP_DLD_FLAGS:
+      {
+	static struct
+	{
+	  long int bit;
+	  const char * str;
+	}
+	flags[] =
+	{
+	  { DT_HP_DEBUG_PRIVATE, "HP_DEBUG_PRIVATE" },
+	  { DT_HP_DEBUG_CALLBACK, "HP_DEBUG_CALLBACK" },
+	  { DT_HP_DEBUG_CALLBACK_BOR, "HP_DEBUG_CALLBACK_BOR" },
+	  { DT_HP_NO_ENVVAR, "HP_NO_ENVVAR" },
+	  { DT_HP_BIND_NOW, "HP_BIND_NOW" },
+	  { DT_HP_BIND_NONFATAL, "HP_BIND_NONFATAL" },
+	  { DT_HP_BIND_VERBOSE, "HP_BIND_VERBOSE" },
+	  { DT_HP_BIND_RESTRICTED, "HP_BIND_RESTRICTED" },
+	  { DT_HP_BIND_SYMBOLIC, "HP_BIND_SYMBOLIC" },
+	  { DT_HP_RPATH_FIRST, "HP_RPATH_FIRST" },
+	  { DT_HP_BIND_DEPTH_FIRST, "HP_BIND_DEPTH_FIRST" },
+	  { DT_HP_GST, "HP_GST" },
+	  { DT_HP_SHLIB_FIXED, "HP_SHLIB_FIXED" },
+	  { DT_HP_MERGE_SHLIB_SEG, "HP_MERGE_SHLIB_SEG" },
+	  { DT_HP_NODELETE, "HP_NODELETE" },
+	  { DT_HP_GROUP, "HP_GROUP" },
+	  { DT_HP_PROTECT_LINKAGE_TABLE, "HP_PROTECT_LINKAGE_TABLE" }
+	};
+	bool first = true;
+	size_t cnt;
+	bfd_vma val = entry->d_un.d_val;
+
+	for (cnt = 0; cnt < ARRAY_SIZE (flags); ++cnt)
+	  if (val & flags[cnt].bit)
+	    {
+	      if (! first)
+		putchar (' ');
+	      fputs (flags[cnt].str, stdout);
+	      first = false;
+	      val ^= flags[cnt].bit;
+	    }
+
+	if (val != 0 || first)
+	  {
+	    if (! first)
+	      putchar (' ');
+	    print_vma (val, HEX);
+	  }
+      }
+      break;
+
+    default:
+      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
+      break;
+    }
+  putchar ('\n');
+}
+
+#ifdef BFD64
+
+/* VMS vs Unix time offset and factor.  */
+
+#define VMS_EPOCH_OFFSET 35067168000000000LL
+#define VMS_GRANULARITY_FACTOR 10000000
+#ifndef INT64_MIN
+#define INT64_MIN (-9223372036854775807LL - 1)
+#endif
+
+/* Display a VMS time in a human readable format.  */
+
+static void
+print_vms_time (bfd_int64_t vmstime)
+{
+  struct tm *tm = NULL;
+  time_t unxtime;
+
+  if (vmstime >= INT64_MIN + VMS_EPOCH_OFFSET)
+    {
+      vmstime = (vmstime - VMS_EPOCH_OFFSET) / VMS_GRANULARITY_FACTOR;
+      unxtime = vmstime;
+      if (unxtime == vmstime)
+	tm = gmtime (&unxtime);
+    }
+  if (tm != NULL)
+    printf ("%04u-%02u-%02uT%02u:%02u:%02u",
+	    tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
+	    tm->tm_hour, tm->tm_min, tm->tm_sec);
+}
+#endif /* BFD64 */
+
+static void
+dynamic_section_ia64_val (Elf_Internal_Dyn * entry)
+{
+  switch (entry->d_tag)
+    {
+    case DT_IA_64_PLT_RESERVE:
+      /* First 3 slots reserved.  */
+      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
+      printf (" -- ");
+      print_vma (entry->d_un.d_ptr + (3 * 8), PREFIX_HEX);
+      break;
+
+    case DT_IA_64_VMS_LINKTIME:
+#ifdef BFD64
+      print_vms_time (entry->d_un.d_val);
+#endif
+      break;
+
+    case DT_IA_64_VMS_LNKFLAGS:
+      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
+      if (entry->d_un.d_val & VMS_LF_CALL_DEBUG)
+        printf (" CALL_DEBUG");
+      if (entry->d_un.d_val & VMS_LF_NOP0BUFS)
+        printf (" NOP0BUFS");
+      if (entry->d_un.d_val & VMS_LF_P0IMAGE)
+        printf (" P0IMAGE");
+      if (entry->d_un.d_val & VMS_LF_MKTHREADS)
+        printf (" MKTHREADS");
+      if (entry->d_un.d_val & VMS_LF_UPCALLS)
+        printf (" UPCALLS");
+      if (entry->d_un.d_val & VMS_LF_IMGSTA)
+        printf (" IMGSTA");
+      if (entry->d_un.d_val & VMS_LF_INITIALIZE)
+        printf (" INITIALIZE");
+      if (entry->d_un.d_val & VMS_LF_MAIN)
+        printf (" MAIN");
+      if (entry->d_un.d_val & VMS_LF_EXE_INIT)
+        printf (" EXE_INIT");
+      if (entry->d_un.d_val & VMS_LF_TBK_IN_IMG)
+        printf (" TBK_IN_IMG");
+      if (entry->d_un.d_val & VMS_LF_DBG_IN_IMG)
+        printf (" DBG_IN_IMG");
+      if (entry->d_un.d_val & VMS_LF_TBK_IN_DSF)
+        printf (" TBK_IN_DSF");
+      if (entry->d_un.d_val & VMS_LF_DBG_IN_DSF)
+        printf (" DBG_IN_DSF");
+      if (entry->d_un.d_val & VMS_LF_SIGNATURES)
+        printf (" SIGNATURES");
+      if (entry->d_un.d_val & VMS_LF_REL_SEG_OFF)
+        printf (" REL_SEG_OFF");
+      break;
+
+    default:
+      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
+      break;
+    }
+  putchar ('\n');
+}
+
+static bool
+get_32bit_dynamic_section (Filedata * filedata)
+{
+  Elf32_External_Dyn * edyn;
+  Elf32_External_Dyn * ext;
+  Elf_Internal_Dyn * entry;
+
+  edyn = (Elf32_External_Dyn *) get_data (NULL, filedata,
+					  filedata->dynamic_addr, 1,
+					  filedata->dynamic_size,
+					  _("dynamic section"));
+  if (!edyn)
+    return false;
+
+  /* SGI's ELF has more than one section in the DYNAMIC segment, and we
+     might not have the luxury of section headers.  Look for the DT_NULL
+     terminator to determine the number of entries.  */
+  for (ext = edyn, filedata->dynamic_nent = 0;
+       (char *) (ext + 1) <= (char *) edyn + filedata->dynamic_size;
+       ext++)
+    {
+      filedata->dynamic_nent++;
+      if (BYTE_GET (ext->d_tag) == DT_NULL)
+	break;
+    }
+
+  filedata->dynamic_section
+    = (Elf_Internal_Dyn *) cmalloc (filedata->dynamic_nent, sizeof (* entry));
+  if (filedata->dynamic_section == NULL)
+    {
+      error (_("Out of memory allocating space for %lu dynamic entries\n"),
+	     (unsigned long) filedata->dynamic_nent);
+      free (edyn);
+      return false;
+    }
+
+  for (ext = edyn, entry = filedata->dynamic_section;
+       entry < filedata->dynamic_section + filedata->dynamic_nent;
+       ext++, entry++)
+    {
+      entry->d_tag      = BYTE_GET (ext->d_tag);
+      entry->d_un.d_val = BYTE_GET (ext->d_un.d_val);
+    }
+
+  free (edyn);
+
+  return true;
+}
+
+static bool
+get_64bit_dynamic_section (Filedata * filedata)
+{
+  Elf64_External_Dyn * edyn;
+  Elf64_External_Dyn * ext;
+  Elf_Internal_Dyn * entry;
+
+  /* Read in the data.  */
+  edyn = (Elf64_External_Dyn *) get_data (NULL, filedata,
+					  filedata->dynamic_addr, 1,
+					  filedata->dynamic_size,
+					  _("dynamic section"));
+  if (!edyn)
+    return false;
+
+  /* SGI's ELF has more than one section in the DYNAMIC segment, and we
+     might not have the luxury of section headers.  Look for the DT_NULL
+     terminator to determine the number of entries.  */
+  for (ext = edyn, filedata->dynamic_nent = 0;
+       /* PR 17533 file: 033-67080-0.004 - do not read past end of buffer.  */
+       (char *) (ext + 1) <= (char *) edyn + filedata->dynamic_size;
+       ext++)
+    {
+      filedata->dynamic_nent++;
+      if (BYTE_GET (ext->d_tag) == DT_NULL)
+	break;
+    }
+
+  filedata->dynamic_section
+    = (Elf_Internal_Dyn *) cmalloc (filedata->dynamic_nent, sizeof (* entry));
+  if (filedata->dynamic_section == NULL)
+    {
+      error (_("Out of memory allocating space for %lu dynamic entries\n"),
+	     (unsigned long) filedata->dynamic_nent);
+      free (edyn);
+      return false;
+    }
+
+  /* Convert from external to internal formats.  */
+  for (ext = edyn, entry = filedata->dynamic_section;
+       entry < filedata->dynamic_section + filedata->dynamic_nent;
+       ext++, entry++)
+    {
+      entry->d_tag      = BYTE_GET (ext->d_tag);
+      entry->d_un.d_val = BYTE_GET (ext->d_un.d_val);
+    }
+
+  free (edyn);
+
+  return true;
+}
+
+static bool
+get_dynamic_section (Filedata *filedata)
+{
+  if (filedata->dynamic_section)
+    return true;
+
+  if (is_32bit_elf)
+    return get_32bit_dynamic_section (filedata);
+  else
+    return get_64bit_dynamic_section (filedata);
+}
+
+static void
+print_dynamic_flags (bfd_vma flags)
+{
+  bool first = true;
+
+  while (flags)
+    {
+      bfd_vma flag;
+
+      flag = flags & - flags;
+      flags &= ~ flag;
+
+      if (first)
+	first = false;
+      else
+	putc (' ', stdout);
+
+      switch (flag)
+	{
+	case DF_ORIGIN:		fputs ("ORIGIN", stdout); break;
+	case DF_SYMBOLIC:	fputs ("SYMBOLIC", stdout); break;
+	case DF_TEXTREL:	fputs ("TEXTREL", stdout); break;
+	case DF_BIND_NOW:	fputs ("BIND_NOW", stdout); break;
+	case DF_STATIC_TLS:	fputs ("STATIC_TLS", stdout); break;
+	default:		fputs (_("unknown"), stdout); break;
+	}
+    }
+  puts ("");
+}
+
+static bfd_vma *
+get_dynamic_data (Filedata * filedata, bfd_size_type number, unsigned int ent_size)
+{
+  unsigned char * e_data;
+  bfd_vma * i_data;
+
+  /* If the size_t type is smaller than the bfd_size_type, eg because
+     you are building a 32-bit tool on a 64-bit host, then make sure
+     that when (number) is cast to (size_t) no information is lost.  */
+  if (sizeof (size_t) < sizeof (bfd_size_type)
+      && (bfd_size_type) ((size_t) number) != number)
+    {
+      error (_("Size truncation prevents reading %s elements of size %u\n"),
+	     bfd_vmatoa ("u", number), ent_size);
+      return NULL;
+    }
+
+  /* Be kind to memory checkers (eg valgrind, address sanitizer) by not
+     attempting to allocate memory when the read is bound to fail.  */
+  if (ent_size * number > filedata->file_size)
+    {
+      error (_("Invalid number of dynamic entries: %s\n"),
+	     bfd_vmatoa ("u", number));
+      return NULL;
+    }
+
+  e_data = (unsigned char *) cmalloc ((size_t) number, ent_size);
+  if (e_data == NULL)
+    {
+      error (_("Out of memory reading %s dynamic entries\n"),
+	     bfd_vmatoa ("u", number));
+      return NULL;
+    }
+
+  if (fread (e_data, ent_size, (size_t) number, filedata->handle) != number)
+    {
+      error (_("Unable to read in %s bytes of dynamic data\n"),
+	     bfd_vmatoa ("u", number * ent_size));
+      free (e_data);
+      return NULL;
+    }
+
+  i_data = (bfd_vma *) cmalloc ((size_t) number, sizeof (*i_data));
+  if (i_data == NULL)
+    {
+      error (_("Out of memory allocating space for %s dynamic entries\n"),
+	     bfd_vmatoa ("u", number));
+      free (e_data);
+      return NULL;
+    }
+
+  while (number--)
+    i_data[number] = byte_get (e_data + number * ent_size, ent_size);
+
+  free (e_data);
+
+  return i_data;
+}
+
+static unsigned long
+get_num_dynamic_syms (Filedata * filedata)
+{
+  unsigned long num_of_syms = 0;
+
+  if (!do_histogram && (!do_using_dynamic || do_dyn_syms))
+    return num_of_syms;
+
+  if (filedata->dynamic_info[DT_HASH])
+    {
+      unsigned char nb[8];
+      unsigned char nc[8];
+      unsigned int hash_ent_size = 4;
+
+      if ((filedata->file_header.e_machine == EM_ALPHA
+	   || filedata->file_header.e_machine == EM_S390
+	   || filedata->file_header.e_machine == EM_S390_OLD)
+	  && filedata->file_header.e_ident[EI_CLASS] == ELFCLASS64)
+	hash_ent_size = 8;
+
+      if (fseek (filedata->handle,
+		 (filedata->archive_file_offset
+		  + offset_from_vma (filedata, filedata->dynamic_info[DT_HASH],
+				     sizeof nb + sizeof nc)),
+		 SEEK_SET))
+	{
+	  error (_("Unable to seek to start of dynamic information\n"));
+	  goto no_hash;
+	}
+
+      if (fread (nb, hash_ent_size, 1, filedata->handle) != 1)
+	{
+	  error (_("Failed to read in number of buckets\n"));
+	  goto no_hash;
+	}
+
+      if (fread (nc, hash_ent_size, 1, filedata->handle) != 1)
+	{
+	  error (_("Failed to read in number of chains\n"));
+	  goto no_hash;
+	}
+
+      filedata->nbuckets = byte_get (nb, hash_ent_size);
+      filedata->nchains = byte_get (nc, hash_ent_size);
+
+      if (filedata->nbuckets != 0 && filedata->nchains != 0)
+	{
+	  filedata->buckets = get_dynamic_data (filedata, filedata->nbuckets,
+						hash_ent_size);
+	  filedata->chains  = get_dynamic_data (filedata, filedata->nchains,
+						hash_ent_size);
+
+	  if (filedata->buckets != NULL && filedata->chains != NULL)
+	    num_of_syms = filedata->nchains;
+	}
+    no_hash:
+      if (num_of_syms == 0)
+	{
+	  free (filedata->buckets);
+	  filedata->buckets = NULL;
+	  free (filedata->chains);
+	  filedata->chains = NULL;
+	  filedata->nbuckets = 0;
+	}
+    }
+
+  if (filedata->dynamic_info_DT_GNU_HASH)
+    {
+      unsigned char nb[16];
+      bfd_vma i, maxchain = 0xffffffff, bitmaskwords;
+      bfd_vma buckets_vma;
+      unsigned long hn;
+
+      if (fseek (filedata->handle,
+		 (filedata->archive_file_offset
+		  + offset_from_vma (filedata,
+				     filedata->dynamic_info_DT_GNU_HASH,
+				     sizeof nb)),
+		 SEEK_SET))
+	{
+	  error (_("Unable to seek to start of dynamic information\n"));
+	  goto no_gnu_hash;
+	}
+
+      if (fread (nb, 16, 1, filedata->handle) != 1)
+	{
+	  error (_("Failed to read in number of buckets\n"));
+	  goto no_gnu_hash;
+	}
+
+      filedata->ngnubuckets = byte_get (nb, 4);
+      filedata->gnusymidx = byte_get (nb + 4, 4);
+      bitmaskwords = byte_get (nb + 8, 4);
+      buckets_vma = filedata->dynamic_info_DT_GNU_HASH + 16;
+      if (is_32bit_elf)
+	buckets_vma += bitmaskwords * 4;
+      else
+	buckets_vma += bitmaskwords * 8;
+
+      if (fseek (filedata->handle,
+		 (filedata->archive_file_offset
+		  + offset_from_vma (filedata, buckets_vma, 4)),
+		 SEEK_SET))
+	{
+	  error (_("Unable to seek to start of dynamic information\n"));
+	  goto no_gnu_hash;
+	}
+
+      filedata->gnubuckets
+	= get_dynamic_data (filedata, filedata->ngnubuckets, 4);
+
+      if (filedata->gnubuckets == NULL)
+	goto no_gnu_hash;
+
+      for (i = 0; i < filedata->ngnubuckets; i++)
+	if (filedata->gnubuckets[i] != 0)
+	  {
+	    if (filedata->gnubuckets[i] < filedata->gnusymidx)
+	      goto no_gnu_hash;
+
+	    if (maxchain == 0xffffffff || filedata->gnubuckets[i] > maxchain)
+	      maxchain = filedata->gnubuckets[i];
+	  }
+
+      if (maxchain == 0xffffffff)
+	goto no_gnu_hash;
+
+      maxchain -= filedata->gnusymidx;
+
+      if (fseek (filedata->handle,
+		 (filedata->archive_file_offset
+		  + offset_from_vma (filedata,
+				     buckets_vma + 4 * (filedata->ngnubuckets
+							+ maxchain),
+				      4)),
+		 SEEK_SET))
+	{
+	  error (_("Unable to seek to start of dynamic information\n"));
+	  goto no_gnu_hash;
+	}
+
+      do
+	{
+	  if (fread (nb, 4, 1, filedata->handle) != 1)
+	    {
+	      error (_("Failed to determine last chain length\n"));
+	      goto no_gnu_hash;
+	    }
+
+	  if (maxchain + 1 == 0)
+	    goto no_gnu_hash;
+
+	  ++maxchain;
+	}
+      while ((byte_get (nb, 4) & 1) == 0);
+
+      if (fseek (filedata->handle,
+		 (filedata->archive_file_offset
+		  + offset_from_vma (filedata, (buckets_vma
+						+ 4 * filedata->ngnubuckets),
+				     4)),
+		 SEEK_SET))
+	{
+	  error (_("Unable to seek to start of dynamic information\n"));
+	  goto no_gnu_hash;
+	}
+
+      filedata->gnuchains = get_dynamic_data (filedata, maxchain, 4);
+      filedata->ngnuchains = maxchain;
+
+      if (filedata->gnuchains == NULL)
+	goto no_gnu_hash;
+
+      if (filedata->dynamic_info_DT_MIPS_XHASH)
+	{
+	  if (fseek (filedata->handle,
+		     (filedata->archive_file_offset
+		      + offset_from_vma (filedata, (buckets_vma
+						    + 4 * (filedata->ngnubuckets
+							   + maxchain)), 4)),
+		     SEEK_SET))
+	    {
+	      error (_("Unable to seek to start of dynamic information\n"));
+	      goto no_gnu_hash;
+	    }
+
+	  filedata->mipsxlat = get_dynamic_data (filedata, maxchain, 4);
+	  if (filedata->mipsxlat == NULL)
+	    goto no_gnu_hash;
+	}
+
+      for (hn = 0; hn < filedata->ngnubuckets; ++hn)
+	if (filedata->gnubuckets[hn] != 0)
+	  {
+	    bfd_vma si = filedata->gnubuckets[hn];
+	    bfd_vma off = si - filedata->gnusymidx;
+
+	    do
+	      {
+		if (filedata->dynamic_info_DT_MIPS_XHASH)
+		  {
+		    if (off < filedata->ngnuchains
+			&& filedata->mipsxlat[off] >= num_of_syms)
+		      num_of_syms = filedata->mipsxlat[off] + 1;
+		  }
+		else
+		  {
+		    if (si >= num_of_syms)
+		      num_of_syms = si + 1;
+		  }
+		si++;
+	      }
+	    while (off < filedata->ngnuchains
+		   && (filedata->gnuchains[off++] & 1) == 0);
+	  }
+
+      if (num_of_syms == 0)
+	{
+	no_gnu_hash:
+	  free (filedata->mipsxlat);
+	  filedata->mipsxlat = NULL;
+	  free (filedata->gnuchains);
+	  filedata->gnuchains = NULL;
+	  free (filedata->gnubuckets);
+	  filedata->gnubuckets = NULL;
+	  filedata->ngnubuckets = 0;
+	  filedata->ngnuchains = 0;
+	}
+    }
+
+  return num_of_syms;
+}
+
+/* Parse and display the contents of the dynamic section.  */
+
+static bool
+process_dynamic_section (Filedata * filedata)
+{
+  Elf_Internal_Dyn * entry;
+
+  if (filedata->dynamic_size <= 1)
+    {
+      if (do_dynamic)
+	{
+	  if (filedata->is_separate)
+	    printf (_("\nThere is no dynamic section in linked file '%s'.\n"),
+		    filedata->file_name);
+	  else
+	    printf (_("\nThere is no dynamic section in this file.\n"));
+	}
+
+      return true;
+    }
+
+  if (!get_dynamic_section (filedata))
+    return false;
+
+  /* Find the appropriate symbol table.  */
+  if (filedata->dynamic_symbols == NULL || do_histogram)
+    {
+      unsigned long num_of_syms;
+
+      for (entry = filedata->dynamic_section;
+	   entry < filedata->dynamic_section + filedata->dynamic_nent;
+	   ++entry)
+	if (entry->d_tag == DT_SYMTAB)
+	  filedata->dynamic_info[DT_SYMTAB] = entry->d_un.d_val;
+	else if (entry->d_tag == DT_SYMENT)
+	  filedata->dynamic_info[DT_SYMENT] = entry->d_un.d_val;
+	else if (entry->d_tag == DT_HASH)
+	  filedata->dynamic_info[DT_HASH] = entry->d_un.d_val;
+	else if (entry->d_tag == DT_GNU_HASH)
+	  filedata->dynamic_info_DT_GNU_HASH = entry->d_un.d_val;
+	else if ((filedata->file_header.e_machine == EM_MIPS
+		  || filedata->file_header.e_machine == EM_MIPS_RS3_LE)
+		 && entry->d_tag == DT_MIPS_XHASH)
+	  {
+	    filedata->dynamic_info_DT_MIPS_XHASH = entry->d_un.d_val;
+	    filedata->dynamic_info_DT_GNU_HASH = entry->d_un.d_val;
+	  }
+
+      num_of_syms = get_num_dynamic_syms (filedata);
+
+      if (num_of_syms != 0
+	  && filedata->dynamic_symbols == NULL
+	  && filedata->dynamic_info[DT_SYMTAB]
+	  && filedata->dynamic_info[DT_SYMENT])
+	{
+	  Elf_Internal_Phdr *seg;
+	  bfd_vma vma = filedata->dynamic_info[DT_SYMTAB];
+
+	  if (! get_program_headers (filedata))
+	    {
+	      error (_("Cannot interpret virtual addresses "
+		       "without program headers.\n"));
+	      return false;
+	    }
+
+	  for (seg = filedata->program_headers;
+	       seg < filedata->program_headers + filedata->file_header.e_phnum;
+	       ++seg)
+	    {
+	      if (seg->p_type != PT_LOAD)
+		continue;
+
+	      if (seg->p_offset + seg->p_filesz > filedata->file_size)
+		{
+		  /* See PR 21379 for a reproducer.  */
+		  error (_("Invalid PT_LOAD entry\n"));
+		  return false;
+		}
+
+	      if (vma >= (seg->p_vaddr & -seg->p_align)
+		  && vma < seg->p_vaddr + seg->p_filesz)
+		{
+		  /* Since we do not know how big the symbol table is,
+		     we default to reading in up to the end of PT_LOAD
+		     segment and processing that.  This is overkill, I
+		     know, but it should work.  */
+		  Elf_Internal_Shdr section;
+		  section.sh_offset = (vma - seg->p_vaddr
+				       + seg->p_offset);
+		  section.sh_size = (num_of_syms
+				     * filedata->dynamic_info[DT_SYMENT]);
+		  section.sh_entsize = filedata->dynamic_info[DT_SYMENT];
+
+		  if (do_checks
+		      && filedata->dynamic_symtab_section != NULL
+		      && ((filedata->dynamic_symtab_section->sh_offset
+			   != section.sh_offset)
+			  || (filedata->dynamic_symtab_section->sh_size
+			      != section.sh_size)
+			  || (filedata->dynamic_symtab_section->sh_entsize
+			      != section.sh_entsize)))
+		    warn (_("\
+the .dynsym section doesn't match the DT_SYMTAB and DT_SYMENT tags\n"));
+
+		  section.sh_name = filedata->string_table_length;
+		  filedata->dynamic_symbols
+		    = get_elf_symbols (filedata, &section,
+				       &filedata->num_dynamic_syms);
+		  if (filedata->dynamic_symbols == NULL
+		      || filedata->num_dynamic_syms != num_of_syms)
+		    {
+		      error (_("Corrupt DT_SYMTAB dynamic entry\n"));
+		      return false;
+		    }
+		  break;
+		}
+	    }
+	}
+    }
+
+  /* Similarly find a string table.  */
+  if (filedata->dynamic_strings == NULL)
+    for (entry = filedata->dynamic_section;
+	 entry < filedata->dynamic_section + filedata->dynamic_nent;
+	 ++entry)
+      {
+	if (entry->d_tag == DT_STRTAB)
+	  filedata->dynamic_info[DT_STRTAB] = entry->d_un.d_val;
+
+	if (entry->d_tag == DT_STRSZ)
+	  filedata->dynamic_info[DT_STRSZ] = entry->d_un.d_val;
+
+	if (filedata->dynamic_info[DT_STRTAB]
+	    && filedata->dynamic_info[DT_STRSZ])
+	  {
+	    unsigned long offset;
+	    bfd_size_type str_tab_len = filedata->dynamic_info[DT_STRSZ];
+
+	    offset = offset_from_vma (filedata,
+				      filedata->dynamic_info[DT_STRTAB],
+				      str_tab_len);
+	    if (do_checks
+		&& filedata->dynamic_strtab_section
+		&& ((filedata->dynamic_strtab_section->sh_offset
+		     != (file_ptr) offset)
+		    || (filedata->dynamic_strtab_section->sh_size
+			!= str_tab_len)))
+	      warn (_("\
+the .dynstr section doesn't match the DT_STRTAB and DT_STRSZ tags\n"));
+
+	    filedata->dynamic_strings
+	      = (char *) get_data (NULL, filedata, offset, 1, str_tab_len,
+				   _("dynamic string table"));
+	    if (filedata->dynamic_strings == NULL)
+	      {
+		error (_("Corrupt DT_STRTAB dynamic entry\n"));
+		break;
+	      }
+
+	    filedata->dynamic_strings_length = str_tab_len;
+	    break;
+	  }
+      }
+
+  /* And find the syminfo section if available.  */
+  if (filedata->dynamic_syminfo == NULL)
+    {
+      unsigned long syminsz = 0;
+
+      for (entry = filedata->dynamic_section;
+	   entry < filedata->dynamic_section + filedata->dynamic_nent;
+	   ++entry)
+	{
+	  if (entry->d_tag == DT_SYMINENT)
+	    {
+	      /* Note: these braces are necessary to avoid a syntax
+		 error from the SunOS4 C compiler.  */
+	      /* PR binutils/17531: A corrupt file can trigger this test.
+		 So do not use an assert, instead generate an error message.  */
+	      if (sizeof (Elf_External_Syminfo) != entry->d_un.d_val)
+		error (_("Bad value (%d) for SYMINENT entry\n"),
+		       (int) entry->d_un.d_val);
+	    }
+	  else if (entry->d_tag == DT_SYMINSZ)
+	    syminsz = entry->d_un.d_val;
+	  else if (entry->d_tag == DT_SYMINFO)
+	    filedata->dynamic_syminfo_offset
+	      = offset_from_vma (filedata, entry->d_un.d_val, syminsz);
+	}
+
+      if (filedata->dynamic_syminfo_offset != 0 && syminsz != 0)
+	{
+	  Elf_External_Syminfo * extsyminfo;
+	  Elf_External_Syminfo * extsym;
+	  Elf_Internal_Syminfo * syminfo;
+
+	  /* There is a syminfo section.  Read the data.  */
+	  extsyminfo = (Elf_External_Syminfo *)
+	    get_data (NULL, filedata, filedata->dynamic_syminfo_offset,
+		      1, syminsz, _("symbol information"));
+	  if (!extsyminfo)
+	    return false;
+
+	  if (filedata->dynamic_syminfo != NULL)
+	    {
+	      error (_("Multiple dynamic symbol information sections found\n"));
+	      free (filedata->dynamic_syminfo);
+	    }
+	  filedata->dynamic_syminfo = (Elf_Internal_Syminfo *) malloc (syminsz);
+	  if (filedata->dynamic_syminfo == NULL)
+	    {
+	      error (_("Out of memory allocating %lu bytes "
+		       "for dynamic symbol info\n"),
+		     (unsigned long) syminsz);
+	      return false;
+	    }
+
+	  filedata->dynamic_syminfo_nent
+	    = syminsz / sizeof (Elf_External_Syminfo);
+	  for (syminfo = filedata->dynamic_syminfo, extsym = extsyminfo;
+	       syminfo < (filedata->dynamic_syminfo
+			  + filedata->dynamic_syminfo_nent);
+	       ++syminfo, ++extsym)
+	    {
+	      syminfo->si_boundto = BYTE_GET (extsym->si_boundto);
+	      syminfo->si_flags = BYTE_GET (extsym->si_flags);
+	    }
+
+	  free (extsyminfo);
+	}
+    }
+
+  if (do_dynamic && filedata->dynamic_addr)
+    {
+      if (filedata->dynamic_nent == 1)
+	{
+	  if (filedata->is_separate)
+	    printf (_("\nIn linked file '%s' the dynamic section at offset 0x%lx contains 1 entry:\n"),
+		    filedata->file_name,
+		    filedata->dynamic_addr);
+	  else
+	    printf (_("\nDynamic section at offset 0x%lx contains 1 entry:\n"),
+		    filedata->dynamic_addr);
+	}
+      else
+	{
+	  if (filedata->is_separate)
+	    printf (_("\nIn linked file '%s' the dynamic section at offset 0x%lx contains %lu entries:\n"),
+		    filedata->file_name,
+		    filedata->dynamic_addr,
+		    (unsigned long) filedata->dynamic_nent);
+	  else
+	    printf (_("\nDynamic section at offset 0x%lx contains %lu entries:\n"),
+		    filedata->dynamic_addr,
+		    (unsigned long) filedata->dynamic_nent);
+	}
+    }
+  if (do_dynamic)
+    printf (_("  Tag        Type                         Name/Value\n"));
+
+  for (entry = filedata->dynamic_section;
+       entry < filedata->dynamic_section + filedata->dynamic_nent;
+       entry++)
+    {
+      if (do_dynamic)
+	{
+	  const char * dtype;
+
+	  putchar (' ');
+	  print_vma (entry->d_tag, FULL_HEX);
+	  dtype = get_dynamic_type (filedata, entry->d_tag);
+	  printf (" (%s)%*s", dtype,
+		  ((is_32bit_elf ? 27 : 19) - (int) strlen (dtype)), " ");
+	}
+
+      switch (entry->d_tag)
+	{
+	case DT_FLAGS:
+	  if (do_dynamic)
+	    print_dynamic_flags (entry->d_un.d_val);
+	  break;
+
+	case DT_AUXILIARY:
+	case DT_FILTER:
+	case DT_CONFIG:
+	case DT_DEPAUDIT:
+	case DT_AUDIT:
+	  if (do_dynamic)
+	    {
+	      switch (entry->d_tag)
+		{
+		case DT_AUXILIARY:
+		  printf (_("Auxiliary library"));
+		  break;
+
+		case DT_FILTER:
+		  printf (_("Filter library"));
+		  break;
+
+		case DT_CONFIG:
+		  printf (_("Configuration file"));
+		  break;
+
+		case DT_DEPAUDIT:
+		  printf (_("Dependency audit library"));
+		  break;
+
+		case DT_AUDIT:
+		  printf (_("Audit library"));
+		  break;
+		}
+
+	      if (VALID_DYNAMIC_NAME (filedata, entry->d_un.d_val))
+		printf (": [%s]\n",
+			GET_DYNAMIC_NAME (filedata, entry->d_un.d_val));
+	      else
+		{
+		  printf (": ");
+		  print_vma (entry->d_un.d_val, PREFIX_HEX);
+		  putchar ('\n');
+		}
+	    }
+	  break;
+
+	case DT_FEATURE:
+	  if (do_dynamic)
+	    {
+	      printf (_("Flags:"));
+
+	      if (entry->d_un.d_val == 0)
+		printf (_(" None\n"));
+	      else
+		{
+		  unsigned long int val = entry->d_un.d_val;
+
+		  if (val & DTF_1_PARINIT)
+		    {
+		      printf (" PARINIT");
+		      val ^= DTF_1_PARINIT;
+		    }
+		  if (val & DTF_1_CONFEXP)
+		    {
+		      printf (" CONFEXP");
+		      val ^= DTF_1_CONFEXP;
+		    }
+		  if (val != 0)
+		    printf (" %lx", val);
+		  puts ("");
+		}
+	    }
+	  break;
+
+	case DT_POSFLAG_1:
+	  if (do_dynamic)
+	    {
+	      printf (_("Flags:"));
+
+	      if (entry->d_un.d_val == 0)
+		printf (_(" None\n"));
+	      else
+		{
+		  unsigned long int val = entry->d_un.d_val;
+
+		  if (val & DF_P1_LAZYLOAD)
+		    {
+		      printf (" LAZYLOAD");
+		      val ^= DF_P1_LAZYLOAD;
+		    }
+		  if (val & DF_P1_GROUPPERM)
+		    {
+		      printf (" GROUPPERM");
+		      val ^= DF_P1_GROUPPERM;
+		    }
+		  if (val != 0)
+		    printf (" %lx", val);
+		  puts ("");
+		}
+	    }
+	  break;
+
+	case DT_FLAGS_1:
+	  if (do_dynamic)
+	    {
+	      printf (_("Flags:"));
+	      if (entry->d_un.d_val == 0)
+		printf (_(" None\n"));
+	      else
+		{
+		  unsigned long int val = entry->d_un.d_val;
+
+		  if (val & DF_1_NOW)
+		    {
+		      printf (" NOW");
+		      val ^= DF_1_NOW;
+		    }
+		  if (val & DF_1_GLOBAL)
+		    {
+		      printf (" GLOBAL");
+		      val ^= DF_1_GLOBAL;
+		    }
+		  if (val & DF_1_GROUP)
+		    {
+		      printf (" GROUP");
+		      val ^= DF_1_GROUP;
+		    }
+		  if (val & DF_1_NODELETE)
+		    {
+		      printf (" NODELETE");
+		      val ^= DF_1_NODELETE;
+		    }
+		  if (val & DF_1_LOADFLTR)
+		    {
+		      printf (" LOADFLTR");
+		      val ^= DF_1_LOADFLTR;
+		    }
+		  if (val & DF_1_INITFIRST)
+		    {
+		      printf (" INITFIRST");
+		      val ^= DF_1_INITFIRST;
+		    }
+		  if (val & DF_1_NOOPEN)
+		    {
+		      printf (" NOOPEN");
+		      val ^= DF_1_NOOPEN;
+		    }
+		  if (val & DF_1_ORIGIN)
+		    {
+		      printf (" ORIGIN");
+		      val ^= DF_1_ORIGIN;
+		    }
+		  if (val & DF_1_DIRECT)
+		    {
+		      printf (" DIRECT");
+		      val ^= DF_1_DIRECT;
+		    }
+		  if (val & DF_1_TRANS)
+		    {
+		      printf (" TRANS");
+		      val ^= DF_1_TRANS;
+		    }
+		  if (val & DF_1_INTERPOSE)
+		    {
+		      printf (" INTERPOSE");
+		      val ^= DF_1_INTERPOSE;
+		    }
+		  if (val & DF_1_NODEFLIB)
+		    {
+		      printf (" NODEFLIB");
+		      val ^= DF_1_NODEFLIB;
+		    }
+		  if (val & DF_1_NODUMP)
+		    {
+		      printf (" NODUMP");
+		      val ^= DF_1_NODUMP;
+		    }
+		  if (val & DF_1_CONFALT)
+		    {
+		      printf (" CONFALT");
+		      val ^= DF_1_CONFALT;
+		    }
+		  if (val & DF_1_ENDFILTEE)
+		    {
+		      printf (" ENDFILTEE");
+		      val ^= DF_1_ENDFILTEE;
+		    }
+		  if (val & DF_1_DISPRELDNE)
+		    {
+		      printf (" DISPRELDNE");
+		      val ^= DF_1_DISPRELDNE;
+		    }
+		  if (val & DF_1_DISPRELPND)
+		    {
+		      printf (" DISPRELPND");
+		      val ^= DF_1_DISPRELPND;
+		    }
+		  if (val & DF_1_NODIRECT)
+		    {
+		      printf (" NODIRECT");
+		      val ^= DF_1_NODIRECT;
+		    }
+		  if (val & DF_1_IGNMULDEF)
+		    {
+		      printf (" IGNMULDEF");
+		      val ^= DF_1_IGNMULDEF;
+		    }
+		  if (val & DF_1_NOKSYMS)
+		    {
+		      printf (" NOKSYMS");
+		      val ^= DF_1_NOKSYMS;
+		    }
+		  if (val & DF_1_NOHDR)
+		    {
+		      printf (" NOHDR");
+		      val ^= DF_1_NOHDR;
+		    }
+		  if (val & DF_1_EDITED)
+		    {
+		      printf (" EDITED");
+		      val ^= DF_1_EDITED;
+		    }
+		  if (val & DF_1_NORELOC)
+		    {
+		      printf (" NORELOC");
+		      val ^= DF_1_NORELOC;
+		    }
+		  if (val & DF_1_SYMINTPOSE)
+		    {
+		      printf (" SYMINTPOSE");
+		      val ^= DF_1_SYMINTPOSE;
+		    }
+		  if (val & DF_1_GLOBAUDIT)
+		    {
+		      printf (" GLOBAUDIT");
+		      val ^= DF_1_GLOBAUDIT;
+		    }
+		  if (val & DF_1_SINGLETON)
+		    {
+		      printf (" SINGLETON");
+		      val ^= DF_1_SINGLETON;
+		    }
+		  if (val & DF_1_STUB)
+		    {
+		      printf (" STUB");
+		      val ^= DF_1_STUB;
+		    }
+		  if (val & DF_1_PIE)
+		    {
+		      printf (" PIE");
+		      val ^= DF_1_PIE;
+		    }
+		  if (val & DF_1_KMOD)
+		    {
+		      printf (" KMOD");
+		      val ^= DF_1_KMOD;
+		    }
+		  if (val & DF_1_WEAKFILTER)
+		    {
+		      printf (" WEAKFILTER");
+		      val ^= DF_1_WEAKFILTER;
+		    }
+		  if (val & DF_1_NOCOMMON)
+		    {
+		      printf (" NOCOMMON");
+		      val ^= DF_1_NOCOMMON;
+		    }
+		  if (val != 0)
+		    printf (" %lx", val);
+		  puts ("");
+		}
+	    }
+	  break;
+
+	case DT_PLTREL:
+	  filedata->dynamic_info[entry->d_tag] = entry->d_un.d_val;
+	  if (do_dynamic)
+	    puts (get_dynamic_type (filedata, entry->d_un.d_val));
+	  break;
+
+	case DT_NULL	:
+	case DT_NEEDED	:
+	case DT_PLTGOT	:
+	case DT_HASH	:
+	case DT_STRTAB	:
+	case DT_SYMTAB	:
+	case DT_RELA	:
+	case DT_INIT	:
+	case DT_FINI	:
+	case DT_SONAME	:
+	case DT_RPATH	:
+	case DT_SYMBOLIC:
+	case DT_REL	:
+	case DT_DEBUG	:
+	case DT_TEXTREL	:
+	case DT_JMPREL	:
+	case DT_RUNPATH	:
+	  filedata->dynamic_info[entry->d_tag] = entry->d_un.d_val;
+
+	  if (do_dynamic)
+	    {
+	      char * name;
+
+	      if (VALID_DYNAMIC_NAME (filedata, entry->d_un.d_val))
+		name = GET_DYNAMIC_NAME (filedata, entry->d_un.d_val);
+	      else
+		name = NULL;
+
+	      if (name)
+		{
+		  switch (entry->d_tag)
+		    {
+		    case DT_NEEDED:
+		      printf (_("Shared library: [%s]"), name);
+
+		      if (filedata->program_interpreter
+			  && streq (name, filedata->program_interpreter))
+			printf (_(" program interpreter"));
+		      break;
+
+		    case DT_SONAME:
+		      printf (_("Library soname: [%s]"), name);
+		      break;
+
+		    case DT_RPATH:
+		      printf (_("Library rpath: [%s]"), name);
+		      break;
+
+		    case DT_RUNPATH:
+		      printf (_("Library runpath: [%s]"), name);
+		      break;
+
+		    default:
+		      print_vma (entry->d_un.d_val, PREFIX_HEX);
+		      break;
+		    }
+		}
+	      else
+		print_vma (entry->d_un.d_val, PREFIX_HEX);
+
+	      putchar ('\n');
+	    }
+	  break;
+
+	case DT_PLTRELSZ:
+	case DT_RELASZ	:
+	case DT_STRSZ	:
+	case DT_RELSZ	:
+	case DT_RELAENT	:
+	case DT_SYMENT	:
+	case DT_RELENT	:
+	  filedata->dynamic_info[entry->d_tag] = entry->d_un.d_val;
+	  /* Fall through.  */
+	case DT_PLTPADSZ:
+	case DT_MOVEENT	:
+	case DT_MOVESZ	:
+	case DT_INIT_ARRAYSZ:
+	case DT_FINI_ARRAYSZ:
+	case DT_GNU_CONFLICTSZ:
+	case DT_GNU_LIBLISTSZ:
+	  if (do_dynamic)
+	    {
+	      print_vma (entry->d_un.d_val, UNSIGNED);
+	      printf (_(" (bytes)\n"));
+	    }
+	  break;
+
+	case DT_VERDEFNUM:
+	case DT_VERNEEDNUM:
+	case DT_RELACOUNT:
+	case DT_RELCOUNT:
+	  if (do_dynamic)
+	    {
+	      print_vma (entry->d_un.d_val, UNSIGNED);
+	      putchar ('\n');
+	    }
+	  break;
+
+	case DT_SYMINSZ:
+	case DT_SYMINENT:
+	case DT_SYMINFO:
+	case DT_USED:
+	case DT_INIT_ARRAY:
+	case DT_FINI_ARRAY:
+	  if (do_dynamic)
+	    {
+	      if (entry->d_tag == DT_USED
+		  && VALID_DYNAMIC_NAME (filedata, entry->d_un.d_val))
+		{
+		  char * name = GET_DYNAMIC_NAME (filedata, entry->d_un.d_val);
+
+		  if (*name)
+		    {
+		      printf (_("Not needed object: [%s]\n"), name);
+		      break;
+		    }
+		}
+
+	      print_vma (entry->d_un.d_val, PREFIX_HEX);
+	      putchar ('\n');
+	    }
+	  break;
+
+	case DT_BIND_NOW:
+	  /* The value of this entry is ignored.  */
+	  if (do_dynamic)
+	    putchar ('\n');
+	  break;
+
+	case DT_GNU_PRELINKED:
+	  if (do_dynamic)
+	    {
+	      struct tm * tmp;
+	      time_t atime = entry->d_un.d_val;
+
+	      tmp = gmtime (&atime);
+	      /* PR 17533 file: 041-1244816-0.004.  */
+	      if (tmp == NULL)
+		printf (_("<corrupt time val: %lx"),
+			(unsigned long) atime);
+	      else
+		printf ("%04u-%02u-%02uT%02u:%02u:%02u\n",
+			tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
+			tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
+
+	    }
+	  break;
+
+	case DT_GNU_HASH:
+	  filedata->dynamic_info_DT_GNU_HASH = entry->d_un.d_val;
+	  if (do_dynamic)
+	    {
+	      print_vma (entry->d_un.d_val, PREFIX_HEX);
+	      putchar ('\n');
+	    }
+	  break;
+
+	case DT_GNU_FLAGS_1:
+	  if (do_dynamic)
+	    {
+	      printf (_("Flags:"));
+	      if (entry->d_un.d_val == 0)
+		printf (_(" None\n"));
+	      else
+		{
+		  unsigned long int val = entry->d_un.d_val;
+
+		  if (val & DF_GNU_1_UNIQUE)
+		    {
+		      printf (" UNIQUE");
+		      val ^= DF_GNU_1_UNIQUE;
+		    }
+		  if (val != 0)
+		    printf (" %lx", val);
+		  puts ("");
+		}
+	    }
+	  break;
+
+	default:
+	  if ((entry->d_tag >= DT_VERSYM) && (entry->d_tag <= DT_VERNEEDNUM))
+	    filedata->version_info[DT_VERSIONTAGIDX (entry->d_tag)]
+	      = entry->d_un.d_val;
+
+	  if (do_dynamic)
+	    {
+	      switch (filedata->file_header.e_machine)
+		{
+		case EM_AARCH64:
+		  dynamic_section_aarch64_val (entry);
+		  break;
+		case EM_MIPS:
+		case EM_MIPS_RS3_LE:
+		  dynamic_section_mips_val (filedata, entry);
+		  break;
+		case EM_PARISC:
+		  dynamic_section_parisc_val (entry);
+		  break;
+		case EM_IA_64:
+		  dynamic_section_ia64_val (entry);
+		  break;
+		default:
+		  print_vma (entry->d_un.d_val, PREFIX_HEX);
+		  putchar ('\n');
+		}
+	    }
+	  break;
+	}
+    }
+
+  return true;
+}
+
+static char *
+get_ver_flags (unsigned int flags)
+{
+  static char buff[128];
+
+  buff[0] = 0;
+
+  if (flags == 0)
+    return _("none");
+
+  if (flags & VER_FLG_BASE)
+    strcat (buff, "BASE");
+
+  if (flags & VER_FLG_WEAK)
+    {
+      if (flags & VER_FLG_BASE)
+	strcat (buff, " | ");
+
+      strcat (buff, "WEAK");
+    }
+
+  if (flags & VER_FLG_INFO)
+    {
+      if (flags & (VER_FLG_BASE|VER_FLG_WEAK))
+	strcat (buff, " | ");
+
+      strcat (buff, "INFO");
+    }
+
+  if (flags & ~(VER_FLG_BASE | VER_FLG_WEAK | VER_FLG_INFO))
+    {
+      if (flags & (VER_FLG_BASE | VER_FLG_WEAK | VER_FLG_INFO))
+	strcat (buff, " | ");
+
+      strcat (buff, _("<unknown>"));
+    }
+
+  return buff;
+}
+
+/* Display the contents of the version sections.  */
+
+static bool
+process_version_sections (Filedata * filedata)
+{
+  Elf_Internal_Shdr * section;
+  unsigned i;
+  bool found = false;
+
+  if (! do_version)
+    return true;
+
+  for (i = 0, section = filedata->section_headers;
+       i < filedata->file_header.e_shnum;
+       i++, section++)
+    {
+      switch (section->sh_type)
+	{
+	case SHT_GNU_verdef:
+	  {
+	    Elf_External_Verdef * edefs;
+	    unsigned long idx;
+	    unsigned long cnt;
+	    char * endbuf;
+
+	    found = true;
+
+	    if (filedata->is_separate)
+	      printf (ngettext ("\nIn linked file '%s' the version definition section '%s' contains %u entry:\n",
+				"\nIn linked file '%s' the version definition section '%s' contains %u entries:\n",
+				section->sh_info),
+		      filedata->file_name,
+		      printable_section_name (filedata, section),
+		      section->sh_info);
+	    else
+	      printf (ngettext ("\nVersion definition section '%s' "
+				"contains %u entry:\n",
+				"\nVersion definition section '%s' "
+				"contains %u entries:\n",
+				section->sh_info),
+		      printable_section_name (filedata, section),
+		      section->sh_info);
+
+	    printf (_(" Addr: 0x"));
+	    printf_vma (section->sh_addr);
+	    printf (_("  Offset: %#08lx  Link: %u (%s)\n"),
+		    (unsigned long) section->sh_offset, section->sh_link,
+		    printable_section_name_from_index (filedata, section->sh_link));
+
+	    edefs = (Elf_External_Verdef *)
+                get_data (NULL, filedata, section->sh_offset, 1,section->sh_size,
+                          _("version definition section"));
+	    if (!edefs)
+	      break;
+	    endbuf = (char *) edefs + section->sh_size;
+
+	    for (idx = cnt = 0; cnt < section->sh_info; ++cnt)
+	      {
+		char * vstart;
+		Elf_External_Verdef * edef;
+		Elf_Internal_Verdef ent;
+		Elf_External_Verdaux * eaux;
+		Elf_Internal_Verdaux aux;
+		unsigned long isum;
+		int j;
+
+		vstart = ((char *) edefs) + idx;
+		if (vstart + sizeof (*edef) > endbuf)
+		  break;
+
+		edef = (Elf_External_Verdef *) vstart;
+
+		ent.vd_version = BYTE_GET (edef->vd_version);
+		ent.vd_flags   = BYTE_GET (edef->vd_flags);
+		ent.vd_ndx     = BYTE_GET (edef->vd_ndx);
+		ent.vd_cnt     = BYTE_GET (edef->vd_cnt);
+		ent.vd_hash    = BYTE_GET (edef->vd_hash);
+		ent.vd_aux     = BYTE_GET (edef->vd_aux);
+		ent.vd_next    = BYTE_GET (edef->vd_next);
+
+		printf (_("  %#06lx: Rev: %d  Flags: %s"),
+			idx, ent.vd_version, get_ver_flags (ent.vd_flags));
+
+		printf (_("  Index: %d  Cnt: %d  "),
+			ent.vd_ndx, ent.vd_cnt);
+
+		/* Check for overflow.  */
+		if (ent.vd_aux > (size_t) (endbuf - vstart))
+		  break;
+
+		vstart += ent.vd_aux;
+
+		if (vstart + sizeof (*eaux) > endbuf)
+		  break;
+		eaux = (Elf_External_Verdaux *) vstart;
+
+		aux.vda_name = BYTE_GET (eaux->vda_name);
+		aux.vda_next = BYTE_GET (eaux->vda_next);
+
+		if (VALID_DYNAMIC_NAME (filedata, aux.vda_name))
+		  printf (_("Name: %s\n"),
+			  GET_DYNAMIC_NAME (filedata, aux.vda_name));
+		else
+		  printf (_("Name index: %ld\n"), aux.vda_name);
+
+		isum = idx + ent.vd_aux;
+
+		for (j = 1; j < ent.vd_cnt; j++)
+		  {
+		    if (aux.vda_next < sizeof (*eaux)
+			&& !(j == ent.vd_cnt - 1 && aux.vda_next == 0))
+		      {
+			warn (_("Invalid vda_next field of %lx\n"),
+			      aux.vda_next);
+			j = ent.vd_cnt;
+			break;
+		      }
+		    /* Check for overflow.  */
+		    if (aux.vda_next > (size_t) (endbuf - vstart))
+		      break;
+
+		    isum   += aux.vda_next;
+		    vstart += aux.vda_next;
+
+		    if (vstart + sizeof (*eaux) > endbuf)
+		      break;
+		    eaux = (Elf_External_Verdaux *) vstart;
+
+		    aux.vda_name = BYTE_GET (eaux->vda_name);
+		    aux.vda_next = BYTE_GET (eaux->vda_next);
+
+		    if (VALID_DYNAMIC_NAME (filedata, aux.vda_name))
+		      printf (_("  %#06lx: Parent %d: %s\n"),
+			      isum, j,
+			      GET_DYNAMIC_NAME (filedata, aux.vda_name));
+		    else
+		      printf (_("  %#06lx: Parent %d, name index: %ld\n"),
+			      isum, j, aux.vda_name);
+		  }
+
+		if (j < ent.vd_cnt)
+		  printf (_("  Version def aux past end of section\n"));
+
+		/* PR 17531:
+		   file: id:000001,src:000172+005151,op:splice,rep:2.  */
+		if (ent.vd_next < sizeof (*edef)
+		    && !(cnt == section->sh_info - 1 && ent.vd_next == 0))
+		  {
+		    warn (_("Invalid vd_next field of %lx\n"), ent.vd_next);
+		    cnt = section->sh_info;
+		    break;
+		  }
+		if (ent.vd_next > (size_t) (endbuf - ((char *) edefs + idx)))
+		  break;
+
+		idx += ent.vd_next;
+	      }
+
+	    if (cnt < section->sh_info)
+	      printf (_("  Version definition past end of section\n"));
+
+	    free (edefs);
+	  }
+	  break;
+
+	case SHT_GNU_verneed:
+	  {
+	    Elf_External_Verneed * eneed;
+	    unsigned long idx;
+	    unsigned long cnt;
+	    char * endbuf;
+
+	    found = true;
+
+	    if (filedata->is_separate)
+	      printf (ngettext ("\nIn linked file '%s' the version needs section '%s' contains %u entry:\n",
+				"\nIn linked file '%s' the version needs section '%s' contains %u entries:\n",
+				section->sh_info),
+		      filedata->file_name,
+		      printable_section_name (filedata, section),
+		      section->sh_info);
+	    else
+	      printf (ngettext ("\nVersion needs section '%s' "
+				"contains %u entry:\n",
+				"\nVersion needs section '%s' "
+				"contains %u entries:\n",
+				section->sh_info),
+		      printable_section_name (filedata, section),
+		      section->sh_info);
+
+	    printf (_(" Addr: 0x"));
+	    printf_vma (section->sh_addr);
+	    printf (_("  Offset: %#08lx  Link: %u (%s)\n"),
+		    (unsigned long) section->sh_offset, section->sh_link,
+		    printable_section_name_from_index (filedata, section->sh_link));
+
+	    eneed = (Elf_External_Verneed *) get_data (NULL, filedata,
+                                                       section->sh_offset, 1,
+                                                       section->sh_size,
+                                                       _("Version Needs section"));
+	    if (!eneed)
+	      break;
+	    endbuf = (char *) eneed + section->sh_size;
+
+	    for (idx = cnt = 0; cnt < section->sh_info; ++cnt)
+	      {
+		Elf_External_Verneed * entry;
+		Elf_Internal_Verneed ent;
+		unsigned long isum;
+		int j;
+		char * vstart;
+
+		vstart = ((char *) eneed) + idx;
+		if (vstart + sizeof (*entry) > endbuf)
+		  break;
+
+		entry = (Elf_External_Verneed *) vstart;
+
+		ent.vn_version = BYTE_GET (entry->vn_version);
+		ent.vn_cnt     = BYTE_GET (entry->vn_cnt);
+		ent.vn_file    = BYTE_GET (entry->vn_file);
+		ent.vn_aux     = BYTE_GET (entry->vn_aux);
+		ent.vn_next    = BYTE_GET (entry->vn_next);
+
+		printf (_("  %#06lx: Version: %d"), idx, ent.vn_version);
+
+		if (VALID_DYNAMIC_NAME (filedata, ent.vn_file))
+		  printf (_("  File: %s"),
+			  GET_DYNAMIC_NAME (filedata, ent.vn_file));
+		else
+		  printf (_("  File: %lx"), ent.vn_file);
+
+		printf (_("  Cnt: %d\n"), ent.vn_cnt);
+
+		/* Check for overflow.  */
+		if (ent.vn_aux > (size_t) (endbuf - vstart))
+		  break;
+		vstart += ent.vn_aux;
+
+		for (j = 0, isum = idx + ent.vn_aux; j < ent.vn_cnt; ++j)
+		  {
+		    Elf_External_Vernaux * eaux;
+		    Elf_Internal_Vernaux aux;
+
+		    if (vstart + sizeof (*eaux) > endbuf)
+		      break;
+		    eaux = (Elf_External_Vernaux *) vstart;
+
+		    aux.vna_hash  = BYTE_GET (eaux->vna_hash);
+		    aux.vna_flags = BYTE_GET (eaux->vna_flags);
+		    aux.vna_other = BYTE_GET (eaux->vna_other);
+		    aux.vna_name  = BYTE_GET (eaux->vna_name);
+		    aux.vna_next  = BYTE_GET (eaux->vna_next);
+
+		    if (VALID_DYNAMIC_NAME (filedata, aux.vna_name))
+		      printf (_("  %#06lx:   Name: %s"),
+			      isum, GET_DYNAMIC_NAME (filedata, aux.vna_name));
+		    else
+		      printf (_("  %#06lx:   Name index: %lx"),
+			      isum, aux.vna_name);
+
+		    printf (_("  Flags: %s  Version: %d\n"),
+			    get_ver_flags (aux.vna_flags), aux.vna_other);
+
+		    if (aux.vna_next < sizeof (*eaux)
+			&& !(j == ent.vn_cnt - 1 && aux.vna_next == 0))
+		      {
+			warn (_("Invalid vna_next field of %lx\n"),
+			      aux.vna_next);
+			j = ent.vn_cnt;
+			break;
+		      }
+		    /* Check for overflow.  */
+		    if (aux.vna_next > (size_t) (endbuf - vstart))
+		      break;
+		    isum   += aux.vna_next;
+		    vstart += aux.vna_next;
+		  }
+
+		if (j < ent.vn_cnt)
+		  warn (_("Missing Version Needs auxiliary information\n"));
+
+		if (ent.vn_next < sizeof (*entry)
+		    && !(cnt == section->sh_info - 1 && ent.vn_next == 0))
+		  {
+		    warn (_("Invalid vn_next field of %lx\n"), ent.vn_next);
+		    cnt = section->sh_info;
+		    break;
+		  }
+		if (ent.vn_next > (size_t) (endbuf - ((char *) eneed + idx)))
+		  break;
+		idx += ent.vn_next;
+	      }
+
+	    if (cnt < section->sh_info)
+	      warn (_("Missing Version Needs information\n"));
+
+	    free (eneed);
+	  }
+	  break;
+
+	case SHT_GNU_versym:
+	  {
+	    Elf_Internal_Shdr * link_section;
+	    size_t total;
+	    unsigned int cnt;
+	    unsigned char * edata;
+	    unsigned short * data;
+	    char * strtab;
+	    Elf_Internal_Sym * symbols;
+	    Elf_Internal_Shdr * string_sec;
+	    unsigned long num_syms;
+	    long off;
+
+	    if (section->sh_link >= filedata->file_header.e_shnum)
+	      break;
+
+	    link_section = filedata->section_headers + section->sh_link;
+	    total = section->sh_size / sizeof (Elf_External_Versym);
+
+	    if (link_section->sh_link >= filedata->file_header.e_shnum)
+	      break;
+
+	    found = true;
+
+	    symbols = get_elf_symbols (filedata, link_section, & num_syms);
+	    if (symbols == NULL)
+	      break;
+
+	    string_sec = filedata->section_headers + link_section->sh_link;
+
+	    strtab = (char *) get_data (NULL, filedata, string_sec->sh_offset, 1,
+                                        string_sec->sh_size,
+                                        _("version string table"));
+	    if (!strtab)
+	      {
+		free (symbols);
+		break;
+	      }
+
+	    if (filedata->is_separate)
+	      printf (ngettext ("\nIn linked file '%s' the version symbols section '%s' contains %lu entry:\n",
+				"\nIn linked file '%s' the version symbols section '%s' contains %lu entries:\n",
+				total),
+		      filedata->file_name,
+		      printable_section_name (filedata, section),
+		      (unsigned long) total);
+	    else
+	      printf (ngettext ("\nVersion symbols section '%s' "
+				"contains %lu entry:\n",
+				"\nVersion symbols section '%s' "
+				"contains %lu entries:\n",
+				total),
+		      printable_section_name (filedata, section),
+		      (unsigned long) total);
+
+	    printf (_(" Addr: 0x"));
+	    printf_vma (section->sh_addr);
+	    printf (_("  Offset: %#08lx  Link: %u (%s)\n"),
+		    (unsigned long) section->sh_offset, section->sh_link,
+		    printable_section_name (filedata, link_section));
+
+	    off = offset_from_vma (filedata,
+				   filedata->version_info[DT_VERSIONTAGIDX (DT_VERSYM)],
+				   total * sizeof (short));
+	    edata = (unsigned char *) get_data (NULL, filedata, off,
+						sizeof (short), total,
+						_("version symbol data"));
+	    if (!edata)
+	      {
+		free (strtab);
+		free (symbols);
+		break;
+	      }
+
+	    data = (short unsigned int *) cmalloc (total, sizeof (short));
+
+	    for (cnt = total; cnt --;)
+	      data[cnt] = byte_get (edata + cnt * sizeof (short),
+				    sizeof (short));
+
+	    free (edata);
+
+	    for (cnt = 0; cnt < total; cnt += 4)
+	      {
+		int j, nn;
+		char *name;
+		char *invalid = _("*invalid*");
+
+		printf ("  %03x:", cnt);
+
+		for (j = 0; (j < 4) && (cnt + j) < total; ++j)
+		  switch (data[cnt + j])
+		    {
+		    case 0:
+		      fputs (_("   0 (*local*)    "), stdout);
+		      break;
+
+		    case 1:
+		      fputs (_("   1 (*global*)   "), stdout);
+		      break;
+
+		    default:
+		      nn = printf ("%4x%c", data[cnt + j] & VERSYM_VERSION,
+				   data[cnt + j] & VERSYM_HIDDEN ? 'h' : ' ');
+
+		      /* If this index value is greater than the size of the symbols
+		         array, break to avoid an out-of-bounds read.  */
+		      if ((unsigned long)(cnt + j) >= num_syms)
+		        {
+		          warn (_("invalid index into symbol array\n"));
+		          break;
+			}
+
+		      name = NULL;
+		      if (filedata->version_info[DT_VERSIONTAGIDX (DT_VERNEED)])
+			{
+			  Elf_Internal_Verneed ivn;
+			  unsigned long offset;
+
+			  offset = offset_from_vma
+			    (filedata,
+			     filedata->version_info[DT_VERSIONTAGIDX (DT_VERNEED)],
+			     sizeof (Elf_External_Verneed));
+
+			  do
+			    {
+			      Elf_Internal_Vernaux ivna;
+			      Elf_External_Verneed evn;
+			      Elf_External_Vernaux evna;
+			      unsigned long a_off;
+
+			      if (get_data (&evn, filedata, offset, sizeof (evn), 1,
+					    _("version need")) == NULL)
+				break;
+
+			      ivn.vn_aux  = BYTE_GET (evn.vn_aux);
+			      ivn.vn_next = BYTE_GET (evn.vn_next);
+
+			      a_off = offset + ivn.vn_aux;
+
+			      do
+				{
+				  if (get_data (&evna, filedata, a_off, sizeof (evna),
+						1, _("version need aux (2)")) == NULL)
+				    {
+				      ivna.vna_next  = 0;
+				      ivna.vna_other = 0;
+				    }
+				  else
+				    {
+				      ivna.vna_next  = BYTE_GET (evna.vna_next);
+				      ivna.vna_other = BYTE_GET (evna.vna_other);
+				    }
+
+				  a_off += ivna.vna_next;
+				}
+			      while (ivna.vna_other != data[cnt + j]
+				     && ivna.vna_next != 0);
+
+			      if (ivna.vna_other == data[cnt + j])
+				{
+				  ivna.vna_name = BYTE_GET (evna.vna_name);
+
+				  if (ivna.vna_name >= string_sec->sh_size)
+				    name = invalid;
+				  else
+				    name = strtab + ivna.vna_name;
+				  break;
+				}
+
+			      offset += ivn.vn_next;
+			    }
+			  while (ivn.vn_next);
+			}
+
+		      if (data[cnt + j] != 0x8001
+			  && filedata->version_info[DT_VERSIONTAGIDX (DT_VERDEF)])
+			{
+			  Elf_Internal_Verdef ivd;
+			  Elf_External_Verdef evd;
+			  unsigned long offset;
+
+			  offset = offset_from_vma
+			    (filedata,
+			     filedata->version_info[DT_VERSIONTAGIDX (DT_VERDEF)],
+			     sizeof evd);
+
+			  do
+			    {
+			      if (get_data (&evd, filedata, offset, sizeof (evd), 1,
+					    _("version def")) == NULL)
+				{
+				  ivd.vd_next = 0;
+				  /* PR 17531: file: 046-1082287-0.004.  */
+				  ivd.vd_ndx  = (data[cnt + j] & VERSYM_VERSION) + 1;
+				  break;
+				}
+			      else
+				{
+				  ivd.vd_next = BYTE_GET (evd.vd_next);
+				  ivd.vd_ndx  = BYTE_GET (evd.vd_ndx);
+				}
+
+			      offset += ivd.vd_next;
+			    }
+			  while (ivd.vd_ndx != (data[cnt + j] & VERSYM_VERSION)
+				 && ivd.vd_next != 0);
+
+			  if (ivd.vd_ndx == (data[cnt + j] & VERSYM_VERSION))
+			    {
+			      Elf_External_Verdaux evda;
+			      Elf_Internal_Verdaux ivda;
+
+			      ivd.vd_aux = BYTE_GET (evd.vd_aux);
+
+			      if (get_data (&evda, filedata,
+					    offset - ivd.vd_next + ivd.vd_aux,
+					    sizeof (evda), 1,
+					    _("version def aux")) == NULL)
+				break;
+
+			      ivda.vda_name = BYTE_GET (evda.vda_name);
+
+			      if (ivda.vda_name >= string_sec->sh_size)
+				name = invalid;
+			      else if (name != NULL && name != invalid)
+				name = _("*both*");
+			      else
+				name = strtab + ivda.vda_name;
+			    }
+			}
+		      if (name != NULL)
+			nn += printf ("(%s%-*s",
+				      name,
+				      12 - (int) strlen (name),
+				      ")");
+
+		      if (nn < 18)
+			printf ("%*c", 18 - nn, ' ');
+		    }
+
+		putchar ('\n');
+	      }
+
+	    free (data);
+	    free (strtab);
+	    free (symbols);
+	  }
+	  break;
+
+	default:
+	  break;
+	}
+    }
+
+  if (! found)
+    {
+      if (filedata->is_separate)
+	printf (_("\nNo version information found in linked file '%s'.\n"),
+		filedata->file_name);
+      else
+	printf (_("\nNo version information found in this file.\n"));
+    }
+
+  return true;
+}
+
+static const char *
+get_symbol_binding (Filedata * filedata, unsigned int binding)
+{
+  static char buff[64];
+
+  switch (binding)
+    {
+    case STB_LOCAL:	return "LOCAL";
+    case STB_GLOBAL:	return "GLOBAL";
+    case STB_WEAK:	return "WEAK";
+    default:
+      if (binding >= STB_LOPROC && binding <= STB_HIPROC)
+	snprintf (buff, sizeof (buff), _("<processor specific>: %d"),
+		  binding);
+      else if (binding >= STB_LOOS && binding <= STB_HIOS)
+	{
+	  if (binding == STB_GNU_UNIQUE
+	      && filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_GNU)
+	    return "UNIQUE";
+	  snprintf (buff, sizeof (buff), _("<OS specific>: %d"), binding);
+	}
+      else
+	snprintf (buff, sizeof (buff), _("<unknown>: %d"), binding);
+      return buff;
+    }
+}
+
+static const char *
+get_symbol_type (Filedata * filedata, unsigned int type)
+{
+  static char buff[64];
+
+  switch (type)
+    {
+    case STT_NOTYPE:	return "NOTYPE";
+    case STT_OBJECT:	return "OBJECT";
+    case STT_FUNC:	return "FUNC";
+    case STT_SECTION:	return "SECTION";
+    case STT_FILE:	return "FILE";
+    case STT_COMMON:	return "COMMON";
+    case STT_TLS:	return "TLS";
+    case STT_RELC:      return "RELC";
+    case STT_SRELC:     return "SRELC";
+    default:
+      if (type >= STT_LOPROC && type <= STT_HIPROC)
+	{
+	  if (filedata->file_header.e_machine == EM_ARM && type == STT_ARM_TFUNC)
+	    return "THUMB_FUNC";
+
+	  if (filedata->file_header.e_machine == EM_SPARCV9 && type == STT_REGISTER)
+	    return "REGISTER";
+
+	  if (filedata->file_header.e_machine == EM_PARISC && type == STT_PARISC_MILLI)
+	    return "PARISC_MILLI";
+
+	  snprintf (buff, sizeof (buff), _("<processor specific>: %d"), type);
+	}
+      else if (type >= STT_LOOS && type <= STT_HIOS)
+	{
+	  if (filedata->file_header.e_machine == EM_PARISC)
+	    {
+	      if (type == STT_HP_OPAQUE)
+		return "HP_OPAQUE";
+	      if (type == STT_HP_STUB)
+		return "HP_STUB";
+	    }
+
+	  if (type == STT_GNU_IFUNC
+	      && (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_GNU
+		  || filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_FREEBSD))
+	    return "IFUNC";
+
+	  snprintf (buff, sizeof (buff), _("<OS specific>: %d"), type);
+	}
+      else
+	snprintf (buff, sizeof (buff), _("<unknown>: %d"), type);
+      return buff;
+    }
+}
+
+static const char *
+get_symbol_visibility (unsigned int visibility)
+{
+  switch (visibility)
+    {
+    case STV_DEFAULT:	return "DEFAULT";
+    case STV_INTERNAL:	return "INTERNAL";
+    case STV_HIDDEN:	return "HIDDEN";
+    case STV_PROTECTED: return "PROTECTED";
+    default:
+      error (_("Unrecognized visibility value: %u\n"), visibility);
+      return _("<unknown>");
+    }
+}
+
+static const char *
+get_alpha_symbol_other (unsigned int other)
+{
+  switch (other)
+    {
+    case STO_ALPHA_NOPV:       return "NOPV";
+    case STO_ALPHA_STD_GPLOAD: return "STD GPLOAD";
+    default:
+      error (_("Unrecognized alpha specific other value: %u\n"), other);
+      return _("<unknown>");
+    }
+}
+
+static const char *
+get_solaris_symbol_visibility (unsigned int visibility)
+{
+  switch (visibility)
+    {
+    case 4: return "EXPORTED";
+    case 5: return "SINGLETON";
+    case 6: return "ELIMINATE";
+    default: return get_symbol_visibility (visibility);
+    }
+}
+
+static const char *
+get_aarch64_symbol_other (unsigned int other)
+{
+  static char buf[32];
+
+  if (other & STO_AARCH64_VARIANT_PCS)
+    {
+      other &= ~STO_AARCH64_VARIANT_PCS;
+      if (other == 0)
+	return "VARIANT_PCS";
+      snprintf (buf, sizeof buf, "VARIANT_PCS | %x", other);
+      return buf;
+    }
+  return NULL;
+}
+
+static const char *
+get_mips_symbol_other (unsigned int other)
+{
+  switch (other)
+    {
+    case STO_OPTIONAL:      return "OPTIONAL";
+    case STO_MIPS_PLT:      return "MIPS PLT";
+    case STO_MIPS_PIC:      return "MIPS PIC";
+    case STO_MICROMIPS:     return "MICROMIPS";
+    case STO_MICROMIPS | STO_MIPS_PIC:      return "MICROMIPS, MIPS PIC";
+    case STO_MIPS16:        return "MIPS16";
+    default:	            return NULL;
+    }
+}
+
+static const char *
+get_ia64_symbol_other (Filedata * filedata, unsigned int other)
+{
+  if (is_ia64_vms (filedata))
+    {
+      static char res[32];
+
+      res[0] = 0;
+
+      /* Function types is for images and .STB files only.  */
+      switch (filedata->file_header.e_type)
+        {
+        case ET_DYN:
+        case ET_EXEC:
+          switch (VMS_ST_FUNC_TYPE (other))
+            {
+            case VMS_SFT_CODE_ADDR:
+              strcat (res, " CA");
+              break;
+            case VMS_SFT_SYMV_IDX:
+              strcat (res, " VEC");
+              break;
+            case VMS_SFT_FD:
+              strcat (res, " FD");
+              break;
+            case VMS_SFT_RESERVE:
+              strcat (res, " RSV");
+              break;
+            default:
+	      warn (_("Unrecognized IA64 VMS ST Function type: %d\n"),
+		    VMS_ST_FUNC_TYPE (other));
+	      strcat (res, " <unknown>");
+	      break;
+            }
+          break;
+        default:
+          break;
+        }
+      switch (VMS_ST_LINKAGE (other))
+        {
+        case VMS_STL_IGNORE:
+          strcat (res, " IGN");
+          break;
+        case VMS_STL_RESERVE:
+          strcat (res, " RSV");
+          break;
+        case VMS_STL_STD:
+          strcat (res, " STD");
+          break;
+        case VMS_STL_LNK:
+          strcat (res, " LNK");
+          break;
+        default:
+	  warn (_("Unrecognized IA64 VMS ST Linkage: %d\n"),
+		VMS_ST_LINKAGE (other));
+	  strcat (res, " <unknown>");
+	  break;
+        }
+
+      if (res[0] != 0)
+        return res + 1;
+      else
+        return res;
+    }
+  return NULL;
+}
+
+static const char *
+get_ppc64_symbol_other (unsigned int other)
+{
+  if ((other & ~STO_PPC64_LOCAL_MASK) != 0)
+    return NULL;
+
+  other >>= STO_PPC64_LOCAL_BIT;
+  if (other <= 6)
+    {
+      static char buf[64];
+      if (other >= 2)
+	other = ppc64_decode_local_entry (other);
+      snprintf (buf, sizeof buf, _("<localentry>: %d"), other);
+      return buf;
+    }
+  return NULL;
+}
+
+static const char *
+get_symbol_other (Filedata * filedata, unsigned int other)
+{
+  const char * result = NULL;
+  static char buff [64];
+
+  if (other == 0)
+    return "";
+
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_ALPHA:
+      result = get_alpha_symbol_other (other);
+      break;
+    case EM_AARCH64:
+      result = get_aarch64_symbol_other (other);
+      break;
+    case EM_MIPS:
+      result = get_mips_symbol_other (other);
+      break;
+    case EM_IA_64:
+      result = get_ia64_symbol_other (filedata, other);
+      break;
+    case EM_PPC64:
+      result = get_ppc64_symbol_other (other);
+      break;
+    default:
+      result = NULL;
+      break;
+    }
+
+  if (result)
+    return result;
+
+  snprintf (buff, sizeof buff, _("<other>: %x"), other);
+  return buff;
+}
+
+static const char *
+get_symbol_index_type (Filedata * filedata, unsigned int type)
+{
+  static char buff[32];
+
+  switch (type)
+    {
+    case SHN_UNDEF:	return "UND";
+    case SHN_ABS:	return "ABS";
+    case SHN_COMMON:	return "COM";
+    default:
+      if (type == SHN_IA_64_ANSI_COMMON
+	  && filedata->file_header.e_machine == EM_IA_64
+	  && filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_HPUX)
+	return "ANSI_COM";
+      else if ((filedata->file_header.e_machine == EM_X86_64
+		|| filedata->file_header.e_machine == EM_L1OM
+		|| filedata->file_header.e_machine == EM_K1OM)
+	       && type == SHN_X86_64_LCOMMON)
+	return "LARGE_COM";
+      else if ((type == SHN_MIPS_SCOMMON
+		&& filedata->file_header.e_machine == EM_MIPS)
+	       || (type == SHN_TIC6X_SCOMMON
+		   && filedata->file_header.e_machine == EM_TI_C6000))
+	return "SCOM";
+      else if (type == SHN_MIPS_SUNDEFINED
+	       && filedata->file_header.e_machine == EM_MIPS)
+	return "SUND";
+      else if (type >= SHN_LOPROC && type <= SHN_HIPROC)
+	sprintf (buff, "PRC[0x%04x]", type & 0xffff);
+      else if (type >= SHN_LOOS && type <= SHN_HIOS)
+	sprintf (buff, "OS [0x%04x]", type & 0xffff);
+      else if (type >= SHN_LORESERVE)
+	sprintf (buff, "RSV[0x%04x]", type & 0xffff);
+      else if (filedata->file_header.e_shnum != 0
+	       && type >= filedata->file_header.e_shnum)
+	sprintf (buff, _("bad section index[%3d]"), type);
+      else
+	sprintf (buff, "%3d", type);
+      break;
+    }
+
+  return buff;
+}
+
+static const char *
+get_symbol_version_string (Filedata *                   filedata,
+			   bool                         is_dynsym,
+			   const char *                 strtab,
+			   unsigned long int            strtab_size,
+			   unsigned int                 si,
+			   Elf_Internal_Sym *           psym,
+			   enum versioned_symbol_info * sym_info,
+			   unsigned short *             vna_other)
+{
+  unsigned char data[2];
+  unsigned short vers_data;
+  unsigned long offset;
+  unsigned short max_vd_ndx;
+
+  if (!is_dynsym
+      || filedata->version_info[DT_VERSIONTAGIDX (DT_VERSYM)] == 0)
+    return NULL;
+
+  offset = offset_from_vma (filedata,
+			    filedata->version_info[DT_VERSIONTAGIDX (DT_VERSYM)],
+			    sizeof data + si * sizeof (vers_data));
+
+  if (get_data (&data, filedata, offset + si * sizeof (vers_data),
+		sizeof (data), 1, _("version data")) == NULL)
+    return NULL;
+
+  vers_data = byte_get (data, 2);
+
+  if ((vers_data & VERSYM_HIDDEN) == 0 && vers_data == 0)
+    return NULL;
+
+  *sym_info = (vers_data & VERSYM_HIDDEN) != 0 ? symbol_hidden : symbol_public;
+  max_vd_ndx = 0;
+
+  /* Usually we'd only see verdef for defined symbols, and verneed for
+     undefined symbols.  However, symbols defined by the linker in
+     .dynbss for variables copied from a shared library in order to
+     avoid text relocations are defined yet have verneed.  We could
+     use a heuristic to detect the special case, for example, check
+     for verneed first on symbols defined in SHT_NOBITS sections, but
+     it is simpler and more reliable to just look for both verdef and
+     verneed.  .dynbss might not be mapped to a SHT_NOBITS section.  */
+
+  if (psym->st_shndx != SHN_UNDEF
+      && vers_data != 0x8001
+      && filedata->version_info[DT_VERSIONTAGIDX (DT_VERDEF)])
+    {
+      Elf_Internal_Verdef ivd;
+      Elf_Internal_Verdaux ivda;
+      Elf_External_Verdaux evda;
+      unsigned long off;
+
+      off = offset_from_vma (filedata,
+			     filedata->version_info[DT_VERSIONTAGIDX (DT_VERDEF)],
+			     sizeof (Elf_External_Verdef));
+
+      do
+	{
+	  Elf_External_Verdef evd;
+
+	  if (get_data (&evd, filedata, off, sizeof (evd), 1,
+			_("version def")) == NULL)
+	    {
+	      ivd.vd_ndx = 0;
+	      ivd.vd_aux = 0;
+	      ivd.vd_next = 0;
+	      ivd.vd_flags = 0;
+	    }
+	  else
+	    {
+	      ivd.vd_ndx = BYTE_GET (evd.vd_ndx);
+	      ivd.vd_aux = BYTE_GET (evd.vd_aux);
+	      ivd.vd_next = BYTE_GET (evd.vd_next);
+	      ivd.vd_flags = BYTE_GET (evd.vd_flags);
+	    }
+
+	  if ((ivd.vd_ndx & VERSYM_VERSION) > max_vd_ndx)
+	    max_vd_ndx = ivd.vd_ndx & VERSYM_VERSION;
+
+	  off += ivd.vd_next;
+	}
+      while (ivd.vd_ndx != (vers_data & VERSYM_VERSION) && ivd.vd_next != 0);
+
+      if (ivd.vd_ndx == (vers_data & VERSYM_VERSION))
+	{
+	  if (ivd.vd_ndx == 1 && ivd.vd_flags == VER_FLG_BASE)
+	    return NULL;
+
+	  off -= ivd.vd_next;
+	  off += ivd.vd_aux;
+
+	  if (get_data (&evda, filedata, off, sizeof (evda), 1,
+			_("version def aux")) != NULL)
+	    {
+	      ivda.vda_name = BYTE_GET (evda.vda_name);
+
+	      if (psym->st_name != ivda.vda_name)
+		return (ivda.vda_name < strtab_size
+			? strtab + ivda.vda_name : _("<corrupt>"));
+	    }
+	}
+    }
+
+  if (filedata->version_info[DT_VERSIONTAGIDX (DT_VERNEED)])
+    {
+      Elf_External_Verneed evn;
+      Elf_Internal_Verneed ivn;
+      Elf_Internal_Vernaux ivna;
+
+      offset = offset_from_vma (filedata,
+				filedata->version_info[DT_VERSIONTAGIDX (DT_VERNEED)],
+				sizeof evn);
+      do
+	{
+	  unsigned long vna_off;
+
+	  if (get_data (&evn, filedata, offset, sizeof (evn), 1,
+			_("version need")) == NULL)
+	    {
+	      ivna.vna_next = 0;
+	      ivna.vna_other = 0;
+	      ivna.vna_name = 0;
+	      break;
+	    }
+
+	  ivn.vn_aux  = BYTE_GET (evn.vn_aux);
+	  ivn.vn_next = BYTE_GET (evn.vn_next);
+
+	  vna_off = offset + ivn.vn_aux;
+
+	  do
+	    {
+	      Elf_External_Vernaux evna;
+
+	      if (get_data (&evna, filedata, vna_off, sizeof (evna), 1,
+			    _("version need aux (3)")) == NULL)
+		{
+		  ivna.vna_next = 0;
+		  ivna.vna_other = 0;
+		  ivna.vna_name = 0;
+		}
+	      else
+		{
+		  ivna.vna_other = BYTE_GET (evna.vna_other);
+		  ivna.vna_next  = BYTE_GET (evna.vna_next);
+		  ivna.vna_name  = BYTE_GET (evna.vna_name);
+		}
+
+	      vna_off += ivna.vna_next;
+	    }
+	  while (ivna.vna_other != vers_data && ivna.vna_next != 0);
+
+	  if (ivna.vna_other == vers_data)
+	    break;
+
+	  offset += ivn.vn_next;
+	}
+      while (ivn.vn_next != 0);
+
+      if (ivna.vna_other == vers_data)
+	{
+	  *sym_info = symbol_undefined;
+	  *vna_other = ivna.vna_other;
+	  return (ivna.vna_name < strtab_size
+		  ? strtab + ivna.vna_name : _("<corrupt>"));
+	}
+      else if ((max_vd_ndx || (vers_data & VERSYM_VERSION) != 1)
+	       && (vers_data & VERSYM_VERSION) > max_vd_ndx)
+	return _("<corrupt>");
+    }
+  return NULL;
+}
+
+/* Display a symbol size on stdout.  Format is based on --sym-base setting.  */
+
+static unsigned int
+print_dynamic_symbol_size (bfd_vma vma, int base)
+{
+  switch (base)
+    {
+    case 8:
+      return print_vma (vma, OCTAL_5);
+
+    case 10:
+      return print_vma (vma, UNSIGNED_5);
+
+    case 16:
+      return print_vma (vma, PREFIX_HEX_5);
+
+    case 0:
+    default:
+      return print_vma (vma, DEC_5);
+    }
+}
+
+static void
+print_dynamic_symbol (Filedata *filedata, unsigned long si,
+		      Elf_Internal_Sym *symtab,
+		      Elf_Internal_Shdr *section,
+		      char *strtab, size_t strtab_size)
+{
+  const char *version_string;
+  enum versioned_symbol_info sym_info;
+  unsigned short vna_other;
+  bool is_valid;
+  const char * sstr;
+  Elf_Internal_Sym *psym = symtab + si;
+
+  printf ("%6ld: ", si);
+  print_vma (psym->st_value, LONG_HEX);
+  putchar (' ');
+  print_dynamic_symbol_size (psym->st_size, sym_base);
+  printf (" %-7s", get_symbol_type (filedata, ELF_ST_TYPE (psym->st_info)));
+  printf (" %-6s", get_symbol_binding (filedata, ELF_ST_BIND (psym->st_info)));
+  if (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_SOLARIS)
+    printf (" %-7s",  get_solaris_symbol_visibility (psym->st_other));
+  else
+    {
+      unsigned int vis = ELF_ST_VISIBILITY (psym->st_other);
+
+      printf (" %-7s", get_symbol_visibility (vis));
+#if 0
+      /* Check to see if any other bits in the st_other field are set.
+	 Note - displaying this information disrupts the layout of the
+	 table being generated, but for the moment this case is very rare.  */
+      if (psym->st_other ^ vis)
+	printf (" [%s] ", get_symbol_other (filedata, psym->st_other ^ vis));
+#endif
+    }
+  printf (" %4s ", get_symbol_index_type (filedata, psym->st_shndx));
+
+  if (ELF_ST_TYPE (psym->st_info) == STT_SECTION
+      && psym->st_shndx < filedata->file_header.e_shnum
+      && psym->st_name == 0)
+    {
+      is_valid = SECTION_NAME_VALID (filedata->section_headers + psym->st_shndx);
+      sstr = is_valid ?
+	SECTION_NAME_PRINT (filedata->section_headers + psym->st_shndx)
+	: _("<corrupt>");
+    }
+  else
+    {
+      is_valid = VALID_SYMBOL_NAME (strtab, strtab_size, psym->st_name);
+      sstr = is_valid  ? strtab + psym->st_name : _("<corrupt>");
+    }
+
+  version_string
+    = get_symbol_version_string (filedata,
+				 (section == NULL
+				  || section->sh_type == SHT_DYNSYM),
+				 strtab, strtab_size, si,
+				 psym, &sym_info, &vna_other);
+
+  int len_avail = 21;
+  if (! do_wide && version_string != NULL)
+    {
+      char buffer[16];
+
+      len_avail -= 1 + strlen (version_string);
+
+      if (sym_info == symbol_undefined)
+	len_avail -= sprintf (buffer," (%d)", vna_other);
+      else if (sym_info != symbol_hidden)
+	len_avail -= 1;
+    }
+
+  print_symbol (len_avail, sstr);
+
+  if (version_string)
+    {
+      if (sym_info == symbol_undefined)
+	printf ("@%s (%d)", version_string, vna_other);
+      else
+	printf (sym_info == symbol_hidden ? "@%s" : "@@%s",
+		version_string);
+    }
+
+#if 1
+    {
+      unsigned int vis = ELF_ST_VISIBILITY (psym->st_other);
+
+      /* Check to see if any other bits in the st_other field are set.  */
+      if (psym->st_other ^ vis)
+	printf (" \t[%s]", get_symbol_other (filedata, psym->st_other ^ vis));
+    }
+#endif
+
+    putchar ('\n');
+
+  if (ELF_ST_BIND (psym->st_info) == STB_LOCAL
+      && section != NULL
+      && si >= section->sh_info
+      /* Irix 5 and 6 MIPS binaries are known to ignore this requirement.  */
+      && filedata->file_header.e_machine != EM_MIPS
+      /* Solaris binaries have been found to violate this requirement as
+	 well.  Not sure if this is a bug or an ABI requirement.  */
+      && filedata->file_header.e_ident[EI_OSABI] != ELFOSABI_SOLARIS)
+    warn (_("local symbol %lu found at index >= %s's sh_info value of %u\n"),
+	  si, printable_section_name (filedata, section), section->sh_info);
+}
+
+static const char *
+get_lto_kind (unsigned int kind)
+{
+  switch (kind)
+    {
+    case 0: return "DEF";
+    case 1: return "WEAKDEF";
+    case 2: return "UNDEF";
+    case 3: return "WEAKUNDEF";
+    case 4: return "COMMON";
+    default:
+      break;
+    }
+
+  static char buffer[30];
+  error (_("Unknown LTO symbol definition encountered: %u\n"), kind);
+  sprintf (buffer, "<unknown: %u>", kind);
+  return buffer;
+}
+
+static const char *
+get_lto_visibility (unsigned int visibility)
+{
+  switch (visibility)
+    {
+    case 0: return "DEFAULT";
+    case 1: return "PROTECTED";
+    case 2: return "INTERNAL";
+    case 3: return "HIDDEN";
+    default:
+      break;
+    }
+
+  static char buffer[30];
+  error (_("Unknown LTO symbol visibility encountered: %u\n"), visibility);
+  sprintf (buffer, "<unknown: %u>", visibility);
+  return buffer;
+}
+
+static const char *
+get_lto_sym_type (unsigned int sym_type)
+{
+  switch (sym_type)
+    {
+    case 0: return "UNKNOWN";
+    case 1: return "FUNCTION";
+    case 2: return "VARIABLE";
+    default:
+      break;
+    }
+
+  static char buffer[30];
+  error (_("Unknown LTO symbol type encountered: %u\n"), sym_type);
+  sprintf (buffer, "<unknown: %u>", sym_type);
+  return buffer;
+}
+
+/* Display an LTO format symbol table.
+   FIXME: The format of LTO symbol tables is not formalized.
+   So this code could need changing in the future.  */
+
+static bool
+display_lto_symtab (Filedata *           filedata,
+		    Elf_Internal_Shdr *  section)
+{
+  if (section->sh_size == 0)
+    {
+      if (filedata->is_separate)
+	printf (_("\nThe LTO Symbol table section '%s' in linked file '%s' is empty!\n"),
+		printable_section_name (filedata, section),
+		filedata->file_name);
+      else
+	printf (_("\nLTO Symbol table '%s' is empty!\n"),
+		printable_section_name (filedata, section));
+
+      return true;
+    }
+
+  if (section->sh_size > filedata->file_size)
+    {
+      error (_("Section %s has an invalid sh_size of 0x%lx\n"),
+	     printable_section_name (filedata, section),
+	     (unsigned long) section->sh_size);
+      return false;
+    }
+
+  void * alloced_data = get_data (NULL, filedata, section->sh_offset,
+				  section->sh_size, 1, _("LTO symbols"));
+  if (alloced_data == NULL)
+    return false;
+
+  /* Look for extended data for the symbol table.  */
+  Elf_Internal_Shdr * ext;
+  void * ext_data_orig = NULL;
+  char * ext_data = NULL;
+  char * ext_data_end = NULL;
+  char * ext_name = NULL;
+
+  if (asprintf (& ext_name, ".gnu.lto_.ext_symtab.%s",
+		SECTION_NAME (section) + sizeof (".gnu.lto_.symtab.") - 1) > 0
+      && ext_name != NULL /* Paranoia.  */
+      && (ext = find_section (filedata, ext_name)) != NULL)
+    {
+      if (ext->sh_size < 3)
+	error (_("LTO Symbol extension table '%s' is empty!\n"),
+	       printable_section_name (filedata, ext));
+      else
+	{
+	  ext_data_orig = ext_data = get_data (NULL, filedata, ext->sh_offset,
+					       ext->sh_size, 1,
+					       _("LTO ext symbol data"));
+	  if (ext_data != NULL)
+	    {
+	      ext_data_end = ext_data + ext->sh_size;
+	      if (* ext_data++ != 1)
+		error (_("Unexpected version number in symbol extension table\n"));
+	    }
+	}
+    }
+
+  const unsigned char * data = (const unsigned char *) alloced_data;
+  const unsigned char * end = data + section->sh_size;
+
+  if (filedata->is_separate)
+    printf (_("\nIn linked file '%s': "), filedata->file_name);
+  else
+    printf ("\n");
+
+  if (ext_data_orig != NULL)
+    {
+      if (do_wide)
+	printf (_("LTO Symbol table '%s' and extension table '%s' contain:\n"),
+		printable_section_name (filedata, section),
+		printable_section_name (filedata, ext));
+      else
+	{
+	  printf (_("LTO Symbol table '%s'\n"),
+		  printable_section_name (filedata, section));
+	  printf (_(" and extension table '%s' contain:\n"),
+		  printable_section_name (filedata, ext));
+	}
+    }
+  else
+    printf (_("LTO Symbol table '%s' contains:\n"),
+	    printable_section_name (filedata, section));
+
+  /* FIXME: Add a wide version.  */
+  if (ext_data_orig != NULL)
+    printf (_("  Comdat_Key       Kind  Visibility     Size      Slot      Type  Section Name\n"));
+  else
+    printf (_("  Comdat_Key       Kind  Visibility     Size      Slot Name\n"));
+
+  /* FIXME: We do not handle style prefixes.  */
+
+  while (data < end)
+    {
+      const unsigned char * sym_name = data;
+      data += strnlen ((const char *) sym_name, end - data) + 1;
+      if (data >= end)
+	goto fail;
+
+      const unsigned char * comdat_key = data;
+      data += strnlen ((const char *) comdat_key, end - data) + 1;
+      if (data >= end)
+	goto fail;
+
+      if (data + 2 + 8 + 4 > end)
+	goto fail;
+
+      unsigned int kind = *data++;
+      unsigned int visibility = *data++;
+
+      elf_vma size = byte_get (data, 8);
+      data += 8;
+
+      elf_vma slot = byte_get (data, 4);
+      data += 4;
+
+      if (ext_data != NULL)
+	{
+	  if (ext_data < (ext_data_end - 1))
+	    {
+	      unsigned int sym_type = * ext_data ++;
+	      unsigned int sec_kind = * ext_data ++;
+
+	      printf ("  %10s %10s %11s %08lx  %08lx %9s %08lx _",
+		      * comdat_key == 0 ? "-" : (char *) comdat_key,
+		      get_lto_kind (kind),
+		      get_lto_visibility (visibility),
+		      (long) size,
+		      (long) slot,
+		      get_lto_sym_type (sym_type),
+		      (long) sec_kind);
+	      print_symbol (6, (const char *) sym_name);
+	    }
+	  else
+	    {
+	      error (_("Ran out of LTO symbol extension data\n"));
+	      ext_data = NULL;
+	      /* FIXME: return FAIL result ?  */
+	    }
+	}
+      else
+	{
+	  printf ("  %10s %10s %11s %08lx  %08lx _",
+		  * comdat_key == 0 ? "-" : (char *) comdat_key,
+		  get_lto_kind (kind),
+		  get_lto_visibility (visibility),
+		  (long) size,
+		  (long) slot);
+	  print_symbol (21, (const char *) sym_name);
+	}
+      putchar ('\n');
+    }
+
+  if (ext_data != NULL && ext_data < ext_data_end)
+    {
+      error (_("Data remains in the LTO symbol extension table\n"));
+      goto fail;
+    }
+
+  free (alloced_data);
+  free (ext_data_orig);
+  free (ext_name);
+  return true;
+
+ fail:
+  error (_("Buffer overrun encountered whilst decoding LTO symbol table\n"));
+  free (alloced_data);
+  free (ext_data_orig);
+  free (ext_name);
+  return false;
+}
+
+/* Display LTO symbol tables.  */
+
+static bool
+process_lto_symbol_tables (Filedata * filedata)
+{
+  Elf_Internal_Shdr * section;
+  unsigned int i;
+  bool res = true;
+
+  if (!do_lto_syms)
+    return true;
+
+  if (filedata->section_headers == NULL)
+    return true;
+
+  for (i = 0, section = filedata->section_headers;
+       i < filedata->file_header.e_shnum;
+       i++, section++)
+    if (SECTION_NAME_VALID (section)
+	&& startswith (SECTION_NAME (section), ".gnu.lto_.symtab."))
+      res &= display_lto_symtab (filedata, section);
+
+  return res;
+}
+
+/* Dump the symbol table.  */
+
+static bool
+process_symbol_table (Filedata * filedata)
+{
+  Elf_Internal_Shdr * section;
+
+  if (!do_syms && !do_dyn_syms && !do_histogram)
+    return true;
+
+  if ((filedata->dynamic_info[DT_HASH] || filedata->dynamic_info_DT_GNU_HASH)
+      && do_syms
+      && do_using_dynamic
+      && filedata->dynamic_strings != NULL
+      && filedata->dynamic_symbols != NULL)
+    {
+      unsigned long si;
+
+      if (filedata->is_separate)
+	{
+	  printf (ngettext ("\nIn linked file '%s' the dynamic symbol table contains %lu entry:\n",
+			    "\nIn linked file '%s' the dynamic symbol table contains %lu entries:\n",
+			    filedata->num_dynamic_syms),
+		  filedata->file_name,
+		  filedata->num_dynamic_syms);
+	}
+      else
+	{
+	  printf (ngettext ("\nSymbol table for image contains %lu entry:\n",
+			    "\nSymbol table for image contains %lu entries:\n",
+			    filedata->num_dynamic_syms),
+		  filedata->num_dynamic_syms);
+	}
+      if (is_32bit_elf)
+	printf (_("   Num:    Value  Size Type    Bind   Vis      Ndx Name\n"));
+      else
+	printf (_("   Num:    Value          Size Type    Bind   Vis      Ndx Name\n"));
+
+      for (si = 0; si < filedata->num_dynamic_syms; si++)
+	print_dynamic_symbol (filedata, si, filedata->dynamic_symbols, NULL,
+			      filedata->dynamic_strings,
+			      filedata->dynamic_strings_length);
+    }
+  else if ((do_dyn_syms || (do_syms && !do_using_dynamic))
+	   && filedata->section_headers != NULL)
+    {
+      unsigned int i;
+
+      for (i = 0, section = filedata->section_headers;
+	   i < filedata->file_header.e_shnum;
+	   i++, section++)
+	{
+	  char * strtab = NULL;
+	  unsigned long int strtab_size = 0;
+	  Elf_Internal_Sym * symtab;
+	  unsigned long si, num_syms;
+
+	  if ((section->sh_type != SHT_SYMTAB
+	       && section->sh_type != SHT_DYNSYM)
+	      || (!do_syms
+		  && section->sh_type == SHT_SYMTAB))
+	    continue;
+
+	  if (section->sh_entsize == 0)
+	    {
+	      printf (_("\nSymbol table '%s' has a sh_entsize of zero!\n"),
+		      printable_section_name (filedata, section));
+	      continue;
+	    }
+
+	  num_syms = section->sh_size / section->sh_entsize;
+
+	  if (filedata->is_separate)
+	    printf (ngettext ("\nIn linked file '%s' symbol section '%s' contains %lu entry:\n",
+			      "\nIn linked file '%s' symbol section '%s' contains %lu entries:\n",
+			      num_syms),
+		    filedata->file_name,
+		    printable_section_name (filedata, section),
+		    num_syms);
+	  else
+	    printf (ngettext ("\nSymbol table '%s' contains %lu entry:\n",
+			      "\nSymbol table '%s' contains %lu entries:\n",
+			      num_syms),
+		    printable_section_name (filedata, section),
+		    num_syms);
+
+	  if (is_32bit_elf)
+	    printf (_("   Num:    Value  Size Type    Bind   Vis      Ndx Name\n"));
+	  else
+	    printf (_("   Num:    Value          Size Type    Bind   Vis      Ndx Name\n"));
+
+	  symtab = get_elf_symbols (filedata, section, & num_syms);
+	  if (symtab == NULL)
+	    continue;
+
+	  if (section->sh_link == filedata->file_header.e_shstrndx)
+	    {
+	      strtab = filedata->string_table;
+	      strtab_size = filedata->string_table_length;
+	    }
+	  else if (section->sh_link < filedata->file_header.e_shnum)
+	    {
+	      Elf_Internal_Shdr * string_sec;
+
+	      string_sec = filedata->section_headers + section->sh_link;
+
+	      strtab = (char *) get_data (NULL, filedata, string_sec->sh_offset,
+                                          1, string_sec->sh_size,
+                                          _("string table"));
+	      strtab_size = strtab != NULL ? string_sec->sh_size : 0;
+	    }
+
+	  for (si = 0; si < num_syms; si++)
+	    print_dynamic_symbol (filedata, si, symtab, section,
+				  strtab, strtab_size);
+
+	  free (symtab);
+	  if (strtab != filedata->string_table)
+	    free (strtab);
+	}
+    }
+  else if (do_syms)
+    printf
+      (_("\nDynamic symbol information is not available for displaying symbols.\n"));
+
+  if (do_histogram && filedata->buckets != NULL)
+    {
+      unsigned long * lengths;
+      unsigned long * counts;
+      unsigned long hn;
+      bfd_vma si;
+      unsigned long maxlength = 0;
+      unsigned long nzero_counts = 0;
+      unsigned long nsyms = 0;
+      char *visited;
+
+      printf (ngettext ("\nHistogram for bucket list length "
+			"(total of %lu bucket):\n",
+			"\nHistogram for bucket list length "
+			"(total of %lu buckets):\n",
+			(unsigned long) filedata->nbuckets),
+	      (unsigned long) filedata->nbuckets);
+
+      lengths = (unsigned long *) calloc (filedata->nbuckets,
+					  sizeof (*lengths));
+      if (lengths == NULL)
+	{
+	  error (_("Out of memory allocating space for histogram buckets\n"));
+	  goto err_out;
+	}
+      visited = xcmalloc (filedata->nchains, 1);
+      memset (visited, 0, filedata->nchains);
+
+      printf (_(" Length  Number     %% of total  Coverage\n"));
+      for (hn = 0; hn < filedata->nbuckets; ++hn)
+	{
+	  for (si = filedata->buckets[hn]; si > 0; si = filedata->chains[si])
+	    {
+	      ++nsyms;
+	      if (maxlength < ++lengths[hn])
+		++maxlength;
+	      if (si >= filedata->nchains || visited[si])
+		{
+		  error (_("histogram chain is corrupt\n"));
+		  break;
+		}
+	      visited[si] = 1;
+	    }
+	}
+      free (visited);
+
+      counts = (unsigned long *) calloc (maxlength + 1, sizeof (*counts));
+      if (counts == NULL)
+	{
+	  free (lengths);
+	  error (_("Out of memory allocating space for histogram counts\n"));
+	  goto err_out;
+	}
+
+      for (hn = 0; hn < filedata->nbuckets; ++hn)
+	++counts[lengths[hn]];
+
+      if (filedata->nbuckets > 0)
+	{
+	  unsigned long i;
+	  printf ("      0  %-10lu (%5.1f%%)\n",
+		  counts[0], (counts[0] * 100.0) / filedata->nbuckets);
+	  for (i = 1; i <= maxlength; ++i)
+	    {
+	      nzero_counts += counts[i] * i;
+	      printf ("%7lu  %-10lu (%5.1f%%)    %5.1f%%\n",
+		      i, counts[i], (counts[i] * 100.0) / filedata->nbuckets,
+		      (nzero_counts * 100.0) / nsyms);
+	    }
+	}
+
+      free (counts);
+      free (lengths);
+    }
+
+  free (filedata->buckets);
+  filedata->buckets = NULL;
+  filedata->nbuckets = 0;
+  free (filedata->chains);
+  filedata->chains = NULL;
+
+  if (do_histogram && filedata->gnubuckets != NULL)
+    {
+      unsigned long * lengths;
+      unsigned long * counts;
+      unsigned long hn;
+      unsigned long maxlength = 0;
+      unsigned long nzero_counts = 0;
+      unsigned long nsyms = 0;
+
+      printf (ngettext ("\nHistogram for `%s' bucket list length "
+			"(total of %lu bucket):\n",
+			"\nHistogram for `%s' bucket list length "
+			"(total of %lu buckets):\n",
+			(unsigned long) filedata->ngnubuckets),
+	      GNU_HASH_SECTION_NAME (filedata),
+	      (unsigned long) filedata->ngnubuckets);
+
+      lengths = (unsigned long *) calloc (filedata->ngnubuckets,
+					  sizeof (*lengths));
+      if (lengths == NULL)
+	{
+	  error (_("Out of memory allocating space for gnu histogram buckets\n"));
+	  goto err_out;
+	}
+
+      printf (_(" Length  Number     %% of total  Coverage\n"));
+
+      for (hn = 0; hn < filedata->ngnubuckets; ++hn)
+	if (filedata->gnubuckets[hn] != 0)
+	  {
+	    bfd_vma off, length = 1;
+
+	    for (off = filedata->gnubuckets[hn] - filedata->gnusymidx;
+		 /* PR 17531 file: 010-77222-0.004.  */
+		 off < filedata->ngnuchains
+		   && (filedata->gnuchains[off] & 1) == 0;
+		 ++off)
+	      ++length;
+	    lengths[hn] = length;
+	    if (length > maxlength)
+	      maxlength = length;
+	    nsyms += length;
+	  }
+
+      counts = (unsigned long *) calloc (maxlength + 1, sizeof (*counts));
+      if (counts == NULL)
+	{
+	  free (lengths);
+	  error (_("Out of memory allocating space for gnu histogram counts\n"));
+	  goto err_out;
+	}
+
+      for (hn = 0; hn < filedata->ngnubuckets; ++hn)
+	++counts[lengths[hn]];
+
+      if (filedata->ngnubuckets > 0)
+	{
+	  unsigned long j;
+	  printf ("      0  %-10lu (%5.1f%%)\n",
+		  counts[0], (counts[0] * 100.0) / filedata->ngnubuckets);
+	  for (j = 1; j <= maxlength; ++j)
+	    {
+	      nzero_counts += counts[j] * j;
+	      printf ("%7lu  %-10lu (%5.1f%%)    %5.1f%%\n",
+		      j, counts[j], (counts[j] * 100.0) / filedata->ngnubuckets,
+		      (nzero_counts * 100.0) / nsyms);
+	    }
+	}
+
+      free (counts);
+      free (lengths);
+    }
+  free (filedata->gnubuckets);
+  filedata->gnubuckets = NULL;
+  filedata->ngnubuckets = 0;
+  free (filedata->gnuchains);
+  filedata->gnuchains = NULL;
+  filedata->ngnuchains = 0;
+  free (filedata->mipsxlat);
+  filedata->mipsxlat = NULL;
+  return true;
+
+ err_out:
+  free (filedata->gnubuckets);
+  filedata->gnubuckets = NULL;
+  filedata->ngnubuckets = 0;
+  free (filedata->gnuchains);
+  filedata->gnuchains = NULL;
+  filedata->ngnuchains = 0;
+  free (filedata->mipsxlat);
+  filedata->mipsxlat = NULL;
+  free (filedata->buckets);
+  filedata->buckets = NULL;
+  filedata->nbuckets = 0;
+  free (filedata->chains);
+  filedata->chains = NULL;
+  return false;
+}
+
+static bool
+process_syminfo (Filedata * filedata)
+{
+  unsigned int i;
+
+  if (filedata->dynamic_syminfo == NULL
+      || !do_dynamic)
+    /* No syminfo, this is ok.  */
+    return true;
+
+  /* There better should be a dynamic symbol section.  */
+  if (filedata->dynamic_symbols == NULL || filedata->dynamic_strings == NULL)
+    return false;
+
+  if (filedata->is_separate)
+    printf (ngettext ("\nIn linked file '%s: the dynamic info segment at offset 0x%lx contains %d entry:\n",
+		      "\nIn linked file '%s: the dynamic info segment at offset 0x%lx contains %d entries:\n",
+		      filedata->dynamic_syminfo_nent),
+	    filedata->file_name,
+	    filedata->dynamic_syminfo_offset,
+	    filedata->dynamic_syminfo_nent);
+  else
+    printf (ngettext ("\nDynamic info segment at offset 0x%lx "
+		      "contains %d entry:\n",
+		      "\nDynamic info segment at offset 0x%lx "
+		      "contains %d entries:\n",
+		      filedata->dynamic_syminfo_nent),
+	    filedata->dynamic_syminfo_offset,
+	    filedata->dynamic_syminfo_nent);
+
+  printf (_(" Num: Name                           BoundTo     Flags\n"));
+  for (i = 0; i < filedata->dynamic_syminfo_nent; ++i)
+    {
+      unsigned short int flags = filedata->dynamic_syminfo[i].si_flags;
+
+      printf ("%4d: ", i);
+      if (i >= filedata->num_dynamic_syms)
+	printf (_("<corrupt index>"));
+      else if (VALID_DYNAMIC_NAME (filedata, filedata->dynamic_symbols[i].st_name))
+	print_symbol (30, GET_DYNAMIC_NAME (filedata,
+					    filedata->dynamic_symbols[i].st_name));
+      else
+	printf (_("<corrupt: %19ld>"), filedata->dynamic_symbols[i].st_name);
+      putchar (' ');
+
+      switch (filedata->dynamic_syminfo[i].si_boundto)
+	{
+	case SYMINFO_BT_SELF:
+	  fputs ("SELF       ", stdout);
+	  break;
+	case SYMINFO_BT_PARENT:
+	  fputs ("PARENT     ", stdout);
+	  break;
+	default:
+	  if (filedata->dynamic_syminfo[i].si_boundto > 0
+	      && filedata->dynamic_syminfo[i].si_boundto < filedata->dynamic_nent
+	      && VALID_DYNAMIC_NAME (filedata,
+				     filedata->dynamic_section[filedata->dynamic_syminfo[i].si_boundto].d_un.d_val))
+	    {
+	      print_symbol (10, GET_DYNAMIC_NAME (filedata,
+						  filedata->dynamic_section[filedata->dynamic_syminfo[i].si_boundto].d_un.d_val));
+	      putchar (' ' );
+	    }
+	  else
+	    printf ("%-10d ", filedata->dynamic_syminfo[i].si_boundto);
+	  break;
+	}
+
+      if (flags & SYMINFO_FLG_DIRECT)
+	printf (" DIRECT");
+      if (flags & SYMINFO_FLG_PASSTHRU)
+	printf (" PASSTHRU");
+      if (flags & SYMINFO_FLG_COPY)
+	printf (" COPY");
+      if (flags & SYMINFO_FLG_LAZYLOAD)
+	printf (" LAZYLOAD");
+
+      puts ("");
+    }
+
+  return true;
+}
+
+/* A macro which evaluates to TRUE if the region ADDR .. ADDR + NELEM
+   is contained by the region START .. END.  The types of ADDR, START
+   and END should all be the same.  Note both ADDR + NELEM and END
+   point to just beyond the end of the regions that are being tested.  */
+#define IN_RANGE(START,END,ADDR,NELEM)		\
+  (((ADDR) >= (START)) && ((ADDR) < (END)) && ((ADDR) + (NELEM) <= (END)))
+
+/* Check to see if the given reloc needs to be handled in a target specific
+   manner.  If so then process the reloc and return TRUE otherwise return
+   FALSE.
+
+   If called with reloc == NULL, then this is a signal that reloc processing
+   for the current section has finished, and any saved state should be
+   discarded.  */
+
+static bool
+target_specific_reloc_handling (Filedata *           filedata,
+				Elf_Internal_Rela *  reloc,
+				unsigned char *      start,
+				unsigned char *      end,
+				Elf_Internal_Sym *   symtab,
+				unsigned long        num_syms)
+{
+  unsigned int reloc_type = 0;
+  unsigned long sym_index = 0;
+
+  if (reloc)
+    {
+      reloc_type = get_reloc_type (filedata, reloc->r_info);
+      sym_index = get_reloc_symindex (reloc->r_info);
+    }
+
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_MSP430:
+    case EM_MSP430_OLD:
+      {
+	static Elf_Internal_Sym * saved_sym = NULL;
+
+	if (reloc == NULL)
+	  {
+	    saved_sym = NULL;
+	    return true;
+	  }
+
+	switch (reloc_type)
+	  {
+	  case 10: /* R_MSP430_SYM_DIFF */
+	  case 12: /* R_MSP430_GNU_SUB_ULEB128 */
+	    if (uses_msp430x_relocs (filedata))
+	      break;
+	    /* Fall through.  */
+	  case 21: /* R_MSP430X_SYM_DIFF */
+	  case 23: /* R_MSP430X_GNU_SUB_ULEB128 */
+	    /* PR 21139.  */
+	    if (sym_index >= num_syms)
+	      error (_("MSP430 SYM_DIFF reloc contains invalid symbol index %lu\n"),
+		     sym_index);
+	    else
+	      saved_sym = symtab + sym_index;
+	    return true;
+
+	  case 1: /* R_MSP430_32 or R_MSP430_ABS32 */
+	  case 3: /* R_MSP430_16 or R_MSP430_ABS8 */
+	    goto handle_sym_diff;
+
+	  case 5: /* R_MSP430_16_BYTE */
+	  case 9: /* R_MSP430_8 */
+	  case 11: /* R_MSP430_GNU_SET_ULEB128 */
+	    if (uses_msp430x_relocs (filedata))
+	      break;
+	    goto handle_sym_diff;
+
+	  case 2: /* R_MSP430_ABS16 */
+	  case 15: /* R_MSP430X_ABS16 */
+	  case 22: /* R_MSP430X_GNU_SET_ULEB128 */
+	    if (! uses_msp430x_relocs (filedata))
+	      break;
+	    goto handle_sym_diff;
+
+	  handle_sym_diff:
+	    if (saved_sym != NULL)
+	      {
+		bfd_vma value;
+		unsigned int reloc_size = 0;
+		int leb_ret = 0;
+		switch (reloc_type)
+		  {
+		  case 1: /* R_MSP430_32 or R_MSP430_ABS32 */
+		    reloc_size = 4;
+		    break;
+		  case 11: /* R_MSP430_GNU_SET_ULEB128 */
+		  case 22: /* R_MSP430X_GNU_SET_ULEB128 */
+		    if (reloc->r_offset < (size_t) (end - start))
+		      read_leb128 (start + reloc->r_offset, end, false,
+				   &reloc_size, &leb_ret);
+		    break;
+		  default:
+		    reloc_size = 2;
+		    break;
+		  }
+
+		if (leb_ret != 0 || reloc_size == 0 || reloc_size > 8)
+		  error (_("MSP430 ULEB128 field at 0x%lx contains invalid "
+			   "ULEB128 value\n"),
+			 (long) reloc->r_offset);
+		else if (sym_index >= num_syms)
+		  error (_("MSP430 reloc contains invalid symbol index %lu\n"),
+			 sym_index);
+		else
+		  {
+		    value = reloc->r_addend + (symtab[sym_index].st_value
+					       - saved_sym->st_value);
+
+		    if (IN_RANGE (start, end, start + reloc->r_offset, reloc_size))
+		      byte_put (start + reloc->r_offset, value, reloc_size);
+		    else
+		      /* PR 21137 */
+		      error (_("MSP430 sym diff reloc contains invalid offset: 0x%lx\n"),
+			     (long) reloc->r_offset);
+		  }
+
+		saved_sym = NULL;
+		return true;
+	      }
+	    break;
+
+	  default:
+	    if (saved_sym != NULL)
+	      error (_("Unhandled MSP430 reloc type found after SYM_DIFF reloc\n"));
+	    break;
+	  }
+	break;
+      }
+
+    case EM_MN10300:
+    case EM_CYGNUS_MN10300:
+      {
+	static Elf_Internal_Sym * saved_sym = NULL;
+
+	if (reloc == NULL)
+	  {
+	    saved_sym = NULL;
+	    return true;
+	  }
+
+	switch (reloc_type)
+	  {
+	  case 34: /* R_MN10300_ALIGN */
+	    return true;
+	  case 33: /* R_MN10300_SYM_DIFF */
+	    if (sym_index >= num_syms)
+	      error (_("MN10300_SYM_DIFF reloc contains invalid symbol index %lu\n"),
+		     sym_index);
+	    else
+	      saved_sym = symtab + sym_index;
+	    return true;
+
+	  case 1: /* R_MN10300_32 */
+	  case 2: /* R_MN10300_16 */
+	    if (saved_sym != NULL)
+	      {
+		int reloc_size = reloc_type == 1 ? 4 : 2;
+		bfd_vma value;
+
+		if (sym_index >= num_syms)
+		  error (_("MN10300 reloc contains invalid symbol index %lu\n"),
+			 sym_index);
+		else
+		  {
+		    value = reloc->r_addend + (symtab[sym_index].st_value
+					       - saved_sym->st_value);
+
+		    if (IN_RANGE (start, end, start + reloc->r_offset, reloc_size))
+		      byte_put (start + reloc->r_offset, value, reloc_size);
+		    else
+		      error (_("MN10300 sym diff reloc contains invalid offset: 0x%lx\n"),
+			     (long) reloc->r_offset);
+		  }
+
+		saved_sym = NULL;
+		return true;
+	      }
+	    break;
+	  default:
+	    if (saved_sym != NULL)
+	      error (_("Unhandled MN10300 reloc type found after SYM_DIFF reloc\n"));
+	    break;
+	  }
+	break;
+      }
+
+    case EM_RL78:
+      {
+	static bfd_vma saved_sym1 = 0;
+	static bfd_vma saved_sym2 = 0;
+	static bfd_vma value;
+
+	if (reloc == NULL)
+	  {
+	    saved_sym1 = saved_sym2 = 0;
+	    return true;
+	  }
+
+	switch (reloc_type)
+	  {
+	  case 0x80: /* R_RL78_SYM.  */
+	    saved_sym1 = saved_sym2;
+	    if (sym_index >= num_syms)
+	      error (_("RL78_SYM reloc contains invalid symbol index %lu\n"),
+		     sym_index);
+	    else
+	      {
+		saved_sym2 = symtab[sym_index].st_value;
+		saved_sym2 += reloc->r_addend;
+	      }
+	    return true;
+
+	  case 0x83: /* R_RL78_OPsub.  */
+	    value = saved_sym1 - saved_sym2;
+	    saved_sym2 = saved_sym1 = 0;
+	    return true;
+	    break;
+
+	  case 0x41: /* R_RL78_ABS32.  */
+	    if (IN_RANGE (start, end, start + reloc->r_offset, 4))
+	      byte_put (start + reloc->r_offset, value, 4);
+	    else
+	      error (_("RL78 sym diff reloc contains invalid offset: 0x%lx\n"),
+		     (long) reloc->r_offset);
+	    value = 0;
+	    return true;
+
+	  case 0x43: /* R_RL78_ABS16.  */
+	    if (IN_RANGE (start, end, start + reloc->r_offset, 2))
+	      byte_put (start + reloc->r_offset, value, 2);
+	    else
+	      error (_("RL78 sym diff reloc contains invalid offset: 0x%lx\n"),
+		     (long) reloc->r_offset);
+	    value = 0;
+	    return true;
+
+	  default:
+	    break;
+	  }
+	break;
+      }
+    }
+
+  return false;
+}
+
+/* Returns TRUE iff RELOC_TYPE is a 32-bit absolute RELA relocation used in
+   DWARF debug sections.  This is a target specific test.  Note - we do not
+   go through the whole including-target-headers-multiple-times route, (as
+   we have already done with <elf/h8.h>) because this would become very
+   messy and even then this function would have to contain target specific
+   information (the names of the relocs instead of their numeric values).
+   FIXME: This is not the correct way to solve this problem.  The proper way
+   is to have target specific reloc sizing and typing functions created by
+   the reloc-macros.h header, in the same way that it already creates the
+   reloc naming functions.  */
+
+static bool
+is_32bit_abs_reloc (Filedata * filedata, unsigned int reloc_type)
+{
+  /* Please keep this table alpha-sorted for ease of visual lookup.  */
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_386:
+    case EM_IAMCU:
+      return reloc_type == 1; /* R_386_32.  */
+    case EM_68K:
+      return reloc_type == 1; /* R_68K_32.  */
+    case EM_860:
+      return reloc_type == 1; /* R_860_32.  */
+    case EM_960:
+      return reloc_type == 2; /* R_960_32.  */
+    case EM_AARCH64:
+      return (reloc_type == 258
+	      || reloc_type == 1); /* R_AARCH64_ABS32 || R_AARCH64_P32_ABS32 */
+    case EM_BPF:
+      return reloc_type == 11; /* R_BPF_DATA_32 */
+    case EM_ADAPTEVA_EPIPHANY:
+      return reloc_type == 3;
+    case EM_ALPHA:
+      return reloc_type == 1; /* R_ALPHA_REFLONG.  */
+    case EM_ARC:
+      return reloc_type == 1; /* R_ARC_32.  */
+    case EM_ARC_COMPACT:
+    case EM_ARC_COMPACT2:
+      return reloc_type == 4; /* R_ARC_32.  */
+    case EM_ARM:
+      return reloc_type == 2; /* R_ARM_ABS32 */
+    case EM_AVR_OLD:
+    case EM_AVR:
+      return reloc_type == 1;
+    case EM_BLACKFIN:
+      return reloc_type == 0x12; /* R_byte4_data.  */
+    case EM_CRIS:
+      return reloc_type == 3; /* R_CRIS_32.  */
+    case EM_CR16:
+      return reloc_type == 3; /* R_CR16_NUM32.  */
+    case EM_CRX:
+      return reloc_type == 15; /* R_CRX_NUM32.  */
+    case EM_CSKY:
+      return reloc_type == 1; /* R_CKCORE_ADDR32.  */
+    case EM_CYGNUS_FRV:
+      return reloc_type == 1;
+    case EM_CYGNUS_D10V:
+    case EM_D10V:
+      return reloc_type == 6; /* R_D10V_32.  */
+    case EM_CYGNUS_D30V:
+    case EM_D30V:
+      return reloc_type == 12; /* R_D30V_32_NORMAL.  */
+    case EM_DLX:
+      return reloc_type == 3; /* R_DLX_RELOC_32.  */
+    case EM_CYGNUS_FR30:
+    case EM_FR30:
+      return reloc_type == 3; /* R_FR30_32.  */
+    case EM_FT32:
+      return reloc_type == 1; /* R_FT32_32.  */
+    case EM_H8S:
+    case EM_H8_300:
+    case EM_H8_300H:
+      return reloc_type == 1; /* R_H8_DIR32.  */
+    case EM_IA_64:
+      return (reloc_type == 0x64    /* R_IA64_SECREL32MSB.  */
+	      || reloc_type == 0x65 /* R_IA64_SECREL32LSB.  */
+	      || reloc_type == 0x24 /* R_IA64_DIR32MSB.  */
+	      || reloc_type == 0x25 /* R_IA64_DIR32LSB.  */);
+    case EM_IP2K_OLD:
+    case EM_IP2K:
+      return reloc_type == 2; /* R_IP2K_32.  */
+    case EM_IQ2000:
+      return reloc_type == 2; /* R_IQ2000_32.  */
+    case EM_LATTICEMICO32:
+      return reloc_type == 3; /* R_LM32_32.  */
+    case EM_M32C_OLD:
+    case EM_M32C:
+      return reloc_type == 3; /* R_M32C_32.  */
+    case EM_M32R:
+      return reloc_type == 34; /* R_M32R_32_RELA.  */
+    case EM_68HC11:
+    case EM_68HC12:
+      return reloc_type == 6; /* R_M68HC11_32.  */
+    case EM_S12Z:
+      return reloc_type == 7 || /* R_S12Z_EXT32 */
+	reloc_type == 6;        /* R_S12Z_CW32.  */
+    case EM_MCORE:
+      return reloc_type == 1; /* R_MCORE_ADDR32.  */
+    case EM_CYGNUS_MEP:
+      return reloc_type == 4; /* R_MEP_32.  */
+    case EM_METAG:
+      return reloc_type == 2; /* R_METAG_ADDR32.  */
+    case EM_MICROBLAZE:
+      return reloc_type == 1; /* R_MICROBLAZE_32.  */
+    case EM_MIPS:
+      return reloc_type == 2; /* R_MIPS_32.  */
+    case EM_MMIX:
+      return reloc_type == 4; /* R_MMIX_32.  */
+    case EM_CYGNUS_MN10200:
+    case EM_MN10200:
+      return reloc_type == 1; /* R_MN10200_32.  */
+    case EM_CYGNUS_MN10300:
+    case EM_MN10300:
+      return reloc_type == 1; /* R_MN10300_32.  */
+    case EM_MOXIE:
+      return reloc_type == 1; /* R_MOXIE_32.  */
+    case EM_MSP430_OLD:
+    case EM_MSP430:
+      return reloc_type == 1; /* R_MSP430_32 or R_MSP320_ABS32.  */
+    case EM_MT:
+      return reloc_type == 2; /* R_MT_32.  */
+    case EM_NDS32:
+      return reloc_type == 20; /* R_NDS32_RELA.  */
+    case EM_ALTERA_NIOS2:
+      return reloc_type == 12; /* R_NIOS2_BFD_RELOC_32.  */
+    case EM_NIOS32:
+      return reloc_type == 1; /* R_NIOS_32.  */
+    case EM_OR1K:
+      return reloc_type == 1; /* R_OR1K_32.  */
+    case EM_PARISC:
+      return (reloc_type == 1 /* R_PARISC_DIR32.  */
+	      || reloc_type == 2 /* R_PARISC_DIR21L.  */
+	      || reloc_type == 41); /* R_PARISC_SECREL32.  */
+    case EM_PJ:
+    case EM_PJ_OLD:
+      return reloc_type == 1; /* R_PJ_DATA_DIR32.  */
+    case EM_PPC64:
+      return reloc_type == 1; /* R_PPC64_ADDR32.  */
+    case EM_PPC:
+      return reloc_type == 1; /* R_PPC_ADDR32.  */
+    case EM_TI_PRU:
+      return reloc_type == 11; /* R_PRU_BFD_RELOC_32.  */
+    case EM_RISCV:
+      return reloc_type == 1; /* R_RISCV_32.  */
+    case EM_RL78:
+      return reloc_type == 1; /* R_RL78_DIR32.  */
+    case EM_RX:
+      return reloc_type == 1; /* R_RX_DIR32.  */
+    case EM_S370:
+      return reloc_type == 1; /* R_I370_ADDR31.  */
+    case EM_S390_OLD:
+    case EM_S390:
+      return reloc_type == 4; /* R_S390_32.  */
+    case EM_SCORE:
+      return reloc_type == 8; /* R_SCORE_ABS32.  */
+    case EM_SH:
+      return reloc_type == 1; /* R_SH_DIR32.  */
+    case EM_SPARC32PLUS:
+    case EM_SPARCV9:
+    case EM_SPARC:
+      return reloc_type == 3 /* R_SPARC_32.  */
+	|| reloc_type == 23; /* R_SPARC_UA32.  */
+    case EM_SPU:
+      return reloc_type == 6; /* R_SPU_ADDR32 */
+    case EM_TI_C6000:
+      return reloc_type == 1; /* R_C6000_ABS32.  */
+    case EM_TILEGX:
+      return reloc_type == 2; /* R_TILEGX_32.  */
+    case EM_TILEPRO:
+      return reloc_type == 1; /* R_TILEPRO_32.  */
+    case EM_CYGNUS_V850:
+    case EM_V850:
+      return reloc_type == 6; /* R_V850_ABS32.  */
+    case EM_V800:
+      return reloc_type == 0x33; /* R_V810_WORD.  */
+    case EM_VAX:
+      return reloc_type == 1; /* R_VAX_32.  */
+    case EM_VISIUM:
+      return reloc_type == 3;  /* R_VISIUM_32. */
+    case EM_WEBASSEMBLY:
+      return reloc_type == 1;  /* R_WASM32_32.  */
+    case EM_X86_64:
+    case EM_L1OM:
+    case EM_K1OM:
+      return reloc_type == 10; /* R_X86_64_32.  */
+    case EM_XC16X:
+    case EM_C166:
+      return reloc_type == 3; /* R_XC16C_ABS_32.  */
+    case EM_XGATE:
+      return reloc_type == 4; /* R_XGATE_32.  */
+    case EM_XSTORMY16:
+      return reloc_type == 1; /* R_XSTROMY16_32.  */
+    case EM_XTENSA_OLD:
+    case EM_XTENSA:
+      return reloc_type == 1; /* R_XTENSA_32.  */
+    case EM_Z80:
+      return reloc_type == 6; /* R_Z80_32.  */
+    default:
+      {
+	static unsigned int prev_warn = 0;
+
+	/* Avoid repeating the same warning multiple times.  */
+	if (prev_warn != filedata->file_header.e_machine)
+	  error (_("Missing knowledge of 32-bit reloc types used in DWARF sections of machine number %d\n"),
+		 filedata->file_header.e_machine);
+	prev_warn = filedata->file_header.e_machine;
+	return false;
+      }
+    }
+}
+
+/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
+   a 32-bit pc-relative RELA relocation used in DWARF debug sections.  */
+
+static bool
+is_32bit_pcrel_reloc (Filedata * filedata, unsigned int reloc_type)
+{
+  switch (filedata->file_header.e_machine)
+  /* Please keep this table alpha-sorted for ease of visual lookup.  */
+    {
+    case EM_386:
+    case EM_IAMCU:
+      return reloc_type == 2;  /* R_386_PC32.  */
+    case EM_68K:
+      return reloc_type == 4;  /* R_68K_PC32.  */
+    case EM_AARCH64:
+      return reloc_type == 261; /* R_AARCH64_PREL32 */
+    case EM_ADAPTEVA_EPIPHANY:
+      return reloc_type == 6;
+    case EM_ALPHA:
+      return reloc_type == 10; /* R_ALPHA_SREL32.  */
+    case EM_ARC_COMPACT:
+    case EM_ARC_COMPACT2:
+      return reloc_type == 49; /* R_ARC_32_PCREL.  */
+    case EM_ARM:
+      return reloc_type == 3;  /* R_ARM_REL32 */
+    case EM_AVR_OLD:
+    case EM_AVR:
+      return reloc_type == 36; /* R_AVR_32_PCREL.  */
+    case EM_MICROBLAZE:
+      return reloc_type == 2;  /* R_MICROBLAZE_32_PCREL.  */
+    case EM_OR1K:
+      return reloc_type == 9; /* R_OR1K_32_PCREL.  */
+    case EM_PARISC:
+      return reloc_type == 9;  /* R_PARISC_PCREL32.  */
+    case EM_PPC:
+      return reloc_type == 26; /* R_PPC_REL32.  */
+    case EM_PPC64:
+      return reloc_type == 26; /* R_PPC64_REL32.  */
+    case EM_RISCV:
+      return reloc_type == 57;	/* R_RISCV_32_PCREL.  */
+    case EM_S390_OLD:
+    case EM_S390:
+      return reloc_type == 5;  /* R_390_PC32.  */
+    case EM_SH:
+      return reloc_type == 2;  /* R_SH_REL32.  */
+    case EM_SPARC32PLUS:
+    case EM_SPARCV9:
+    case EM_SPARC:
+      return reloc_type == 6;  /* R_SPARC_DISP32.  */
+    case EM_SPU:
+      return reloc_type == 13; /* R_SPU_REL32.  */
+    case EM_TILEGX:
+      return reloc_type == 6; /* R_TILEGX_32_PCREL.  */
+    case EM_TILEPRO:
+      return reloc_type == 4; /* R_TILEPRO_32_PCREL.  */
+    case EM_VISIUM:
+      return reloc_type == 6;  /* R_VISIUM_32_PCREL */
+    case EM_X86_64:
+    case EM_L1OM:
+    case EM_K1OM:
+      return reloc_type == 2;  /* R_X86_64_PC32.  */
+    case EM_VAX:
+      return reloc_type == 4;  /* R_VAX_PCREL32.  */
+    case EM_XTENSA_OLD:
+    case EM_XTENSA:
+      return reloc_type == 14; /* R_XTENSA_32_PCREL.  */
+    default:
+      /* Do not abort or issue an error message here.  Not all targets use
+	 pc-relative 32-bit relocs in their DWARF debug information and we
+	 have already tested for target coverage in is_32bit_abs_reloc.  A
+	 more helpful warning message will be generated by apply_relocations
+	 anyway, so just return.  */
+      return false;
+    }
+}
+
+/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
+   a 64-bit absolute RELA relocation used in DWARF debug sections.  */
+
+static bool
+is_64bit_abs_reloc (Filedata * filedata, unsigned int reloc_type)
+{
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_AARCH64:
+      return reloc_type == 257;	/* R_AARCH64_ABS64.  */
+    case EM_ALPHA:
+      return reloc_type == 2; /* R_ALPHA_REFQUAD.  */
+    case EM_IA_64:
+      return (reloc_type == 0x26    /* R_IA64_DIR64MSB.  */
+	      || reloc_type == 0x27 /* R_IA64_DIR64LSB.  */);
+    case EM_PARISC:
+      return reloc_type == 80; /* R_PARISC_DIR64.  */
+    case EM_PPC64:
+      return reloc_type == 38; /* R_PPC64_ADDR64.  */
+    case EM_RISCV:
+      return reloc_type == 2; /* R_RISCV_64.  */
+    case EM_SPARC32PLUS:
+    case EM_SPARCV9:
+    case EM_SPARC:
+      return reloc_type == 32 /* R_SPARC_64.  */
+	|| reloc_type == 54; /* R_SPARC_UA64.  */
+    case EM_X86_64:
+    case EM_L1OM:
+    case EM_K1OM:
+      return reloc_type == 1; /* R_X86_64_64.  */
+    case EM_S390_OLD:
+    case EM_S390:
+      return reloc_type == 22;	/* R_S390_64.  */
+    case EM_TILEGX:
+      return reloc_type == 1; /* R_TILEGX_64.  */
+    case EM_MIPS:
+      return reloc_type == 18;	/* R_MIPS_64.  */
+    default:
+      return false;
+    }
+}
+
+/* Like is_32bit_pcrel_reloc except that it returns TRUE iff RELOC_TYPE is
+   a 64-bit pc-relative RELA relocation used in DWARF debug sections.  */
+
+static bool
+is_64bit_pcrel_reloc (Filedata * filedata, unsigned int reloc_type)
+{
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_AARCH64:
+      return reloc_type == 260;	/* R_AARCH64_PREL64.  */
+    case EM_ALPHA:
+      return reloc_type == 11; /* R_ALPHA_SREL64.  */
+    case EM_IA_64:
+      return (reloc_type == 0x4e    /* R_IA64_PCREL64MSB.  */
+	      || reloc_type == 0x4f /* R_IA64_PCREL64LSB.  */);
+    case EM_PARISC:
+      return reloc_type == 72; /* R_PARISC_PCREL64.  */
+    case EM_PPC64:
+      return reloc_type == 44; /* R_PPC64_REL64.  */
+    case EM_SPARC32PLUS:
+    case EM_SPARCV9:
+    case EM_SPARC:
+      return reloc_type == 46; /* R_SPARC_DISP64.  */
+    case EM_X86_64:
+    case EM_L1OM:
+    case EM_K1OM:
+      return reloc_type == 24; /* R_X86_64_PC64.  */
+    case EM_S390_OLD:
+    case EM_S390:
+      return reloc_type == 23;	/* R_S390_PC64.  */
+    case EM_TILEGX:
+      return reloc_type == 5;  /* R_TILEGX_64_PCREL.  */
+    default:
+      return false;
+    }
+}
+
+/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
+   a 24-bit absolute RELA relocation used in DWARF debug sections.  */
+
+static bool
+is_24bit_abs_reloc (Filedata * filedata, unsigned int reloc_type)
+{
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_CYGNUS_MN10200:
+    case EM_MN10200:
+      return reloc_type == 4; /* R_MN10200_24.  */
+    case EM_FT32:
+      return reloc_type == 5; /* R_FT32_20.  */
+    case EM_Z80:
+      return reloc_type == 5; /* R_Z80_24. */
+    default:
+      return false;
+    }
+}
+
+/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
+   a 16-bit absolute RELA relocation used in DWARF debug sections.  */
+
+static bool
+is_16bit_abs_reloc (Filedata * filedata, unsigned int reloc_type)
+{
+  /* Please keep this table alpha-sorted for ease of visual lookup.  */
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_ARC:
+    case EM_ARC_COMPACT:
+    case EM_ARC_COMPACT2:
+      return reloc_type == 2; /* R_ARC_16.  */
+    case EM_ADAPTEVA_EPIPHANY:
+      return reloc_type == 5;
+    case EM_AVR_OLD:
+    case EM_AVR:
+      return reloc_type == 4; /* R_AVR_16.  */
+    case EM_CYGNUS_D10V:
+    case EM_D10V:
+      return reloc_type == 3; /* R_D10V_16.  */
+    case EM_FT32:
+      return reloc_type == 2; /* R_FT32_16.  */
+    case EM_H8S:
+    case EM_H8_300:
+    case EM_H8_300H:
+      return reloc_type == R_H8_DIR16;
+    case EM_IP2K_OLD:
+    case EM_IP2K:
+      return reloc_type == 1; /* R_IP2K_16.  */
+    case EM_M32C_OLD:
+    case EM_M32C:
+      return reloc_type == 1; /* R_M32C_16 */
+    case EM_CYGNUS_MN10200:
+    case EM_MN10200:
+      return reloc_type == 2; /* R_MN10200_16.  */
+    case EM_CYGNUS_MN10300:
+    case EM_MN10300:
+      return reloc_type == 2; /* R_MN10300_16.  */
+    case EM_MSP430:
+      if (uses_msp430x_relocs (filedata))
+	return reloc_type == 2; /* R_MSP430_ABS16.  */
+      /* Fall through.  */
+    case EM_MSP430_OLD:
+      return reloc_type == 5; /* R_MSP430_16_BYTE.  */
+    case EM_NDS32:
+      return reloc_type == 19; /* R_NDS32_RELA.  */
+    case EM_ALTERA_NIOS2:
+      return reloc_type == 13; /* R_NIOS2_BFD_RELOC_16.  */
+    case EM_NIOS32:
+      return reloc_type == 9; /* R_NIOS_16.  */
+    case EM_OR1K:
+      return reloc_type == 2; /* R_OR1K_16.  */
+    case EM_RISCV:
+      return reloc_type == 55; /* R_RISCV_SET16.  */
+    case EM_TI_PRU:
+      return reloc_type == 8; /* R_PRU_BFD_RELOC_16.  */
+    case EM_TI_C6000:
+      return reloc_type == 2; /* R_C6000_ABS16.  */
+    case EM_VISIUM:
+      return reloc_type == 2; /* R_VISIUM_16. */
+    case EM_XC16X:
+    case EM_C166:
+      return reloc_type == 2; /* R_XC16C_ABS_16.  */
+    case EM_XGATE:
+      return reloc_type == 3; /* R_XGATE_16.  */
+    case EM_Z80:
+      return reloc_type == 4; /* R_Z80_16.  */
+    default:
+      return false;
+    }
+}
+
+/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
+   a 8-bit absolute RELA relocation used in DWARF debug sections.  */
+
+static bool
+is_8bit_abs_reloc (Filedata * filedata, unsigned int reloc_type)
+{
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_RISCV:
+      return reloc_type == 54; /* R_RISCV_SET8.  */
+    case EM_Z80:
+      return reloc_type == 1;  /* R_Z80_8.  */
+    default:
+      return false;
+    }
+}
+
+/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
+   a 6-bit absolute RELA relocation used in DWARF debug sections.  */
+
+static bool
+is_6bit_abs_reloc (Filedata * filedata, unsigned int reloc_type)
+{
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_RISCV:
+      return reloc_type == 53; /* R_RISCV_SET6.  */
+    default:
+      return false;
+    }
+}
+
+/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
+   a 32-bit inplace add RELA relocation used in DWARF debug sections.  */
+
+static bool
+is_32bit_inplace_add_reloc (Filedata * filedata, unsigned int reloc_type)
+{
+  /* Please keep this table alpha-sorted for ease of visual lookup.  */
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_RISCV:
+      return reloc_type == 35; /* R_RISCV_ADD32.  */
+    default:
+      return false;
+    }
+}
+
+/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
+   a 32-bit inplace sub RELA relocation used in DWARF debug sections.  */
+
+static bool
+is_32bit_inplace_sub_reloc (Filedata * filedata, unsigned int reloc_type)
+{
+  /* Please keep this table alpha-sorted for ease of visual lookup.  */
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_RISCV:
+      return reloc_type == 39; /* R_RISCV_SUB32.  */
+    default:
+      return false;
+    }
+}
+
+/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
+   a 64-bit inplace add RELA relocation used in DWARF debug sections.  */
+
+static bool
+is_64bit_inplace_add_reloc (Filedata * filedata, unsigned int reloc_type)
+{
+  /* Please keep this table alpha-sorted for ease of visual lookup.  */
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_RISCV:
+      return reloc_type == 36; /* R_RISCV_ADD64.  */
+    default:
+      return false;
+    }
+}
+
+/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
+   a 64-bit inplace sub RELA relocation used in DWARF debug sections.  */
+
+static bool
+is_64bit_inplace_sub_reloc (Filedata * filedata, unsigned int reloc_type)
+{
+  /* Please keep this table alpha-sorted for ease of visual lookup.  */
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_RISCV:
+      return reloc_type == 40; /* R_RISCV_SUB64.  */
+    default:
+      return false;
+    }
+}
+
+/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
+   a 16-bit inplace add RELA relocation used in DWARF debug sections.  */
+
+static bool
+is_16bit_inplace_add_reloc (Filedata * filedata, unsigned int reloc_type)
+{
+  /* Please keep this table alpha-sorted for ease of visual lookup.  */
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_RISCV:
+      return reloc_type == 34; /* R_RISCV_ADD16.  */
+    default:
+      return false;
+    }
+}
+
+/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
+   a 16-bit inplace sub RELA relocation used in DWARF debug sections.  */
+
+static bool
+is_16bit_inplace_sub_reloc (Filedata * filedata, unsigned int reloc_type)
+{
+  /* Please keep this table alpha-sorted for ease of visual lookup.  */
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_RISCV:
+      return reloc_type == 38; /* R_RISCV_SUB16.  */
+    default:
+      return false;
+    }
+}
+
+/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
+   a 8-bit inplace add RELA relocation used in DWARF debug sections.  */
+
+static bool
+is_8bit_inplace_add_reloc (Filedata * filedata, unsigned int reloc_type)
+{
+  /* Please keep this table alpha-sorted for ease of visual lookup.  */
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_RISCV:
+      return reloc_type == 33; /* R_RISCV_ADD8.  */
+    default:
+      return false;
+    }
+}
+
+/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
+   a 8-bit inplace sub RELA relocation used in DWARF debug sections.  */
+
+static bool
+is_8bit_inplace_sub_reloc (Filedata * filedata, unsigned int reloc_type)
+{
+  /* Please keep this table alpha-sorted for ease of visual lookup.  */
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_RISCV:
+      return reloc_type == 37; /* R_RISCV_SUB8.  */
+    default:
+      return false;
+    }
+}
+
+/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
+   a 6-bit inplace sub RELA relocation used in DWARF debug sections.  */
+
+static bool
+is_6bit_inplace_sub_reloc (Filedata * filedata, unsigned int reloc_type)
+{
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_RISCV:
+      return reloc_type == 52; /* R_RISCV_SUB6.  */
+    default:
+      return false;
+    }
+}
+
+/* Returns TRUE iff RELOC_TYPE is a NONE relocation used for discarded
+   relocation entries (possibly formerly used for SHT_GROUP sections).  */
+
+static bool
+is_none_reloc (Filedata * filedata, unsigned int reloc_type)
+{
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_386:     /* R_386_NONE.  */
+    case EM_68K:     /* R_68K_NONE.  */
+    case EM_ADAPTEVA_EPIPHANY:
+    case EM_ALPHA:   /* R_ALPHA_NONE.  */
+    case EM_ALTERA_NIOS2: /* R_NIOS2_NONE.  */
+    case EM_ARC:     /* R_ARC_NONE.  */
+    case EM_ARC_COMPACT2: /* R_ARC_NONE.  */
+    case EM_ARC_COMPACT: /* R_ARC_NONE.  */
+    case EM_ARM:     /* R_ARM_NONE.  */
+    case EM_C166:    /* R_XC16X_NONE.  */
+    case EM_CRIS:    /* R_CRIS_NONE.  */
+    case EM_FT32:    /* R_FT32_NONE.  */
+    case EM_IA_64:   /* R_IA64_NONE.  */
+    case EM_K1OM:    /* R_X86_64_NONE.  */
+    case EM_L1OM:    /* R_X86_64_NONE.  */
+    case EM_M32R:    /* R_M32R_NONE.  */
+    case EM_MIPS:    /* R_MIPS_NONE.  */
+    case EM_MN10300: /* R_MN10300_NONE.  */
+    case EM_MOXIE:   /* R_MOXIE_NONE.  */
+    case EM_NIOS32:  /* R_NIOS_NONE.  */
+    case EM_OR1K:    /* R_OR1K_NONE. */
+    case EM_PARISC:  /* R_PARISC_NONE.  */
+    case EM_PPC64:   /* R_PPC64_NONE.  */
+    case EM_PPC:     /* R_PPC_NONE.  */
+    case EM_RISCV:   /* R_RISCV_NONE.  */
+    case EM_S390:    /* R_390_NONE.  */
+    case EM_S390_OLD:
+    case EM_SH:      /* R_SH_NONE.  */
+    case EM_SPARC32PLUS:
+    case EM_SPARC:   /* R_SPARC_NONE.  */
+    case EM_SPARCV9:
+    case EM_TILEGX:  /* R_TILEGX_NONE.  */
+    case EM_TILEPRO: /* R_TILEPRO_NONE.  */
+    case EM_TI_C6000:/* R_C6000_NONE.  */
+    case EM_X86_64:  /* R_X86_64_NONE.  */
+    case EM_XC16X:
+    case EM_Z80:     /* R_Z80_NONE. */
+    case EM_WEBASSEMBLY: /* R_WASM32_NONE.  */
+      return reloc_type == 0;
+
+    case EM_AARCH64:
+      return reloc_type == 0 || reloc_type == 256;
+    case EM_AVR_OLD:
+    case EM_AVR:
+      return (reloc_type == 0 /* R_AVR_NONE.  */
+	      || reloc_type == 30 /* R_AVR_DIFF8.  */
+	      || reloc_type == 31 /* R_AVR_DIFF16.  */
+	      || reloc_type == 32 /* R_AVR_DIFF32.  */);
+    case EM_METAG:
+      return reloc_type == 3; /* R_METAG_NONE.  */
+    case EM_NDS32:
+      return (reloc_type == 0       /* R_XTENSA_NONE.  */
+	      || reloc_type == 204  /* R_NDS32_DIFF8.  */
+	      || reloc_type == 205  /* R_NDS32_DIFF16.  */
+	      || reloc_type == 206  /* R_NDS32_DIFF32.  */
+	      || reloc_type == 207  /* R_NDS32_ULEB128.  */);
+    case EM_TI_PRU:
+      return (reloc_type == 0       /* R_PRU_NONE.  */
+	      || reloc_type == 65   /* R_PRU_DIFF8.  */
+	      || reloc_type == 66   /* R_PRU_DIFF16.  */
+	      || reloc_type == 67   /* R_PRU_DIFF32.  */);
+    case EM_XTENSA_OLD:
+    case EM_XTENSA:
+      return (reloc_type == 0      /* R_XTENSA_NONE.  */
+	      || reloc_type == 17  /* R_XTENSA_DIFF8.  */
+	      || reloc_type == 18  /* R_XTENSA_DIFF16.  */
+	      || reloc_type == 19  /* R_XTENSA_DIFF32.  */
+	      || reloc_type == 57  /* R_XTENSA_PDIFF8.  */
+	      || reloc_type == 58  /* R_XTENSA_PDIFF16.  */
+	      || reloc_type == 59  /* R_XTENSA_PDIFF32.  */
+	      || reloc_type == 60  /* R_XTENSA_NDIFF8.  */
+	      || reloc_type == 61  /* R_XTENSA_NDIFF16.  */
+	      || reloc_type == 62  /* R_XTENSA_NDIFF32.  */);
+    }
+  return false;
+}
+
+/* Returns TRUE if there is a relocation against
+   section NAME at OFFSET bytes.  */
+
+bool
+reloc_at (struct dwarf_section * dsec, dwarf_vma offset)
+{
+  Elf_Internal_Rela * relocs;
+  Elf_Internal_Rela * rp;
+
+  if (dsec == NULL || dsec->reloc_info == NULL)
+    return false;
+
+  relocs = (Elf_Internal_Rela *) dsec->reloc_info;
+
+  for (rp = relocs; rp < relocs + dsec->num_relocs; ++rp)
+    if (rp->r_offset == offset)
+      return true;
+
+   return false;
+}
+
+/* Apply relocations to a section.
+   Returns TRUE upon success, FALSE otherwise.
+   If RELOCS_RETURN is non-NULL then it is set to point to the loaded relocs.
+   It is then the caller's responsibility to free them.  NUM_RELOCS_RETURN
+   will be set to the number of relocs loaded.
+
+   Note: So far support has been added only for those relocations
+   which can be found in debug sections. FIXME: Add support for
+   more relocations ?  */
+
+static bool
+apply_relocations (Filedata *                 filedata,
+		   const Elf_Internal_Shdr *  section,
+		   unsigned char *            start,
+		   bfd_size_type              size,
+		   void **                    relocs_return,
+		   unsigned long *            num_relocs_return)
+{
+  Elf_Internal_Shdr * relsec;
+  unsigned char * end = start + size;
+
+  if (relocs_return != NULL)
+    {
+      * (Elf_Internal_Rela **) relocs_return = NULL;
+      * num_relocs_return = 0;
+    }
+
+  if (filedata->file_header.e_type != ET_REL)
+    /* No relocs to apply.  */
+    return true;
+
+  /* Find the reloc section associated with the section.  */
+  for (relsec = filedata->section_headers;
+       relsec < filedata->section_headers + filedata->file_header.e_shnum;
+       ++relsec)
+    {
+      bool is_rela;
+      unsigned long num_relocs;
+      Elf_Internal_Rela * relocs;
+      Elf_Internal_Rela * rp;
+      Elf_Internal_Shdr * symsec;
+      Elf_Internal_Sym * symtab;
+      unsigned long num_syms;
+      Elf_Internal_Sym * sym;
+
+      if ((relsec->sh_type != SHT_RELA && relsec->sh_type != SHT_REL)
+	  || relsec->sh_info >= filedata->file_header.e_shnum
+	  || filedata->section_headers + relsec->sh_info != section
+	  || relsec->sh_size == 0
+	  || relsec->sh_link >= filedata->file_header.e_shnum)
+	continue;
+
+      symsec = filedata->section_headers + relsec->sh_link;
+      if (symsec->sh_type != SHT_SYMTAB
+	  && symsec->sh_type != SHT_DYNSYM)
+	return false;
+
+      is_rela = relsec->sh_type == SHT_RELA;
+
+      if (is_rela)
+	{
+	  if (!slurp_rela_relocs (filedata, relsec->sh_offset,
+                                  relsec->sh_size, & relocs, & num_relocs))
+	    return false;
+	}
+      else
+	{
+	  if (!slurp_rel_relocs (filedata, relsec->sh_offset,
+                                 relsec->sh_size, & relocs, & num_relocs))
+	    return false;
+	}
+
+      /* SH uses RELA but uses in place value instead of the addend field.  */
+      if (filedata->file_header.e_machine == EM_SH)
+	is_rela = false;
+
+      symtab = get_elf_symbols (filedata, symsec, & num_syms);
+
+      for (rp = relocs; rp < relocs + num_relocs; ++rp)
+	{
+	  bfd_vma addend;
+	  unsigned int reloc_type;
+	  unsigned int reloc_size;
+	  bool reloc_inplace = false;
+	  bool reloc_subtract = false;
+	  unsigned char *rloc;
+	  unsigned long sym_index;
+
+	  reloc_type = get_reloc_type (filedata, rp->r_info);
+
+	  if (target_specific_reloc_handling (filedata, rp, start, end, symtab, num_syms))
+	    continue;
+	  else if (is_none_reloc (filedata, reloc_type))
+	    continue;
+	  else if (is_32bit_abs_reloc (filedata, reloc_type)
+		   || is_32bit_pcrel_reloc (filedata, reloc_type))
+	    reloc_size = 4;
+	  else if (is_64bit_abs_reloc (filedata, reloc_type)
+		   || is_64bit_pcrel_reloc (filedata, reloc_type))
+	    reloc_size = 8;
+	  else if (is_24bit_abs_reloc (filedata, reloc_type))
+	    reloc_size = 3;
+	  else if (is_16bit_abs_reloc (filedata, reloc_type))
+	    reloc_size = 2;
+	  else if (is_8bit_abs_reloc (filedata, reloc_type)
+		   || is_6bit_abs_reloc (filedata, reloc_type))
+	    reloc_size = 1;
+	  else if ((reloc_subtract = is_32bit_inplace_sub_reloc (filedata,
+								 reloc_type))
+		   || is_32bit_inplace_add_reloc (filedata, reloc_type))
+	    {
+	      reloc_size = 4;
+	      reloc_inplace = true;
+	    }
+	  else if ((reloc_subtract = is_64bit_inplace_sub_reloc (filedata,
+								 reloc_type))
+		   || is_64bit_inplace_add_reloc (filedata, reloc_type))
+	    {
+	      reloc_size = 8;
+	      reloc_inplace = true;
+	    }
+	  else if ((reloc_subtract = is_16bit_inplace_sub_reloc (filedata,
+								 reloc_type))
+		   || is_16bit_inplace_add_reloc (filedata, reloc_type))
+	    {
+	      reloc_size = 2;
+	      reloc_inplace = true;
+	    }
+	  else if ((reloc_subtract = is_8bit_inplace_sub_reloc (filedata,
+								reloc_type))
+		   || is_8bit_inplace_add_reloc (filedata, reloc_type))
+	    {
+	      reloc_size = 1;
+	      reloc_inplace = true;
+	    }
+	  else if ((reloc_subtract = is_6bit_inplace_sub_reloc (filedata,
+								reloc_type)))
+	    {
+	      reloc_size = 1;
+	      reloc_inplace = true;
+	    }
+	  else
+	    {
+	      static unsigned int prev_reloc = 0;
+
+	      if (reloc_type != prev_reloc)
+		warn (_("unable to apply unsupported reloc type %d to section %s\n"),
+		      reloc_type, printable_section_name (filedata, section));
+	      prev_reloc = reloc_type;
+	      continue;
+	    }
+
+	  rloc = start + rp->r_offset;
+	  if (!IN_RANGE (start, end, rloc, reloc_size))
+	    {
+	      warn (_("skipping invalid relocation offset 0x%lx in section %s\n"),
+		    (unsigned long) rp->r_offset,
+		    printable_section_name (filedata, section));
+	      continue;
+	    }
+
+	  sym_index = (unsigned long) get_reloc_symindex (rp->r_info);
+	  if (sym_index >= num_syms)
+	    {
+	      warn (_("skipping invalid relocation symbol index 0x%lx in section %s\n"),
+		    sym_index, printable_section_name (filedata, section));
+	      continue;
+	    }
+	  sym = symtab + sym_index;
+
+	  /* If the reloc has a symbol associated with it,
+	     make sure that it is of an appropriate type.
+
+	     Relocations against symbols without type can happen.
+	     Gcc -feliminate-dwarf2-dups may generate symbols
+	     without type for debug info.
+
+	     Icc generates relocations against function symbols
+	     instead of local labels.
+
+	     Relocations against object symbols can happen, eg when
+	     referencing a global array.  For an example of this see
+	     the _clz.o binary in libgcc.a.  */
+	  if (sym != symtab
+	      && ELF_ST_TYPE (sym->st_info) != STT_COMMON
+	      && ELF_ST_TYPE (sym->st_info) > STT_SECTION)
+	    {
+	      warn (_("skipping unexpected symbol type %s in section %s relocation %ld\n"),
+		    get_symbol_type (filedata, ELF_ST_TYPE (sym->st_info)),
+		    printable_section_name (filedata, relsec),
+		    (long int)(rp - relocs));
+	      continue;
+	    }
+
+	  addend = 0;
+	  if (is_rela)
+	    addend += rp->r_addend;
+	  /* R_XTENSA_32, R_PJ_DATA_DIR32 and R_D30V_32_NORMAL are
+	     partial_inplace.  */
+	  if (!is_rela
+	      || (filedata->file_header.e_machine == EM_XTENSA
+		  && reloc_type == 1)
+	      || ((filedata->file_header.e_machine == EM_PJ
+		   || filedata->file_header.e_machine == EM_PJ_OLD)
+		  && reloc_type == 1)
+	      || ((filedata->file_header.e_machine == EM_D30V
+		   || filedata->file_header.e_machine == EM_CYGNUS_D30V)
+		  && reloc_type == 12)
+	      || reloc_inplace)
+	    {
+	      if (is_6bit_inplace_sub_reloc (filedata, reloc_type))
+		addend += byte_get (rloc, reloc_size) & 0x3f;
+	      else
+		addend += byte_get (rloc, reloc_size);
+	    }
+
+	  if (is_32bit_pcrel_reloc (filedata, reloc_type)
+	      || is_64bit_pcrel_reloc (filedata, reloc_type))
+	    {
+	      /* On HPPA, all pc-relative relocations are biased by 8.  */
+	      if (filedata->file_header.e_machine == EM_PARISC)
+		addend -= 8;
+	      byte_put (rloc, (addend + sym->st_value) - rp->r_offset,
+		        reloc_size);
+	    }
+	  else if (is_6bit_abs_reloc (filedata, reloc_type)
+		   || is_6bit_inplace_sub_reloc (filedata, reloc_type))
+	    {
+	      if (reloc_subtract)
+		addend -= sym->st_value;
+	      else
+		addend += sym->st_value;
+	      addend = (addend & 0x3f) | (byte_get (rloc, reloc_size) & 0xc0);
+	      byte_put (rloc, addend, reloc_size);
+	    }
+	  else if (reloc_subtract)
+	    byte_put (rloc, addend - sym->st_value, reloc_size);
+	  else
+	    byte_put (rloc, addend + sym->st_value, reloc_size);
+	}
+
+      free (symtab);
+      /* Let the target specific reloc processing code know that
+	 we have finished with these relocs.  */
+      target_specific_reloc_handling (filedata, NULL, NULL, NULL, NULL, 0);
+
+      if (relocs_return)
+	{
+	  * (Elf_Internal_Rela **) relocs_return = relocs;
+	  * num_relocs_return = num_relocs;
+	}
+      else
+	free (relocs);
+
+      break;
+    }
+
+  return true;
+}
+
+#ifdef SUPPORT_DISASSEMBLY
+static bool
+disassemble_section (Elf_Internal_Shdr * section, Filedata * filedata)
+{
+  printf (_("\nAssembly dump of section %s\n"), printable_section_name (filedata, section));
+
+  /* FIXME: XXX -- to be done --- XXX */
+
+  return true;
+}
+#endif
+
+/* Reads in the contents of SECTION from FILE, returning a pointer
+   to a malloc'ed buffer or NULL if something went wrong.  */
+
+static char *
+get_section_contents (Elf_Internal_Shdr * section, Filedata * filedata)
+{
+  bfd_size_type num_bytes = section->sh_size;
+
+  if (num_bytes == 0 || section->sh_type == SHT_NOBITS)
+    {
+      printf (_("Section '%s' has no data to dump.\n"),
+	      printable_section_name (filedata, section));
+      return NULL;
+    }
+
+  return  (char *) get_data (NULL, filedata, section->sh_offset, 1, num_bytes,
+                             _("section contents"));
+}
+
+/* Uncompresses a section that was compressed using zlib, in place.  */
+
+static bool
+uncompress_section_contents (unsigned char **   buffer,
+			     dwarf_size_type    uncompressed_size,
+			     dwarf_size_type *  size)
+{
+  dwarf_size_type compressed_size = *size;
+  unsigned char * compressed_buffer = *buffer;
+  unsigned char * uncompressed_buffer;
+  z_stream strm;
+  int rc;
+
+  /* It is possible the section consists of several compressed
+     buffers concatenated together, so we uncompress in a loop.  */
+  /* PR 18313: The state field in the z_stream structure is supposed
+     to be invisible to the user (ie us), but some compilers will
+     still complain about it being used without initialisation.  So
+     we first zero the entire z_stream structure and then set the fields
+     that we need.  */
+  memset (& strm, 0, sizeof strm);
+  strm.avail_in = compressed_size;
+  strm.next_in = (Bytef *) compressed_buffer;
+  strm.avail_out = uncompressed_size;
+  uncompressed_buffer = (unsigned char *) xmalloc (uncompressed_size);
+
+  rc = inflateInit (& strm);
+  while (strm.avail_in > 0)
+    {
+      if (rc != Z_OK)
+        break;
+      strm.next_out = ((Bytef *) uncompressed_buffer
+                       + (uncompressed_size - strm.avail_out));
+      rc = inflate (&strm, Z_FINISH);
+      if (rc != Z_STREAM_END)
+        break;
+      rc = inflateReset (& strm);
+    }
+  if (inflateEnd (& strm) != Z_OK
+      || rc != Z_OK
+      || strm.avail_out != 0)
+    goto fail;
+
+  *buffer = uncompressed_buffer;
+  *size = uncompressed_size;
+  return true;
+
+ fail:
+  free (uncompressed_buffer);
+  /* Indicate decompression failure.  */
+  *buffer = NULL;
+  return false;
+}
+
+static bool
+dump_section_as_strings (Elf_Internal_Shdr * section, Filedata * filedata)
+{
+  Elf_Internal_Shdr *relsec;
+  bfd_size_type num_bytes;
+  unsigned char *data;
+  unsigned char *end;
+  unsigned char *real_start;
+  unsigned char *start;
+  bool some_strings_shown;
+
+  real_start = start = (unsigned char *) get_section_contents (section, filedata);
+  if (start == NULL)
+    /* PR 21820: Do not fail if the section was empty.  */
+    return section->sh_size == 0 || section->sh_type == SHT_NOBITS;
+
+  num_bytes = section->sh_size;
+
+  if (filedata->is_separate)
+    printf (_("\nString dump of section '%s' in linked file %s:\n"),
+	    printable_section_name (filedata, section),
+	    filedata->file_name);
+  else
+    printf (_("\nString dump of section '%s':\n"),
+	    printable_section_name (filedata, section));
+
+  if (decompress_dumps)
+    {
+      dwarf_size_type new_size = num_bytes;
+      dwarf_size_type uncompressed_size = 0;
+
+      if ((section->sh_flags & SHF_COMPRESSED) != 0)
+	{
+	  Elf_Internal_Chdr chdr;
+	  unsigned int compression_header_size
+	    = get_compression_header (& chdr, (unsigned char *) start,
+				      num_bytes);
+	  if (compression_header_size == 0)
+	    /* An error message will have already been generated
+	       by get_compression_header.  */
+	    goto error_out;
+
+	  if (chdr.ch_type != ELFCOMPRESS_ZLIB)
+	    {
+	      warn (_("section '%s' has unsupported compress type: %d\n"),
+		    printable_section_name (filedata, section), chdr.ch_type);
+	      goto error_out;
+	    }
+	  uncompressed_size = chdr.ch_size;
+	  start += compression_header_size;
+	  new_size -= compression_header_size;
+	}
+      else if (new_size > 12 && streq ((char *) start, "ZLIB"))
+	{
+	  /* Read the zlib header.  In this case, it should be "ZLIB"
+	     followed by the uncompressed section size, 8 bytes in
+	     big-endian order.  */
+	  uncompressed_size = start[4]; uncompressed_size <<= 8;
+	  uncompressed_size += start[5]; uncompressed_size <<= 8;
+	  uncompressed_size += start[6]; uncompressed_size <<= 8;
+	  uncompressed_size += start[7]; uncompressed_size <<= 8;
+	  uncompressed_size += start[8]; uncompressed_size <<= 8;
+	  uncompressed_size += start[9]; uncompressed_size <<= 8;
+	  uncompressed_size += start[10]; uncompressed_size <<= 8;
+	  uncompressed_size += start[11];
+	  start += 12;
+	  new_size -= 12;
+	}
+
+      if (uncompressed_size)
+	{
+	  if (uncompress_section_contents (& start,
+					   uncompressed_size, & new_size))
+	    num_bytes = new_size;
+	  else
+	    {
+	      error (_("Unable to decompress section %s\n"),
+		     printable_section_name (filedata, section));
+	      goto error_out;
+	    }
+	}
+      else
+	start = real_start;
+    }
+
+  /* If the section being dumped has relocations against it the user might
+     be expecting these relocations to have been applied.  Check for this
+     case and issue a warning message in order to avoid confusion.
+     FIXME: Maybe we ought to have an option that dumps a section with
+     relocs applied ?  */
+  for (relsec = filedata->section_headers;
+       relsec < filedata->section_headers + filedata->file_header.e_shnum;
+       ++relsec)
+    {
+      if ((relsec->sh_type != SHT_RELA && relsec->sh_type != SHT_REL)
+	  || relsec->sh_info >= filedata->file_header.e_shnum
+	  || filedata->section_headers + relsec->sh_info != section
+	  || relsec->sh_size == 0
+	  || relsec->sh_link >= filedata->file_header.e_shnum)
+	continue;
+
+      printf (_("  Note: This section has relocations against it, but these have NOT been applied to this dump.\n"));
+      break;
+    }
+
+  data = start;
+  end  = start + num_bytes;
+  some_strings_shown = false;
+
+#ifdef HAVE_MBSTATE_T
+  mbstate_t state;
+  /* Initialise the multibyte conversion state.  */
+  memset (& state, 0, sizeof (state));
+#endif
+
+  bool continuing = false;
+
+  while (data < end)
+    {
+      while (!ISPRINT (* data))
+	if (++ data >= end)
+	  break;
+
+      if (data < end)
+	{
+	  size_t maxlen = end - data;
+
+	  if (continuing)
+	    {
+	      printf ("            ");
+	      continuing = false;
+	    }
+	  else
+	    {
+	      printf ("  [%6lx]  ", (unsigned long) (data - start));
+	    }
+
+	  if (maxlen > 0)
+	    {
+	      char c = 0;
+
+	      while (maxlen)
+		{
+		  c = *data++;
+
+		  if (c == 0)
+		    break;
+
+		  /* PR 25543: Treat new-lines as string-ending characters.  */
+		  if (c == '\n')
+		    {
+		      printf ("\\n\n");
+		      if (*data != 0)
+			continuing = true;
+		      break;
+		    }
+
+		  /* Do not print control characters directly as they can affect terminal
+		     settings.  Such characters usually appear in the names generated
+		     by the assembler for local labels.  */
+		  if (ISCNTRL (c))
+		    {
+		      printf ("^%c", c + 0x40);
+		    }
+		  else if (ISPRINT (c))
+		    {
+		      putchar (c);
+		    }
+		  else
+		    {
+		      size_t  n;
+#ifdef HAVE_MBSTATE_T
+		      wchar_t w;
+#endif
+		      /* Let printf do the hard work of displaying multibyte characters.  */
+		      printf ("%.1s", data - 1);
+#ifdef HAVE_MBSTATE_T
+		      /* Try to find out how many bytes made up the character that was
+			 just printed.  Advance the symbol pointer past the bytes that
+			 were displayed.  */
+		      n = mbrtowc (& w, (char *)(data - 1), MB_CUR_MAX, & state);
+#else
+		      n = 1;
+#endif
+		      if (n != (size_t) -1 && n != (size_t) -2 && n > 0)
+			data += (n - 1);
+		    }
+		}
+
+	      if (c != '\n')
+		putchar ('\n');
+	    }
+	  else
+	    {
+	      printf (_("<corrupt>\n"));
+	      data = end;
+	    }
+	  some_strings_shown = true;
+	}
+    }
+
+  if (! some_strings_shown)
+    printf (_("  No strings found in this section."));
+
+  free (real_start);
+
+  putchar ('\n');
+  return true;
+
+error_out:
+  free (real_start);
+  return false;
+}
+
+static bool
+dump_section_as_bytes (Elf_Internal_Shdr *section,
+		       Filedata *filedata,
+		       bool relocate)
+{
+  Elf_Internal_Shdr * relsec;
+  bfd_size_type       bytes;
+  bfd_size_type       section_size;
+  bfd_vma             addr;
+  unsigned char *     data;
+  unsigned char *     real_start;
+  unsigned char *     start;
+
+  real_start = start = (unsigned char *) get_section_contents (section, filedata);
+  if (start == NULL)
+    /* PR 21820: Do not fail if the section was empty.  */
+    return section->sh_size == 0 || section->sh_type == SHT_NOBITS;
+
+  section_size = section->sh_size;
+
+  if (filedata->is_separate)
+    printf (_("\nHex dump of section '%s' in linked file %s:\n"),
+	    printable_section_name (filedata, section),
+	    filedata->file_name);
+  else
+    printf (_("\nHex dump of section '%s':\n"),
+	    printable_section_name (filedata, section));
+
+  if (decompress_dumps)
+    {
+      dwarf_size_type new_size = section_size;
+      dwarf_size_type uncompressed_size = 0;
+
+      if ((section->sh_flags & SHF_COMPRESSED) != 0)
+	{
+	  Elf_Internal_Chdr chdr;
+	  unsigned int compression_header_size
+	    = get_compression_header (& chdr, start, section_size);
+
+	  if (compression_header_size == 0)
+	    /* An error message will have already been generated
+	       by get_compression_header.  */
+	    goto error_out;
+
+	  if (chdr.ch_type != ELFCOMPRESS_ZLIB)
+	    {
+	      warn (_("section '%s' has unsupported compress type: %d\n"),
+		    printable_section_name (filedata, section), chdr.ch_type);
+	      goto error_out;
+	    }
+	  uncompressed_size = chdr.ch_size;
+	  start += compression_header_size;
+	  new_size -= compression_header_size;
+	}
+      else if (new_size > 12 && streq ((char *) start, "ZLIB"))
+	{
+	  /* Read the zlib header.  In this case, it should be "ZLIB"
+	     followed by the uncompressed section size, 8 bytes in
+	     big-endian order.  */
+	  uncompressed_size = start[4]; uncompressed_size <<= 8;
+	  uncompressed_size += start[5]; uncompressed_size <<= 8;
+	  uncompressed_size += start[6]; uncompressed_size <<= 8;
+	  uncompressed_size += start[7]; uncompressed_size <<= 8;
+	  uncompressed_size += start[8]; uncompressed_size <<= 8;
+	  uncompressed_size += start[9]; uncompressed_size <<= 8;
+	  uncompressed_size += start[10]; uncompressed_size <<= 8;
+	  uncompressed_size += start[11];
+	  start += 12;
+	  new_size -= 12;
+	}
+
+      if (uncompressed_size)
+	{
+	  if (uncompress_section_contents (& start, uncompressed_size,
+					   & new_size))
+	    {
+	      section_size = new_size;
+	    }
+	  else
+	    {
+	      error (_("Unable to decompress section %s\n"),
+		     printable_section_name (filedata, section));
+	      /* FIXME: Print the section anyway ?  */
+	      goto error_out;
+	    }
+	}
+      else
+	start = real_start;
+    }
+
+  if (relocate)
+    {
+      if (! apply_relocations (filedata, section, start, section_size, NULL, NULL))
+	goto error_out;
+    }
+  else
+    {
+      /* If the section being dumped has relocations against it the user might
+	 be expecting these relocations to have been applied.  Check for this
+	 case and issue a warning message in order to avoid confusion.
+	 FIXME: Maybe we ought to have an option that dumps a section with
+	 relocs applied ?  */
+      for (relsec = filedata->section_headers;
+	   relsec < filedata->section_headers + filedata->file_header.e_shnum;
+	   ++relsec)
+	{
+	  if ((relsec->sh_type != SHT_RELA && relsec->sh_type != SHT_REL)
+	      || relsec->sh_info >= filedata->file_header.e_shnum
+	      || filedata->section_headers + relsec->sh_info != section
+	      || relsec->sh_size == 0
+	      || relsec->sh_link >= filedata->file_header.e_shnum)
+	    continue;
+
+	  printf (_(" NOTE: This section has relocations against it, but these have NOT been applied to this dump.\n"));
+	  break;
+	}
+    }
+
+  addr = section->sh_addr;
+  bytes = section_size;
+  data = start;
+
+  while (bytes)
+    {
+      int j;
+      int k;
+      int lbytes;
+
+      lbytes = (bytes > 16 ? 16 : bytes);
+
+      printf ("  0x%8.8lx ", (unsigned long) addr);
+
+      for (j = 0; j < 16; j++)
+	{
+	  if (j < lbytes)
+	    printf ("%2.2x", data[j]);
+	  else
+	    printf ("  ");
+
+	  if ((j & 3) == 3)
+	    printf (" ");
+	}
+
+      for (j = 0; j < lbytes; j++)
+	{
+	  k = data[j];
+	  if (k >= ' ' && k < 0x7f)
+	    printf ("%c", k);
+	  else
+	    printf (".");
+	}
+
+      putchar ('\n');
+
+      data  += lbytes;
+      addr  += lbytes;
+      bytes -= lbytes;
+    }
+
+  free (real_start);
+
+  putchar ('\n');
+  return true;
+
+ error_out:
+  free (real_start);
+  return false;
+}
+
+#ifdef ENABLE_LIBCTF
+static ctf_sect_t *
+shdr_to_ctf_sect (ctf_sect_t *buf, Elf_Internal_Shdr *shdr, Filedata *filedata)
+{
+  buf->cts_name = SECTION_NAME_PRINT (shdr);
+  buf->cts_size = shdr->sh_size;
+  buf->cts_entsize = shdr->sh_entsize;
+
+  return buf;
+}
+
+/* Formatting callback function passed to ctf_dump.  Returns either the pointer
+   it is passed, or a pointer to newly-allocated storage, in which case
+   dump_ctf() will free it when it no longer needs it.  */
+
+static char *
+dump_ctf_indent_lines (ctf_sect_names_t sect ATTRIBUTE_UNUSED,
+		       char *s, void *arg)
+{
+  const char *blanks = arg;
+  char *new_s;
+
+  if (asprintf (&new_s, "%s%s", blanks, s) < 0)
+    return s;
+  return new_s;
+}
+
+/* Dump CTF errors/warnings.  */
+static void
+dump_ctf_errs (ctf_dict_t *fp)
+{
+  ctf_next_t *it = NULL;
+  char *errtext;
+  int is_warning;
+  int err;
+
+  /* Dump accumulated errors and warnings.  */
+  while ((errtext = ctf_errwarning_next (fp, &it, &is_warning, &err)) != NULL)
+    {
+      error (_("%s: %s"), is_warning ? _("warning"): _("error"),
+	     errtext);
+      free (errtext);
+    }
+  if (err != ECTF_NEXT_END)
+    error (_("CTF error: cannot get CTF errors: `%s'"), ctf_errmsg (err));
+}
+
+/* Dump one CTF archive member.  */
+
+static int
+dump_ctf_archive_member (ctf_dict_t *ctf, const char *name, void *arg)
+{
+  ctf_dict_t *parent = (ctf_dict_t *) arg;
+  const char *things[] = {"Header", "Labels", "Data objects",
+			  "Function objects", "Variables", "Types", "Strings",
+			  ""};
+  const char **thing;
+  size_t i;
+  int err = 0;
+
+  /* Only print out the name of non-default-named archive members.
+     The name .ctf appears everywhere, even for things that aren't
+     really archives, so printing it out is liable to be confusing.
+
+     The parent, if there is one, is the default-owned archive member:
+     avoid importing it into itself.  (This does no harm, but looks
+     confusing.)  */
+
+  if (strcmp (name, ".ctf") != 0)
+    {
+      printf (_("\nCTF archive member: %s:\n"), name);
+      ctf_import (ctf, parent);
+    }
+
+  for (i = 0, thing = things; *thing[0]; thing++, i++)
+    {
+      ctf_dump_state_t *s = NULL;
+      char *item;
+
+      printf ("\n  %s:\n", *thing);
+      while ((item = ctf_dump (ctf, &s, i, dump_ctf_indent_lines,
+			       (void *) "    ")) != NULL)
+	{
+	  printf ("%s\n", item);
+	  free (item);
+	}
+
+      if (ctf_errno (ctf))
+	{
+	  error (_("Iteration failed: %s, %s\n"), *thing,
+		 ctf_errmsg (ctf_errno (ctf)));
+	  err = 1;
+	  goto out;
+	}
+    }
+
+ out:
+  dump_ctf_errs (ctf);
+  return err;
+}
+
+static bool
+dump_section_as_ctf (Elf_Internal_Shdr * section, Filedata * filedata)
+{
+  Elf_Internal_Shdr *  parent_sec = NULL;
+  Elf_Internal_Shdr *  symtab_sec = NULL;
+  Elf_Internal_Shdr *  strtab_sec = NULL;
+  void *	       data = NULL;
+  void *	       symdata = NULL;
+  void *	       strdata = NULL;
+  void *	       parentdata = NULL;
+  ctf_sect_t	       ctfsect, symsect, strsect, parentsect;
+  ctf_sect_t *	       symsectp = NULL;
+  ctf_sect_t *	       strsectp = NULL;
+  ctf_archive_t *      ctfa = NULL;
+  ctf_archive_t *      parenta = NULL, *lookparent;
+  ctf_dict_t *         parent = NULL;
+
+  int err;
+  bool ret = false;
+
+  shdr_to_ctf_sect (&ctfsect, section, filedata);
+  data = get_section_contents (section, filedata);
+  ctfsect.cts_data = data;
+
+  if (!dump_ctf_symtab_name)
+    dump_ctf_symtab_name = strdup (".dynsym");
+
+  if (!dump_ctf_strtab_name)
+    dump_ctf_strtab_name = strdup (".dynstr");
+
+  if (dump_ctf_symtab_name && dump_ctf_symtab_name[0] != 0)
+    {
+      if ((symtab_sec = find_section (filedata, dump_ctf_symtab_name)) == NULL)
+	{
+	  error (_("No symbol section named %s\n"), dump_ctf_symtab_name);
+	  goto fail;
+	}
+      if ((symdata = (void *) get_data (NULL, filedata,
+					symtab_sec->sh_offset, 1,
+					symtab_sec->sh_size,
+					_("symbols"))) == NULL)
+	goto fail;
+      symsectp = shdr_to_ctf_sect (&symsect, symtab_sec, filedata);
+      symsect.cts_data = symdata;
+    }
+
+  if (dump_ctf_strtab_name && dump_ctf_strtab_name[0] != 0)
+    {
+      if ((strtab_sec = find_section (filedata, dump_ctf_strtab_name)) == NULL)
+	{
+	  error (_("No string table section named %s\n"),
+		 dump_ctf_strtab_name);
+	  goto fail;
+	}
+      if ((strdata = (void *) get_data (NULL, filedata,
+					strtab_sec->sh_offset, 1,
+					strtab_sec->sh_size,
+					_("strings"))) == NULL)
+	goto fail;
+      strsectp = shdr_to_ctf_sect (&strsect, strtab_sec, filedata);
+      strsect.cts_data = strdata;
+    }
+
+  if (dump_ctf_parent_name)
+    {
+      if ((parent_sec = find_section (filedata, dump_ctf_parent_name)) == NULL)
+	{
+	  error (_("No CTF parent section named %s\n"), dump_ctf_parent_name);
+	  goto fail;
+	}
+      if ((parentdata = (void *) get_data (NULL, filedata,
+					   parent_sec->sh_offset, 1,
+					   parent_sec->sh_size,
+					   _("CTF parent"))) == NULL)
+	goto fail;
+      shdr_to_ctf_sect (&parentsect, parent_sec, filedata);
+      parentsect.cts_data = parentdata;
+    }
+
+  /* Load the CTF file and dump it.  It may be a raw CTF section, or an archive:
+     libctf papers over the difference, so we can pretend it is always an
+     archive.  Possibly open the parent as well, if one was specified.  */
+
+  if ((ctfa = ctf_arc_bufopen (&ctfsect, symsectp, strsectp, &err)) == NULL)
+    {
+      dump_ctf_errs (NULL);
+      error (_("CTF open failure: %s\n"), ctf_errmsg (err));
+      goto fail;
+    }
+
+  ctf_arc_symsect_endianness (ctfa, filedata->file_header.e_ident[EI_DATA]
+			      != ELFDATA2MSB);
+
+  if (parentdata)
+    {
+      if ((parenta = ctf_arc_bufopen (&parentsect, symsectp, strsectp,
+				      &err)) == NULL)
+	{
+	  dump_ctf_errs (NULL);
+	  error (_("CTF open failure: %s\n"), ctf_errmsg (err));
+	  goto fail;
+	}
+      lookparent = parenta;
+    }
+  else
+    lookparent = ctfa;
+
+  /* Assume that the applicable parent archive member is the default one.
+     (This is what all known implementations are expected to do, if they
+     put CTFs and their parents in archives together.)  */
+  if ((parent = ctf_dict_open (lookparent, NULL, &err)) == NULL)
+    {
+      dump_ctf_errs (NULL);
+      error (_("CTF open failure: %s\n"), ctf_errmsg (err));
+      goto fail;
+    }
+
+  ret = true;
+
+  if (filedata->is_separate)
+    printf (_("\nDump of CTF section '%s' in linked file %s:\n"),
+	    printable_section_name (filedata, section),
+	    filedata->file_name);
+  else
+    printf (_("\nDump of CTF section '%s':\n"),
+	    printable_section_name (filedata, section));
+
+  if ((err = ctf_archive_iter (ctfa, dump_ctf_archive_member, parent)) != 0)
+    {
+      dump_ctf_errs (NULL);
+      error (_("CTF member open failure: %s\n"), ctf_errmsg (err));
+      ret = false;
+    }
+
+ fail:
+  ctf_dict_close (parent);
+  ctf_close (ctfa);
+  ctf_close (parenta);
+  free (parentdata);
+  free (data);
+  free (symdata);
+  free (strdata);
+  return ret;
+}
+#endif
+
+static bool
+load_specific_debug_section (enum dwarf_section_display_enum  debug,
+			     const Elf_Internal_Shdr *        sec,
+			     void *                           data)
+{
+  struct dwarf_section * section = &debug_displays [debug].section;
+  char buf [64];
+  Filedata * filedata = (Filedata *) data;
+
+  if (section->start != NULL)
+    {
+      /* If it is already loaded, do nothing.  */
+      if (streq (section->filename, filedata->file_name))
+	return true;
+      free (section->start);
+    }
+
+  snprintf (buf, sizeof (buf), _("%s section data"), section->name);
+  section->address = sec->sh_addr;
+  section->filename = filedata->file_name;
+  section->start = (unsigned char *) get_data (NULL, filedata,
+                                               sec->sh_offset, 1,
+                                               sec->sh_size, buf);
+  if (section->start == NULL)
+    section->size = 0;
+  else
+    {
+      unsigned char *start = section->start;
+      dwarf_size_type size = sec->sh_size;
+      dwarf_size_type uncompressed_size = 0;
+
+      if ((sec->sh_flags & SHF_COMPRESSED) != 0)
+	{
+	  Elf_Internal_Chdr chdr;
+	  unsigned int compression_header_size;
+
+	  if (size < (is_32bit_elf
+		      ? sizeof (Elf32_External_Chdr)
+		      : sizeof (Elf64_External_Chdr)))
+	    {
+	      warn (_("compressed section %s is too small to contain a compression header\n"),
+		    section->name);
+	      return false;
+	    }
+
+	  compression_header_size = get_compression_header (&chdr, start, size);
+	  if (compression_header_size == 0)
+	    /* An error message will have already been generated
+	       by get_compression_header.  */
+	    return false;
+
+	  if (chdr.ch_type != ELFCOMPRESS_ZLIB)
+	    {
+	      warn (_("section '%s' has unsupported compress type: %d\n"),
+		    section->name, chdr.ch_type);
+	      return false;
+	    }
+	  uncompressed_size = chdr.ch_size;
+	  start += compression_header_size;
+	  size -= compression_header_size;
+	}
+      else if (size > 12 && streq ((char *) start, "ZLIB"))
+	{
+	  /* Read the zlib header.  In this case, it should be "ZLIB"
+	     followed by the uncompressed section size, 8 bytes in
+	     big-endian order.  */
+	  uncompressed_size = start[4]; uncompressed_size <<= 8;
+	  uncompressed_size += start[5]; uncompressed_size <<= 8;
+	  uncompressed_size += start[6]; uncompressed_size <<= 8;
+	  uncompressed_size += start[7]; uncompressed_size <<= 8;
+	  uncompressed_size += start[8]; uncompressed_size <<= 8;
+	  uncompressed_size += start[9]; uncompressed_size <<= 8;
+	  uncompressed_size += start[10]; uncompressed_size <<= 8;
+	  uncompressed_size += start[11];
+	  start += 12;
+	  size -= 12;
+	}
+
+      if (uncompressed_size)
+	{
+	  if (uncompress_section_contents (&start, uncompressed_size,
+					   &size))
+	    {
+	      /* Free the compressed buffer, update the section buffer
+		 and the section size if uncompress is successful.  */
+	      free (section->start);
+	      section->start = start;
+	    }
+	  else
+	    {
+	      error (_("Unable to decompress section %s\n"),
+		     printable_section_name (filedata, sec));
+	      return false;
+	    }
+	}
+
+      section->size = size;
+    }
+
+  if (section->start == NULL)
+    return false;
+
+  if (debug_displays [debug].relocate)
+    {
+      if (! apply_relocations (filedata, sec, section->start, section->size,
+			       & section->reloc_info, & section->num_relocs))
+	return false;
+    }
+  else
+    {
+      section->reloc_info = NULL;
+      section->num_relocs = 0;
+    }
+
+  return true;
+}
+
+#if HAVE_LIBDEBUGINFOD
+/* Return a hex string representation of the build-id.  */
+unsigned char *
+get_build_id (void * data)
+{
+  Filedata * filedata = (Filedata *) data;
+  Elf_Internal_Shdr * shdr;
+  unsigned long i;
+
+  /* Iterate through notes to find note.gnu.build-id.
+     FIXME: Only the first note in any note section is examined.  */
+  for (i = 0, shdr = filedata->section_headers;
+       i < filedata->file_header.e_shnum && shdr != NULL;
+       i++, shdr++)
+    {
+      if (shdr->sh_type != SHT_NOTE)
+        continue;
+
+      char * next;
+      char * end;
+      size_t data_remaining;
+      size_t min_notesz;
+      Elf_External_Note * enote;
+      Elf_Internal_Note inote;
+
+      bfd_vma offset = shdr->sh_offset;
+      bfd_vma align = shdr->sh_addralign;
+      bfd_vma length = shdr->sh_size;
+
+      enote = (Elf_External_Note *) get_section_contents (shdr, filedata);
+      if (enote == NULL)
+        continue;
+
+      if (align < 4)
+        align = 4;
+      else if (align != 4 && align != 8)
+	{
+	  free (enote);
+	  continue;
+	}
+
+      end = (char *) enote + length;
+      data_remaining = end - (char *) enote;
+
+      if (!is_ia64_vms (filedata))
+        {
+          min_notesz = offsetof (Elf_External_Note, name);
+          if (data_remaining < min_notesz)
+            {
+	      warn (_("\
+malformed note encountered in section %s whilst scanning for build-id note\n"),
+		    printable_section_name (filedata, shdr));
+	      free (enote);
+              continue;
+            }
+          data_remaining -= min_notesz;
+
+          inote.type     = BYTE_GET (enote->type);
+          inote.namesz   = BYTE_GET (enote->namesz);
+          inote.namedata = enote->name;
+          inote.descsz   = BYTE_GET (enote->descsz);
+          inote.descdata = ((char *) enote
+                            + ELF_NOTE_DESC_OFFSET (inote.namesz, align));
+          inote.descpos  = offset + (inote.descdata - (char *) enote);
+          next = ((char *) enote
+                  + ELF_NOTE_NEXT_OFFSET (inote.namesz, inote.descsz, align));
+        }
+      else
+        {
+          Elf64_External_VMS_Note *vms_enote;
+
+          /* PR binutils/15191
+             Make sure that there is enough data to read.  */
+          min_notesz = offsetof (Elf64_External_VMS_Note, name);
+          if (data_remaining < min_notesz)
+            {
+	      warn (_("\
+malformed note encountered in section %s whilst scanning for build-id note\n"),
+		    printable_section_name (filedata, shdr));
+	      free (enote);
+              continue;
+            }
+          data_remaining -= min_notesz;
+
+          vms_enote = (Elf64_External_VMS_Note *) enote;
+          inote.type     = BYTE_GET (vms_enote->type);
+          inote.namesz   = BYTE_GET (vms_enote->namesz);
+          inote.namedata = vms_enote->name;
+          inote.descsz   = BYTE_GET (vms_enote->descsz);
+          inote.descdata = inote.namedata + align_power (inote.namesz, 3);
+          inote.descpos  = offset + (inote.descdata - (char *) enote);
+          next = inote.descdata + align_power (inote.descsz, 3);
+        }
+
+      /* Skip malformed notes.  */
+      if ((size_t) (inote.descdata - inote.namedata) < inote.namesz
+          || (size_t) (inote.descdata - inote.namedata) > data_remaining
+          || (size_t) (next - inote.descdata) < inote.descsz
+          || ((size_t) (next - inote.descdata)
+              > data_remaining - (size_t) (inote.descdata - inote.namedata)))
+        {
+	  warn (_("\
+malformed note encountered in section %s whilst scanning for build-id note\n"),
+		printable_section_name (filedata, shdr));
+	  free (enote);
+          continue;
+        }
+
+      /* Check if this is the build-id note. If so then convert the build-id
+         bytes to a hex string.  */
+      if (inote.namesz > 0
+          && startswith (inote.namedata, "GNU")
+          && inote.type == NT_GNU_BUILD_ID)
+        {
+          unsigned long j;
+          char * build_id;
+
+          build_id = malloc (inote.descsz * 2 + 1);
+          if (build_id == NULL)
+	    {
+	      free (enote);
+	      return NULL;
+	    }
+
+          for (j = 0; j < inote.descsz; ++j)
+            sprintf (build_id + (j * 2), "%02x", inote.descdata[j] & 0xff);
+          build_id[inote.descsz * 2] = '\0';
+	  free (enote);
+
+          return (unsigned char *) build_id;
+        }
+      free (enote);
+    }
+
+  return NULL;
+}
+#endif /* HAVE_LIBDEBUGINFOD */
+
+/* If this is not NULL, load_debug_section will only look for sections
+   within the list of sections given here.  */
+static unsigned int * section_subset = NULL;
+
+bool
+load_debug_section (enum dwarf_section_display_enum debug, void * data)
+{
+  struct dwarf_section * section = &debug_displays [debug].section;
+  Elf_Internal_Shdr * sec;
+  Filedata * filedata = (Filedata *) data;
+
+  /* Without section headers we cannot find any sections.  */
+  if (filedata->section_headers == NULL)
+    return false;
+
+  if (filedata->string_table == NULL
+      && filedata->file_header.e_shstrndx != SHN_UNDEF
+      && filedata->file_header.e_shstrndx < filedata->file_header.e_shnum)
+    {
+      Elf_Internal_Shdr * strs;
+
+      /* Read in the string table, so that we have section names to scan.  */
+      strs = filedata->section_headers + filedata->file_header.e_shstrndx;
+
+      if (strs != NULL && strs->sh_size != 0)
+	{
+	  filedata->string_table
+	    = (char *) get_data (NULL, filedata, strs->sh_offset,
+				 1, strs->sh_size, _("string table"));
+
+	  filedata->string_table_length
+	    = filedata->string_table != NULL ? strs->sh_size : 0;
+	}
+    }
+
+  /* Locate the debug section.  */
+  sec = find_section_in_set (filedata, section->uncompressed_name, section_subset);
+  if (sec != NULL)
+    section->name = section->uncompressed_name;
+  else
+    {
+      sec = find_section_in_set (filedata, section->compressed_name, section_subset);
+      if (sec != NULL)
+	section->name = section->compressed_name;
+    }
+  if (sec == NULL)
+    return false;
+
+  /* If we're loading from a subset of sections, and we've loaded
+     a section matching this name before, it's likely that it's a
+     different one.  */
+  if (section_subset != NULL)
+    free_debug_section (debug);
+
+  return load_specific_debug_section (debug, sec, data);
+}
+
+void
+free_debug_section (enum dwarf_section_display_enum debug)
+{
+  struct dwarf_section * section = &debug_displays [debug].section;
+
+  if (section->start == NULL)
+    return;
+
+  free ((char *) section->start);
+  section->start = NULL;
+  section->address = 0;
+  section->size = 0;
+
+  free (section->reloc_info);
+  section->reloc_info = NULL;
+  section->num_relocs = 0;
+}
+
+static bool
+display_debug_section (int shndx, Elf_Internal_Shdr * section, Filedata * filedata)
+{
+  char * name = SECTION_NAME_VALID (section) ? SECTION_NAME (section) : "";
+  const char * print_name = printable_section_name (filedata, section);
+  bfd_size_type length;
+  bool result = true;
+  int i;
+
+  length = section->sh_size;
+  if (length == 0)
+    {
+      printf (_("\nSection '%s' has no debugging data.\n"), print_name);
+      return true;
+    }
+  if (section->sh_type == SHT_NOBITS)
+    {
+      /* There is no point in dumping the contents of a debugging section
+	 which has the NOBITS type - the bits in the file will be random.
+	 This can happen when a file containing a .eh_frame section is
+	 stripped with the --only-keep-debug command line option.  */
+      printf (_("section '%s' has the NOBITS type - its contents are unreliable.\n"),
+	      print_name);
+      return false;
+    }
+
+  if (startswith (name, ".gnu.linkonce.wi."))
+    name = ".debug_info";
+
+  /* See if we know how to display the contents of this section.  */
+  for (i = 0; i < max; i++)
+    {
+      enum dwarf_section_display_enum  id = (enum dwarf_section_display_enum) i;
+      struct dwarf_section_display *   display = debug_displays + i;
+      struct dwarf_section *           sec = & display->section;
+
+      if (streq (sec->uncompressed_name, name)
+	  || (id == line && startswith (name, ".debug_line."))
+	  || streq (sec->compressed_name, name))
+	{
+	  bool secondary = (section != find_section (filedata, name));
+
+	  if (secondary)
+	    free_debug_section (id);
+
+	  if (i == line && startswith (name, ".debug_line."))
+	    sec->name = name;
+	  else if (streq (sec->uncompressed_name, name))
+	    sec->name = sec->uncompressed_name;
+	  else
+	    sec->name = sec->compressed_name;
+
+	  if (load_specific_debug_section (id, section, filedata))
+	    {
+	      /* If this debug section is part of a CU/TU set in a .dwp file,
+		 restrict load_debug_section to the sections in that set.  */
+	      section_subset = find_cu_tu_set (filedata, shndx);
+
+	      result &= display->display (sec, filedata);
+
+	      section_subset = NULL;
+
+	      if (secondary || (id != info && id != abbrev && id != debug_addr))
+		free_debug_section (id);
+	    }
+	  break;
+	}
+    }
+
+  if (i == max)
+    {
+      printf (_("Unrecognized debug section: %s\n"), print_name);
+      result = false;
+    }
+
+  return result;
+}
+
+/* Set DUMP_SECTS for all sections where dumps were requested
+   based on section name.  */
+
+static void
+initialise_dumps_byname (Filedata * filedata)
+{
+  struct dump_list_entry * cur;
+
+  for (cur = dump_sects_byname; cur; cur = cur->next)
+    {
+      unsigned int i;
+      bool any = false;
+
+      for (i = 0; i < filedata->file_header.e_shnum; i++)
+	if (SECTION_NAME_VALID (filedata->section_headers + i)
+	    && streq (SECTION_NAME (filedata->section_headers + i), cur->name))
+	  {
+	    request_dump_bynumber (&filedata->dump, i, cur->type);
+	    any = true;
+	  }
+
+      if (!any && !filedata->is_separate)
+	warn (_("Section '%s' was not dumped because it does not exist\n"),
+	      cur->name);
+    }
+}
+
+static bool
+process_section_contents (Filedata * filedata)
+{
+  Elf_Internal_Shdr * section;
+  unsigned int i;
+  bool res = true;
+
+  if (! do_dump)
+    return true;
+
+  initialise_dumps_byname (filedata);
+
+  for (i = 0, section = filedata->section_headers;
+       i < filedata->file_header.e_shnum && i < filedata->dump.num_dump_sects;
+       i++, section++)
+    {
+      dump_type dump = filedata->dump.dump_sects[i];
+
+      if (filedata->is_separate && ! process_links)
+	dump &= DEBUG_DUMP;
+
+#ifdef SUPPORT_DISASSEMBLY
+      if (dump & DISASS_DUMP)
+	{
+	  if (! disassemble_section (section, filedata))
+	    res = false;
+	}
+#endif
+      if (dump & HEX_DUMP)
+	{
+	  if (! dump_section_as_bytes (section, filedata, false))
+	    res = false;
+	}
+
+      if (dump & RELOC_DUMP)
+	{
+	  if (! dump_section_as_bytes (section, filedata, true))
+	    res = false;
+	}
+
+      if (dump & STRING_DUMP)
+	{
+	  if (! dump_section_as_strings (section, filedata))
+	    res = false;
+	}
+
+      if (dump & DEBUG_DUMP)
+	{
+	  if (! display_debug_section (i, section, filedata))
+	    res = false;
+	}
+
+#ifdef ENABLE_LIBCTF
+      if (dump & CTF_DUMP)
+	{
+	  if (! dump_section_as_ctf (section, filedata))
+	    res = false;
+	}
+#endif
+    }
+
+  if (! filedata->is_separate)
+    {
+      /* Check to see if the user requested a
+	 dump of a section that does not exist.  */
+      for (; i < filedata->dump.num_dump_sects; i++)
+	if (filedata->dump.dump_sects[i])
+	  {
+	    warn (_("Section %d was not dumped because it does not exist!\n"), i);
+	    res = false;
+	  }
+    }
+
+  return res;
+}
+
+static void
+process_mips_fpe_exception (int mask)
+{
+  if (mask)
+    {
+      bool first = true;
+
+      if (mask & OEX_FPU_INEX)
+	fputs ("INEX", stdout), first = false;
+      if (mask & OEX_FPU_UFLO)
+	printf ("%sUFLO", first ? "" : "|"), first = false;
+      if (mask & OEX_FPU_OFLO)
+	printf ("%sOFLO", first ? "" : "|"), first = false;
+      if (mask & OEX_FPU_DIV0)
+	printf ("%sDIV0", first ? "" : "|"), first = false;
+      if (mask & OEX_FPU_INVAL)
+	printf ("%sINVAL", first ? "" : "|");
+    }
+  else
+    fputs ("0", stdout);
+}
+
+/* Display's the value of TAG at location P.  If TAG is
+   greater than 0 it is assumed to be an unknown tag, and
+   a message is printed to this effect.  Otherwise it is
+   assumed that a message has already been printed.
+
+   If the bottom bit of TAG is set it assumed to have a
+   string value, otherwise it is assumed to have an integer
+   value.
+
+   Returns an updated P pointing to the first unread byte
+   beyond the end of TAG's value.
+
+   Reads at or beyond END will not be made.  */
+
+static unsigned char *
+display_tag_value (signed int tag,
+		   unsigned char * p,
+		   const unsigned char * const end)
+{
+  unsigned long val;
+
+  if (tag > 0)
+    printf ("  Tag_unknown_%d: ", tag);
+
+  if (p >= end)
+    {
+      warn (_("<corrupt tag>\n"));
+    }
+  else if (tag & 1)
+    {
+      /* PR 17531 file: 027-19978-0.004.  */
+      size_t maxlen = (end - p) - 1;
+
+      putchar ('"');
+      if (maxlen > 0)
+	{
+	  print_symbol ((int) maxlen, (const char *) p);
+	  p += strnlen ((char *) p, maxlen) + 1;
+	}
+      else
+	{
+	  printf (_("<corrupt string tag>"));
+	  p = (unsigned char *) end;
+	}
+      printf ("\"\n");
+    }
+  else
+    {
+      READ_ULEB (val, p, end);
+      printf ("%ld (0x%lx)\n", val, val);
+    }
+
+  assert (p <= end);
+  return p;
+}
+
+/* ARC ABI attributes section.  */
+
+static unsigned char *
+display_arc_attribute (unsigned char * p,
+		       const unsigned char * const end)
+{
+  unsigned int tag;
+  unsigned int val;
+
+  READ_ULEB (tag, p, end);
+
+  switch (tag)
+    {
+    case Tag_ARC_PCS_config:
+      READ_ULEB (val, p, end);
+      printf ("  Tag_ARC_PCS_config: ");
+      switch (val)
+	{
+	case 0:
+	  printf (_("Absent/Non standard\n"));
+	  break;
+	case 1:
+	  printf (_("Bare metal/mwdt\n"));
+	  break;
+	case 2:
+	  printf (_("Bare metal/newlib\n"));
+	  break;
+	case 3:
+	  printf (_("Linux/uclibc\n"));
+	  break;
+	case 4:
+	  printf (_("Linux/glibc\n"));
+	  break;
+	default:
+	  printf (_("Unknown\n"));
+	  break;
+	}
+      break;
+
+    case Tag_ARC_CPU_base:
+      READ_ULEB (val, p, end);
+      printf ("  Tag_ARC_CPU_base: ");
+      switch (val)
+	{
+	default:
+	case TAG_CPU_NONE:
+	  printf (_("Absent\n"));
+	  break;
+	case TAG_CPU_ARC6xx:
+	  printf ("ARC6xx\n");
+	  break;
+	case TAG_CPU_ARC7xx:
+	  printf ("ARC7xx\n");
+	  break;
+	case TAG_CPU_ARCEM:
+	  printf ("ARCEM\n");
+	  break;
+	case TAG_CPU_ARCHS:
+	  printf ("ARCHS\n");
+	  break;
+	}
+      break;
+
+    case Tag_ARC_CPU_variation:
+      READ_ULEB (val, p, end);
+      printf ("  Tag_ARC_CPU_variation: ");
+      switch (val)
+	{
+	default:
+	  if (val > 0 && val < 16)
+	      printf ("Core%d\n", val);
+	  else
+	      printf ("Unknown\n");
+	  break;
+
+	case 0:
+	  printf (_("Absent\n"));
+	  break;
+	}
+      break;
+
+    case Tag_ARC_CPU_name:
+      printf ("  Tag_ARC_CPU_name: ");
+      p = display_tag_value (-1, p, end);
+      break;
+
+    case Tag_ARC_ABI_rf16:
+      READ_ULEB (val, p, end);
+      printf ("  Tag_ARC_ABI_rf16: %s\n", val ? _("yes") : _("no"));
+      break;
+
+    case Tag_ARC_ABI_osver:
+      READ_ULEB (val, p, end);
+      printf ("  Tag_ARC_ABI_osver: v%d\n", val);
+      break;
+
+    case Tag_ARC_ABI_pic:
+    case Tag_ARC_ABI_sda:
+      READ_ULEB (val, p, end);
+      printf (tag == Tag_ARC_ABI_sda ? "  Tag_ARC_ABI_sda: "
+	      : "  Tag_ARC_ABI_pic: ");
+      switch (val)
+	{
+	case 0:
+	  printf (_("Absent\n"));
+	  break;
+	case 1:
+	  printf ("MWDT\n");
+	  break;
+	case 2:
+	  printf ("GNU\n");
+	  break;
+	default:
+	  printf (_("Unknown\n"));
+	  break;
+	}
+      break;
+
+    case Tag_ARC_ABI_tls:
+      READ_ULEB (val, p, end);
+      printf ("  Tag_ARC_ABI_tls: %s\n", val ? "r25": "none");
+      break;
+
+    case Tag_ARC_ABI_enumsize:
+      READ_ULEB (val, p, end);
+      printf ("  Tag_ARC_ABI_enumsize: %s\n", val ? _("default") :
+	      _("smallest"));
+      break;
+
+    case Tag_ARC_ABI_exceptions:
+      READ_ULEB (val, p, end);
+      printf ("  Tag_ARC_ABI_exceptions: %s\n", val ? _("OPTFP")
+	      : _("default"));
+      break;
+
+    case Tag_ARC_ABI_double_size:
+      READ_ULEB (val, p, end);
+      printf ("  Tag_ARC_ABI_double_size: %d\n", val);
+      break;
+
+    case Tag_ARC_ISA_config:
+      printf ("  Tag_ARC_ISA_config: ");
+      p = display_tag_value (-1, p, end);
+      break;
+
+    case Tag_ARC_ISA_apex:
+      printf ("  Tag_ARC_ISA_apex: ");
+      p = display_tag_value (-1, p, end);
+      break;
+
+    case Tag_ARC_ISA_mpy_option:
+      READ_ULEB (val, p, end);
+      printf ("  Tag_ARC_ISA_mpy_option: %d\n", val);
+      break;
+
+    case Tag_ARC_ATR_version:
+      READ_ULEB (val, p, end);
+      printf ("  Tag_ARC_ATR_version: %d\n", val);
+      break;
+
+    default:
+      return display_tag_value (tag & 1, p, end);
+    }
+
+  return p;
+}
+
+/* ARM EABI attributes section.  */
+typedef struct
+{
+  unsigned int tag;
+  const char * name;
+  /* 0 = special, 1 = string, 2 = uleb123, > 0x80 == table lookup.  */
+  unsigned int type;
+  const char *const *table;
+} arm_attr_public_tag;
+
+static const char *const arm_attr_tag_CPU_arch[] =
+  {"Pre-v4", "v4", "v4T", "v5T", "v5TE", "v5TEJ", "v6", "v6KZ", "v6T2",
+   "v6K", "v7", "v6-M", "v6S-M", "v7E-M", "v8", "v8-R", "v8-M.baseline",
+   "v8-M.mainline", "", "", "", "v8.1-M.mainline"};
+static const char *const arm_attr_tag_ARM_ISA_use[] = {"No", "Yes"};
+static const char *const arm_attr_tag_THUMB_ISA_use[] =
+  {"No", "Thumb-1", "Thumb-2", "Yes"};
+static const char *const arm_attr_tag_FP_arch[] =
+  {"No", "VFPv1", "VFPv2", "VFPv3", "VFPv3-D16", "VFPv4", "VFPv4-D16",
+   "FP for ARMv8", "FPv5/FP-D16 for ARMv8"};
+static const char *const arm_attr_tag_WMMX_arch[] = {"No", "WMMXv1", "WMMXv2"};
+static const char *const arm_attr_tag_Advanced_SIMD_arch[] =
+  {"No", "NEONv1", "NEONv1 with Fused-MAC", "NEON for ARMv8",
+   "NEON for ARMv8.1"};
+static const char *const arm_attr_tag_PCS_config[] =
+  {"None", "Bare platform", "Linux application", "Linux DSO", "PalmOS 2004",
+   "PalmOS (reserved)", "SymbianOS 2004", "SymbianOS (reserved)"};
+static const char *const arm_attr_tag_ABI_PCS_R9_use[] =
+  {"V6", "SB", "TLS", "Unused"};
+static const char *const arm_attr_tag_ABI_PCS_RW_data[] =
+  {"Absolute", "PC-relative", "SB-relative", "None"};
+static const char *const arm_attr_tag_ABI_PCS_RO_data[] =
+  {"Absolute", "PC-relative", "None"};
+static const char *const arm_attr_tag_ABI_PCS_GOT_use[] =
+  {"None", "direct", "GOT-indirect"};
+static const char *const arm_attr_tag_ABI_PCS_wchar_t[] =
+  {"None", "??? 1", "2", "??? 3", "4"};
+static const char *const arm_attr_tag_ABI_FP_rounding[] = {"Unused", "Needed"};
+static const char *const arm_attr_tag_ABI_FP_denormal[] =
+  {"Unused", "Needed", "Sign only"};
+static const char *const arm_attr_tag_ABI_FP_exceptions[] = {"Unused", "Needed"};
+static const char *const arm_attr_tag_ABI_FP_user_exceptions[] = {"Unused", "Needed"};
+static const char *const arm_attr_tag_ABI_FP_number_model[] =
+  {"Unused", "Finite", "RTABI", "IEEE 754"};
+static const char *const arm_attr_tag_ABI_enum_size[] =
+  {"Unused", "small", "int", "forced to int"};
+static const char *const arm_attr_tag_ABI_HardFP_use[] =
+  {"As Tag_FP_arch", "SP only", "Reserved", "Deprecated"};
+static const char *const arm_attr_tag_ABI_VFP_args[] =
+  {"AAPCS", "VFP registers", "custom", "compatible"};
+static const char *const arm_attr_tag_ABI_WMMX_args[] =
+  {"AAPCS", "WMMX registers", "custom"};
+static const char *const arm_attr_tag_ABI_optimization_goals[] =
+  {"None", "Prefer Speed", "Aggressive Speed", "Prefer Size",
+    "Aggressive Size", "Prefer Debug", "Aggressive Debug"};
+static const char *const arm_attr_tag_ABI_FP_optimization_goals[] =
+  {"None", "Prefer Speed", "Aggressive Speed", "Prefer Size",
+    "Aggressive Size", "Prefer Accuracy", "Aggressive Accuracy"};
+static const char *const arm_attr_tag_CPU_unaligned_access[] = {"None", "v6"};
+static const char *const arm_attr_tag_FP_HP_extension[] =
+  {"Not Allowed", "Allowed"};
+static const char *const arm_attr_tag_ABI_FP_16bit_format[] =
+  {"None", "IEEE 754", "Alternative Format"};
+static const char *const arm_attr_tag_DSP_extension[] =
+  {"Follow architecture", "Allowed"};
+static const char *const arm_attr_tag_MPextension_use[] =
+  {"Not Allowed", "Allowed"};
+static const char *const arm_attr_tag_DIV_use[] =
+  {"Allowed in Thumb-ISA, v7-R or v7-M", "Not allowed",
+    "Allowed in v7-A with integer division extension"};
+static const char *const arm_attr_tag_T2EE_use[] = {"Not Allowed", "Allowed"};
+static const char *const arm_attr_tag_Virtualization_use[] =
+  {"Not Allowed", "TrustZone", "Virtualization Extensions",
+    "TrustZone and Virtualization Extensions"};
+static const char *const arm_attr_tag_MPextension_use_legacy[] =
+  {"Not Allowed", "Allowed"};
+
+static const char *const arm_attr_tag_MVE_arch[] =
+  {"No MVE", "MVE Integer only", "MVE Integer and FP"};
+
+#define LOOKUP(id, name) \
+  {id, #name, 0x80 | ARRAY_SIZE(arm_attr_tag_##name), arm_attr_tag_##name}
+static arm_attr_public_tag arm_attr_public_tags[] =
+{
+  {4, "CPU_raw_name", 1, NULL},
+  {5, "CPU_name", 1, NULL},
+  LOOKUP(6, CPU_arch),
+  {7, "CPU_arch_profile", 0, NULL},
+  LOOKUP(8, ARM_ISA_use),
+  LOOKUP(9, THUMB_ISA_use),
+  LOOKUP(10, FP_arch),
+  LOOKUP(11, WMMX_arch),
+  LOOKUP(12, Advanced_SIMD_arch),
+  LOOKUP(13, PCS_config),
+  LOOKUP(14, ABI_PCS_R9_use),
+  LOOKUP(15, ABI_PCS_RW_data),
+  LOOKUP(16, ABI_PCS_RO_data),
+  LOOKUP(17, ABI_PCS_GOT_use),
+  LOOKUP(18, ABI_PCS_wchar_t),
+  LOOKUP(19, ABI_FP_rounding),
+  LOOKUP(20, ABI_FP_denormal),
+  LOOKUP(21, ABI_FP_exceptions),
+  LOOKUP(22, ABI_FP_user_exceptions),
+  LOOKUP(23, ABI_FP_number_model),
+  {24, "ABI_align_needed", 0, NULL},
+  {25, "ABI_align_preserved", 0, NULL},
+  LOOKUP(26, ABI_enum_size),
+  LOOKUP(27, ABI_HardFP_use),
+  LOOKUP(28, ABI_VFP_args),
+  LOOKUP(29, ABI_WMMX_args),
+  LOOKUP(30, ABI_optimization_goals),
+  LOOKUP(31, ABI_FP_optimization_goals),
+  {32, "compatibility", 0, NULL},
+  LOOKUP(34, CPU_unaligned_access),
+  LOOKUP(36, FP_HP_extension),
+  LOOKUP(38, ABI_FP_16bit_format),
+  LOOKUP(42, MPextension_use),
+  LOOKUP(44, DIV_use),
+  LOOKUP(46, DSP_extension),
+  LOOKUP(48, MVE_arch),
+  {64, "nodefaults", 0, NULL},
+  {65, "also_compatible_with", 0, NULL},
+  LOOKUP(66, T2EE_use),
+  {67, "conformance", 1, NULL},
+  LOOKUP(68, Virtualization_use),
+  LOOKUP(70, MPextension_use_legacy)
+};
+#undef LOOKUP
+
+static unsigned char *
+display_arm_attribute (unsigned char * p,
+		       const unsigned char * const end)
+{
+  unsigned int tag;
+  unsigned int val;
+  arm_attr_public_tag * attr;
+  unsigned i;
+  unsigned int type;
+
+  READ_ULEB (tag, p, end);
+  attr = NULL;
+  for (i = 0; i < ARRAY_SIZE (arm_attr_public_tags); i++)
+    {
+      if (arm_attr_public_tags[i].tag == tag)
+	{
+	  attr = &arm_attr_public_tags[i];
+	  break;
+	}
+    }
+
+  if (attr)
+    {
+      printf ("  Tag_%s: ", attr->name);
+      switch (attr->type)
+	{
+	case 0:
+	  switch (tag)
+	    {
+	    case 7: /* Tag_CPU_arch_profile.  */
+	      READ_ULEB (val, p, end);
+	      switch (val)
+		{
+		case 0: printf (_("None\n")); break;
+		case 'A': printf (_("Application\n")); break;
+		case 'R': printf (_("Realtime\n")); break;
+		case 'M': printf (_("Microcontroller\n")); break;
+		case 'S': printf (_("Application or Realtime\n")); break;
+		default: printf ("??? (%d)\n", val); break;
+		}
+	      break;
+
+	    case 24: /* Tag_align_needed.  */
+	      READ_ULEB (val, p, end);
+	      switch (val)
+		{
+		case 0: printf (_("None\n")); break;
+		case 1: printf (_("8-byte\n")); break;
+		case 2: printf (_("4-byte\n")); break;
+		case 3: printf ("??? 3\n"); break;
+		default:
+		  if (val <= 12)
+		    printf (_("8-byte and up to %d-byte extended\n"),
+			    1 << val);
+		  else
+		    printf ("??? (%d)\n", val);
+		  break;
+		}
+	      break;
+
+	    case 25: /* Tag_align_preserved.  */
+	      READ_ULEB (val, p, end);
+	      switch (val)
+		{
+		case 0: printf (_("None\n")); break;
+		case 1: printf (_("8-byte, except leaf SP\n")); break;
+		case 2: printf (_("8-byte\n")); break;
+		case 3: printf ("??? 3\n"); break;
+		default:
+		  if (val <= 12)
+		    printf (_("8-byte and up to %d-byte extended\n"),
+			    1 << val);
+		  else
+		    printf ("??? (%d)\n", val);
+		  break;
+		}
+	      break;
+
+	    case 32: /* Tag_compatibility.  */
+	      {
+		READ_ULEB (val, p, end);
+		printf (_("flag = %d, vendor = "), val);
+		if (p < end - 1)
+		  {
+		    size_t maxlen = (end - p) - 1;
+
+		    print_symbol ((int) maxlen, (const char *) p);
+		    p += strnlen ((char *) p, maxlen) + 1;
+		  }
+		else
+		  {
+		    printf (_("<corrupt>"));
+		    p = (unsigned char *) end;
+		  }
+		putchar ('\n');
+	      }
+	      break;
+
+	    case 64: /* Tag_nodefaults.  */
+	      /* PR 17531: file: 001-505008-0.01.  */
+	      if (p < end)
+		p++;
+	      printf (_("True\n"));
+	      break;
+
+	    case 65: /* Tag_also_compatible_with.  */
+	      READ_ULEB (val, p, end);
+	      if (val == 6 /* Tag_CPU_arch.  */)
+		{
+		  READ_ULEB (val, p, end);
+		  if ((unsigned int) val >= ARRAY_SIZE (arm_attr_tag_CPU_arch))
+		    printf ("??? (%d)\n", val);
+		  else
+		    printf ("%s\n", arm_attr_tag_CPU_arch[val]);
+		}
+	      else
+		printf ("???\n");
+	      while (p < end && *(p++) != '\0' /* NUL terminator.  */)
+		;
+	      break;
+
+	    default:
+	      printf (_("<unknown: %d>\n"), tag);
+	      break;
+	    }
+	  return p;
+
+	case 1:
+	  return display_tag_value (-1, p, end);
+	case 2:
+	  return display_tag_value (0, p, end);
+
+	default:
+	  assert (attr->type & 0x80);
+	  READ_ULEB (val, p, end);
+	  type = attr->type & 0x7f;
+	  if (val >= type)
+	    printf ("??? (%d)\n", val);
+	  else
+	    printf ("%s\n", attr->table[val]);
+	  return p;
+	}
+    }
+
+  return display_tag_value (tag, p, end);
+}
+
+static unsigned char *
+display_gnu_attribute (unsigned char * p,
+		       unsigned char * (* display_proc_gnu_attribute) (unsigned char *, unsigned int, const unsigned char * const),
+		       const unsigned char * const end)
+{
+  unsigned int tag;
+  unsigned int val;
+
+  READ_ULEB (tag, p, end);
+
+  /* Tag_compatibility is the only generic GNU attribute defined at
+     present.  */
+  if (tag == 32)
+    {
+      READ_ULEB (val, p, end);
+
+      printf (_("flag = %d, vendor = "), val);
+      if (p == end)
+	{
+	  printf (_("<corrupt>\n"));
+	  warn (_("corrupt vendor attribute\n"));
+	}
+      else
+	{
+	  if (p < end - 1)
+	    {
+	      size_t maxlen = (end - p) - 1;
+
+	      print_symbol ((int) maxlen, (const char *) p);
+	      p += strnlen ((char *) p, maxlen) + 1;
+	    }
+	  else
+	    {
+	      printf (_("<corrupt>"));
+	      p = (unsigned char *) end;
+	    }
+	  putchar ('\n');
+	}
+      return p;
+    }
+
+  if ((tag & 2) == 0 && display_proc_gnu_attribute)
+    return display_proc_gnu_attribute (p, tag, end);
+
+  return display_tag_value (tag, p, end);
+}
+
+static unsigned char *
+display_m68k_gnu_attribute (unsigned char * p,
+			    unsigned int tag,
+			    const unsigned char * const end)
+{
+  unsigned int val;
+
+  if (tag == Tag_GNU_M68K_ABI_FP)
+    {
+      printf ("  Tag_GNU_M68K_ABI_FP: ");
+      if (p == end)
+	{
+	  printf (_("<corrupt>\n"));
+	  return p;
+	}
+      READ_ULEB (val, p, end);
+
+      if (val > 3)
+	printf ("(%#x), ", val);
+
+      switch (val & 3)
+	{
+	case 0:
+	  printf (_("unspecified hard/soft float\n"));
+	  break;
+	case 1:
+	  printf (_("hard float\n"));
+	  break;
+	case 2:
+	  printf (_("soft float\n"));
+	  break;
+	}
+      return p;
+    }
+
+  return display_tag_value (tag & 1, p, end);
+}
+
+static unsigned char *
+display_power_gnu_attribute (unsigned char * p,
+			     unsigned int tag,
+			     const unsigned char * const end)
+{
+  unsigned int val;
+
+  if (tag == Tag_GNU_Power_ABI_FP)
+    {
+      printf ("  Tag_GNU_Power_ABI_FP: ");
+      if (p == end)
+	{
+	  printf (_("<corrupt>\n"));
+	  return p;
+	}
+      READ_ULEB (val, p, end);
+
+      if (val > 15)
+	printf ("(%#x), ", val);
+
+      switch (val & 3)
+	{
+	case 0:
+	  printf (_("unspecified hard/soft float, "));
+	  break;
+	case 1:
+	  printf (_("hard float, "));
+	  break;
+	case 2:
+	  printf (_("soft float, "));
+	  break;
+	case 3:
+	  printf (_("single-precision hard float, "));
+	  break;
+	}
+
+      switch (val & 0xC)
+	{
+	case 0:
+	  printf (_("unspecified long double\n"));
+	  break;
+	case 4:
+	  printf (_("128-bit IBM long double\n"));
+	  break;
+	case 8:
+	  printf (_("64-bit long double\n"));
+	  break;
+	case 12:
+	  printf (_("128-bit IEEE long double\n"));
+	  break;
+	}
+      return p;
+    }
+
+  if (tag == Tag_GNU_Power_ABI_Vector)
+    {
+      printf ("  Tag_GNU_Power_ABI_Vector: ");
+      if (p == end)
+	{
+	  printf (_("<corrupt>\n"));
+	  return p;
+	}
+      READ_ULEB (val, p, end);
+
+      if (val > 3)
+	printf ("(%#x), ", val);
+
+      switch (val & 3)
+	{
+	case 0:
+	  printf (_("unspecified\n"));
+	  break;
+	case 1:
+	  printf (_("generic\n"));
+	  break;
+	case 2:
+	  printf ("AltiVec\n");
+	  break;
+	case 3:
+	  printf ("SPE\n");
+	  break;
+	}
+      return p;
+    }
+
+  if (tag == Tag_GNU_Power_ABI_Struct_Return)
+    {
+      printf ("  Tag_GNU_Power_ABI_Struct_Return: ");
+      if (p == end)
+	{
+	  printf (_("<corrupt>\n"));
+	  return p;
+	}
+      READ_ULEB (val, p, end);
+
+      if (val > 2)
+	printf ("(%#x), ", val);
+
+      switch (val & 3)
+	{
+	case 0:
+	  printf (_("unspecified\n"));
+	  break;
+	case 1:
+	  printf ("r3/r4\n");
+	  break;
+	case 2:
+	  printf (_("memory\n"));
+	  break;
+	case 3:
+	  printf ("???\n");
+	  break;
+	}
+      return p;
+    }
+
+  return display_tag_value (tag & 1, p, end);
+}
+
+static unsigned char *
+display_s390_gnu_attribute (unsigned char * p,
+			    unsigned int tag,
+			    const unsigned char * const end)
+{
+  unsigned int val;
+
+  if (tag == Tag_GNU_S390_ABI_Vector)
+    {
+      printf ("  Tag_GNU_S390_ABI_Vector: ");
+      READ_ULEB (val, p, end);
+
+      switch (val)
+	{
+	case 0:
+	  printf (_("any\n"));
+	  break;
+	case 1:
+	  printf (_("software\n"));
+	  break;
+	case 2:
+	  printf (_("hardware\n"));
+	  break;
+	default:
+	  printf ("??? (%d)\n", val);
+	  break;
+	}
+      return p;
+   }
+
+  return display_tag_value (tag & 1, p, end);
+}
+
+static void
+display_sparc_hwcaps (unsigned int mask)
+{
+  if (mask)
+    {
+      bool first = true;
+
+      if (mask & ELF_SPARC_HWCAP_MUL32)
+	fputs ("mul32", stdout), first = false;
+      if (mask & ELF_SPARC_HWCAP_DIV32)
+	printf ("%sdiv32", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP_FSMULD)
+	printf ("%sfsmuld", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP_V8PLUS)
+	printf ("%sv8plus", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP_POPC)
+	printf ("%spopc", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP_VIS)
+	printf ("%svis", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP_VIS2)
+	printf ("%svis2", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP_ASI_BLK_INIT)
+	printf ("%sASIBlkInit", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP_FMAF)
+	printf ("%sfmaf", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP_VIS3)
+	printf ("%svis3", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP_HPC)
+	printf ("%shpc", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP_RANDOM)
+	printf ("%srandom", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP_TRANS)
+	printf ("%strans", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP_FJFMAU)
+	printf ("%sfjfmau", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP_IMA)
+	printf ("%sima", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP_ASI_CACHE_SPARING)
+	printf ("%scspare", first ? "" : "|"), first = false;
+    }
+  else
+    fputc ('0', stdout);
+  fputc ('\n', stdout);
+}
+
+static void
+display_sparc_hwcaps2 (unsigned int mask)
+{
+  if (mask)
+    {
+      bool first = true;
+
+      if (mask & ELF_SPARC_HWCAP2_FJATHPLUS)
+	fputs ("fjathplus", stdout), first = false;
+      if (mask & ELF_SPARC_HWCAP2_VIS3B)
+	printf ("%svis3b", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP2_ADP)
+	printf ("%sadp", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP2_SPARC5)
+	printf ("%ssparc5", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP2_MWAIT)
+	printf ("%smwait", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP2_XMPMUL)
+	printf ("%sxmpmul", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP2_XMONT)
+	printf ("%sxmont2", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP2_NSEC)
+	printf ("%snsec", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP2_FJATHHPC)
+	printf ("%sfjathhpc", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP2_FJDES)
+	printf ("%sfjdes", first ? "" : "|"), first = false;
+      if (mask & ELF_SPARC_HWCAP2_FJAES)
+	printf ("%sfjaes", first ? "" : "|"), first = false;
+    }
+  else
+    fputc ('0', stdout);
+  fputc ('\n', stdout);
+}
+
+static unsigned char *
+display_sparc_gnu_attribute (unsigned char * p,
+			     unsigned int tag,
+			     const unsigned char * const end)
+{
+  unsigned int val;
+
+  if (tag == Tag_GNU_Sparc_HWCAPS)
+    {
+      READ_ULEB (val, p, end);
+      printf ("  Tag_GNU_Sparc_HWCAPS: ");
+      display_sparc_hwcaps (val);
+      return p;
+    }
+  if (tag == Tag_GNU_Sparc_HWCAPS2)
+    {
+      READ_ULEB (val, p, end);
+      printf ("  Tag_GNU_Sparc_HWCAPS2: ");
+      display_sparc_hwcaps2 (val);
+      return p;
+    }
+
+  return display_tag_value (tag, p, end);
+}
+
+static void
+print_mips_fp_abi_value (unsigned int val)
+{
+  switch (val)
+    {
+    case Val_GNU_MIPS_ABI_FP_ANY:
+      printf (_("Hard or soft float\n"));
+      break;
+    case Val_GNU_MIPS_ABI_FP_DOUBLE:
+      printf (_("Hard float (double precision)\n"));
+      break;
+    case Val_GNU_MIPS_ABI_FP_SINGLE:
+      printf (_("Hard float (single precision)\n"));
+      break;
+    case Val_GNU_MIPS_ABI_FP_SOFT:
+      printf (_("Soft float\n"));
+      break;
+    case Val_GNU_MIPS_ABI_FP_OLD_64:
+      printf (_("Hard float (MIPS32r2 64-bit FPU 12 callee-saved)\n"));
+      break;
+    case Val_GNU_MIPS_ABI_FP_XX:
+      printf (_("Hard float (32-bit CPU, Any FPU)\n"));
+      break;
+    case Val_GNU_MIPS_ABI_FP_64:
+      printf (_("Hard float (32-bit CPU, 64-bit FPU)\n"));
+      break;
+    case Val_GNU_MIPS_ABI_FP_64A:
+      printf (_("Hard float compat (32-bit CPU, 64-bit FPU)\n"));
+      break;
+    case Val_GNU_MIPS_ABI_FP_NAN2008:
+      printf (_("NaN 2008 compatibility\n"));
+      break;
+    default:
+      printf ("??? (%d)\n", val);
+      break;
+    }
+}
+
+static unsigned char *
+display_mips_gnu_attribute (unsigned char * p,
+			    unsigned int tag,
+			    const unsigned char * const end)
+{
+  if (tag == Tag_GNU_MIPS_ABI_FP)
+    {
+      unsigned int val;
+
+      printf ("  Tag_GNU_MIPS_ABI_FP: ");
+      READ_ULEB (val, p, end);
+      print_mips_fp_abi_value (val);
+      return p;
+   }
+
+  if (tag == Tag_GNU_MIPS_ABI_MSA)
+    {
+      unsigned int val;
+
+      printf ("  Tag_GNU_MIPS_ABI_MSA: ");
+      READ_ULEB (val, p, end);
+
+      switch (val)
+	{
+	case Val_GNU_MIPS_ABI_MSA_ANY:
+	  printf (_("Any MSA or not\n"));
+	  break;
+	case Val_GNU_MIPS_ABI_MSA_128:
+	  printf (_("128-bit MSA\n"));
+	  break;
+	default:
+	  printf ("??? (%d)\n", val);
+	  break;
+	}
+      return p;
+    }
+
+  return display_tag_value (tag & 1, p, end);
+}
+
+static unsigned char *
+display_tic6x_attribute (unsigned char * p,
+			 const unsigned char * const end)
+{
+  unsigned int tag;
+  unsigned int val;
+
+  READ_ULEB (tag, p, end);
+
+  switch (tag)
+    {
+    case Tag_ISA:
+      printf ("  Tag_ISA: ");
+      READ_ULEB (val, p, end);
+
+      switch (val)
+	{
+	case C6XABI_Tag_ISA_none:
+	  printf (_("None\n"));
+	  break;
+	case C6XABI_Tag_ISA_C62X:
+	  printf ("C62x\n");
+	  break;
+	case C6XABI_Tag_ISA_C67X:
+	  printf ("C67x\n");
+	  break;
+	case C6XABI_Tag_ISA_C67XP:
+	  printf ("C67x+\n");
+	  break;
+	case C6XABI_Tag_ISA_C64X:
+	  printf ("C64x\n");
+	  break;
+	case C6XABI_Tag_ISA_C64XP:
+	  printf ("C64x+\n");
+	  break;
+	case C6XABI_Tag_ISA_C674X:
+	  printf ("C674x\n");
+	  break;
+	default:
+	  printf ("??? (%d)\n", val);
+	  break;
+	}
+      return p;
+
+    case Tag_ABI_wchar_t:
+      printf ("  Tag_ABI_wchar_t: ");
+      READ_ULEB (val, p, end);
+      switch (val)
+	{
+	case 0:
+	  printf (_("Not used\n"));
+	  break;
+	case 1:
+	  printf (_("2 bytes\n"));
+	  break;
+	case 2:
+	  printf (_("4 bytes\n"));
+	  break;
+	default:
+	  printf ("??? (%d)\n", val);
+	  break;
+	}
+      return p;
+
+    case Tag_ABI_stack_align_needed:
+      printf ("  Tag_ABI_stack_align_needed: ");
+      READ_ULEB (val, p, end);
+      switch (val)
+	{
+	case 0:
+	  printf (_("8-byte\n"));
+	  break;
+	case 1:
+	  printf (_("16-byte\n"));
+	  break;
+	default:
+	  printf ("??? (%d)\n", val);
+	  break;
+	}
+      return p;
+
+    case Tag_ABI_stack_align_preserved:
+      READ_ULEB (val, p, end);
+      printf ("  Tag_ABI_stack_align_preserved: ");
+      switch (val)
+	{
+	case 0:
+	  printf (_("8-byte\n"));
+	  break;
+	case 1:
+	  printf (_("16-byte\n"));
+	  break;
+	default:
+	  printf ("??? (%d)\n", val);
+	  break;
+	}
+      return p;
+
+    case Tag_ABI_DSBT:
+      READ_ULEB (val, p, end);
+      printf ("  Tag_ABI_DSBT: ");
+      switch (val)
+	{
+	case 0:
+	  printf (_("DSBT addressing not used\n"));
+	  break;
+	case 1:
+	  printf (_("DSBT addressing used\n"));
+	  break;
+	default:
+	  printf ("??? (%d)\n", val);
+	  break;
+	}
+      return p;
+
+    case Tag_ABI_PID:
+      READ_ULEB (val, p, end);
+      printf ("  Tag_ABI_PID: ");
+      switch (val)
+	{
+	case 0:
+	  printf (_("Data addressing position-dependent\n"));
+	  break;
+	case 1:
+	  printf (_("Data addressing position-independent, GOT near DP\n"));
+	  break;
+	case 2:
+	  printf (_("Data addressing position-independent, GOT far from DP\n"));
+	  break;
+	default:
+	  printf ("??? (%d)\n", val);
+	  break;
+	}
+      return p;
+
+    case Tag_ABI_PIC:
+      READ_ULEB (val, p, end);
+      printf ("  Tag_ABI_PIC: ");
+      switch (val)
+	{
+	case 0:
+	  printf (_("Code addressing position-dependent\n"));
+	  break;
+	case 1:
+	  printf (_("Code addressing position-independent\n"));
+	  break;
+	default:
+	  printf ("??? (%d)\n", val);
+	  break;
+	}
+      return p;
+
+    case Tag_ABI_array_object_alignment:
+      READ_ULEB (val, p, end);
+      printf ("  Tag_ABI_array_object_alignment: ");
+      switch (val)
+	{
+	case 0:
+	  printf (_("8-byte\n"));
+	  break;
+	case 1:
+	  printf (_("4-byte\n"));
+	  break;
+	case 2:
+	  printf (_("16-byte\n"));
+	  break;
+	default:
+	  printf ("??? (%d)\n", val);
+	  break;
+	}
+      return p;
+
+    case Tag_ABI_array_object_align_expected:
+      READ_ULEB (val, p, end);
+      printf ("  Tag_ABI_array_object_align_expected: ");
+      switch (val)
+	{
+	case 0:
+	  printf (_("8-byte\n"));
+	  break;
+	case 1:
+	  printf (_("4-byte\n"));
+	  break;
+	case 2:
+	  printf (_("16-byte\n"));
+	  break;
+	default:
+	  printf ("??? (%d)\n", val);
+	  break;
+	}
+      return p;
+
+    case Tag_ABI_compatibility:
+      {
+	READ_ULEB (val, p, end);
+	printf ("  Tag_ABI_compatibility: ");
+	printf (_("flag = %d, vendor = "), val);
+	if (p < end - 1)
+	  {
+	    size_t maxlen = (end - p) - 1;
+
+	    print_symbol ((int) maxlen, (const char *) p);
+	    p += strnlen ((char *) p, maxlen) + 1;
+	  }
+	else
+	  {
+	    printf (_("<corrupt>"));
+	    p = (unsigned char *) end;
+	  }
+	putchar ('\n');
+	return p;
+      }
+
+    case Tag_ABI_conformance:
+      {
+	printf ("  Tag_ABI_conformance: \"");
+	if (p < end - 1)
+	  {
+	    size_t maxlen = (end - p) - 1;
+
+	    print_symbol ((int) maxlen, (const char *) p);
+	    p += strnlen ((char *) p, maxlen) + 1;
+	  }
+	else
+	  {
+	    printf (_("<corrupt>"));
+	    p = (unsigned char *) end;
+	  }
+	printf ("\"\n");
+	return p;
+      }
+    }
+
+  return display_tag_value (tag, p, end);
+}
+
+static void
+display_raw_attribute (unsigned char * p, unsigned char const * const end)
+{
+  unsigned long addr = 0;
+  size_t bytes = end - p;
+
+  assert (end >= p);
+  while (bytes)
+    {
+      int j;
+      int k;
+      int lbytes = (bytes > 16 ? 16 : bytes);
+
+      printf ("  0x%8.8lx ", addr);
+
+      for (j = 0; j < 16; j++)
+	{
+	  if (j < lbytes)
+	    printf ("%2.2x", p[j]);
+	  else
+	    printf ("  ");
+
+	  if ((j & 3) == 3)
+	    printf (" ");
+	}
+
+      for (j = 0; j < lbytes; j++)
+	{
+	  k = p[j];
+	  if (k >= ' ' && k < 0x7f)
+	    printf ("%c", k);
+	  else
+	    printf (".");
+	}
+
+      putchar ('\n');
+
+      p  += lbytes;
+      bytes -= lbytes;
+      addr += lbytes;
+    }
+
+  putchar ('\n');
+}
+
+static unsigned char *
+display_msp430_attribute (unsigned char * p,
+			   const unsigned char * const end)
+{
+  unsigned int val;
+  unsigned int tag;
+
+  READ_ULEB (tag, p, end);
+
+  switch (tag)
+    {
+    case OFBA_MSPABI_Tag_ISA:
+      printf ("  Tag_ISA: ");
+      READ_ULEB (val, p, end);
+      switch (val)
+	{
+	case 0: printf (_("None\n")); break;
+	case 1: printf (_("MSP430\n")); break;
+	case 2: printf (_("MSP430X\n")); break;
+	default: printf ("??? (%d)\n", val); break;
+	}
+      break;
+
+    case OFBA_MSPABI_Tag_Code_Model:
+      printf ("  Tag_Code_Model: ");
+      READ_ULEB (val, p, end);
+      switch (val)
+	{
+	case 0: printf (_("None\n")); break;
+	case 1: printf (_("Small\n")); break;
+	case 2: printf (_("Large\n")); break;
+	default: printf ("??? (%d)\n", val); break;
+	}
+      break;
+
+    case OFBA_MSPABI_Tag_Data_Model:
+      printf ("  Tag_Data_Model: ");
+      READ_ULEB (val, p, end);
+      switch (val)
+	{
+	case 0: printf (_("None\n")); break;
+	case 1: printf (_("Small\n")); break;
+	case 2: printf (_("Large\n")); break;
+	case 3: printf (_("Restricted Large\n")); break;
+	default: printf ("??? (%d)\n", val); break;
+	}
+      break;
+
+    default:
+      printf (_("  <unknown tag %d>: "), tag);
+
+      if (tag & 1)
+	{
+	  putchar ('"');
+	  if (p < end - 1)
+	    {
+	      size_t maxlen = (end - p) - 1;
+
+	      print_symbol ((int) maxlen, (const char *) p);
+	      p += strnlen ((char *) p, maxlen) + 1;
+	    }
+	  else
+	    {
+	      printf (_("<corrupt>"));
+	      p = (unsigned char *) end;
+	    }
+	  printf ("\"\n");
+	}
+      else
+	{
+	  READ_ULEB (val, p, end);
+	  printf ("%d (0x%x)\n", val, val);
+	}
+      break;
+   }
+
+  assert (p <= end);
+  return p;
+}
+
+static unsigned char *
+display_msp430_gnu_attribute (unsigned char * p,
+			      unsigned int tag,
+			      const unsigned char * const end)
+{
+  if (tag == Tag_GNU_MSP430_Data_Region)
+    {
+      unsigned int val;
+
+      printf ("  Tag_GNU_MSP430_Data_Region: ");
+      READ_ULEB (val, p, end);
+
+      switch (val)
+	{
+	case Val_GNU_MSP430_Data_Region_Any:
+	  printf (_("Any Region\n"));
+	  break;
+	case Val_GNU_MSP430_Data_Region_Lower:
+	  printf (_("Lower Region Only\n"));
+	  break;
+	default:
+	  printf ("??? (%u)\n", val);
+	}
+      return p;
+    }
+  return display_tag_value (tag & 1, p, end);
+}
+
+struct riscv_attr_tag_t {
+  const char *name;
+  unsigned int tag;
+};
+
+static struct riscv_attr_tag_t riscv_attr_tag[] =
+{
+#define T(tag) {"Tag_RISCV_" #tag, Tag_RISCV_##tag}
+  T(arch),
+  T(priv_spec),
+  T(priv_spec_minor),
+  T(priv_spec_revision),
+  T(unaligned_access),
+  T(stack_align),
+#undef T
+};
+
+static unsigned char *
+display_riscv_attribute (unsigned char *p,
+			 const unsigned char * const end)
+{
+  unsigned int val;
+  unsigned int tag;
+  struct riscv_attr_tag_t *attr = NULL;
+  unsigned i;
+
+  READ_ULEB (tag, p, end);
+
+  /* Find the name of attribute. */
+  for (i = 0; i < ARRAY_SIZE (riscv_attr_tag); i++)
+    {
+      if (riscv_attr_tag[i].tag == tag)
+	{
+	  attr = &riscv_attr_tag[i];
+	  break;
+	}
+    }
+
+  if (attr)
+    printf ("  %s: ", attr->name);
+  else
+    return display_tag_value (tag, p, end);
+
+  switch (tag)
+    {
+    case Tag_RISCV_priv_spec:
+    case Tag_RISCV_priv_spec_minor:
+    case Tag_RISCV_priv_spec_revision:
+      READ_ULEB (val, p, end);
+      printf (_("%u\n"), val);
+      break;
+    case Tag_RISCV_unaligned_access:
+      READ_ULEB (val, p, end);
+      switch (val)
+	{
+	case 0:
+	  printf (_("No unaligned access\n"));
+	  break;
+	case 1:
+	  printf (_("Unaligned access\n"));
+	  break;
+	}
+      break;
+    case Tag_RISCV_stack_align:
+      READ_ULEB (val, p, end);
+      printf (_("%u-bytes\n"), val);
+      break;
+    case Tag_RISCV_arch:
+      p = display_tag_value (-1, p, end);
+      break;
+    default:
+      return display_tag_value (tag, p, end);
+    }
+
+  return p;
+}
+
+static unsigned char *
+display_csky_attribute (unsigned char * p,
+			const unsigned char * const end)
+{
+  unsigned int tag;
+  unsigned int val;
+  READ_ULEB (tag, p, end);
+
+  if (tag >= Tag_CSKY_MAX)
+    {
+      return display_tag_value (-1, p, end);
+    }
+
+  switch (tag)
+    {
+    case Tag_CSKY_ARCH_NAME:
+      printf ("  Tag_CSKY_ARCH_NAME:\t\t");
+      return display_tag_value (-1, p, end);
+    case Tag_CSKY_CPU_NAME:
+      printf ("  Tag_CSKY_CPU_NAME:\t\t");
+      return display_tag_value (-1, p, end);
+
+    case Tag_CSKY_ISA_FLAGS:
+      printf ("  Tag_CSKY_ISA_FLAGS:\t\t");
+      return display_tag_value (0, p, end);
+    case Tag_CSKY_ISA_EXT_FLAGS:
+      printf ("  Tag_CSKY_ISA_EXT_FLAGS:\t");
+      return display_tag_value (0, p, end);
+
+    case Tag_CSKY_DSP_VERSION:
+      printf ("  Tag_CSKY_DSP_VERSION:\t\t");
+      READ_ULEB (val, p, end);
+      if (val == VAL_CSKY_DSP_VERSION_EXTENSION)
+	printf ("DSP Extension\n");
+      else if (val == VAL_CSKY_DSP_VERSION_2)
+	printf ("DSP 2.0\n");
+      break;
+
+    case Tag_CSKY_VDSP_VERSION:
+      printf ("  Tag_CSKY_VDSP_VERSION:\t");
+      READ_ULEB (val, p, end);
+      printf ("VDSP Version %d\n", val);
+      break;
+
+    case Tag_CSKY_FPU_VERSION:
+      printf ("  Tag_CSKY_FPU_VERSION:\t\t");
+      READ_ULEB (val, p, end);
+      if (val == VAL_CSKY_FPU_VERSION_1)
+	printf ("ABIV1 FPU Version 1\n");
+      else if (val == VAL_CSKY_FPU_VERSION_2)
+	printf ("FPU Version 2\n");
+      break;
+
+    case Tag_CSKY_FPU_ABI:
+      printf ("  Tag_CSKY_FPU_ABI:\t\t");
+      READ_ULEB (val, p, end);
+      if (val == VAL_CSKY_FPU_ABI_HARD)
+	printf ("Hard\n");
+      else if (val == VAL_CSKY_FPU_ABI_SOFTFP)
+	printf ("SoftFP\n");
+      else if (val == VAL_CSKY_FPU_ABI_SOFT)
+	printf ("Soft\n");
+      break;
+    case Tag_CSKY_FPU_ROUNDING:
+      READ_ULEB (val, p, end);
+      if (val == 1) {
+	printf ("  Tag_CSKY_FPU_ROUNDING:\t");
+	printf ("Needed\n");
+      }
+      break;
+    case Tag_CSKY_FPU_DENORMAL:
+      READ_ULEB (val, p, end);
+      if (val == 1) {
+	printf ("  Tag_CSKY_FPU_DENORMAL:\t");
+	printf ("Needed\n");
+      }
+      break;
+    case Tag_CSKY_FPU_Exception:
+      READ_ULEB (val, p, end);
+      if (val == 1) {
+	printf ("  Tag_CSKY_FPU_Exception:\t");
+	printf ("Needed\n");
+      }
+      break;
+    case Tag_CSKY_FPU_NUMBER_MODULE:
+      printf ("  Tag_CSKY_FPU_NUMBER_MODULE:\t");
+      return display_tag_value (-1, p, end);
+    case Tag_CSKY_FPU_HARDFP:
+      printf ("  Tag_CSKY_FPU_HARDFP:\t\t");
+      READ_ULEB (val, p, end);
+      if (val & VAL_CSKY_FPU_HARDFP_HALF)
+	printf (" Half");
+      if (val & VAL_CSKY_FPU_HARDFP_SINGLE)
+	printf (" Single");
+      if (val & VAL_CSKY_FPU_HARDFP_DOUBLE)
+	printf (" Double");
+      printf ("\n");
+      break;
+    default:
+      return display_tag_value (tag, p, end);
+     }
+  return p;
+}
+
+static bool
+process_attributes (Filedata * filedata,
+		    const char * public_name,
+		    unsigned int proc_type,
+		    unsigned char * (* display_pub_attribute) (unsigned char *, const unsigned char * const),
+		    unsigned char * (* display_proc_gnu_attribute) (unsigned char *, unsigned int, const unsigned char * const))
+{
+  Elf_Internal_Shdr * sect;
+  unsigned i;
+  bool res = true;
+
+  /* Find the section header so that we get the size.  */
+  for (i = 0, sect = filedata->section_headers;
+       i < filedata->file_header.e_shnum;
+       i++, sect++)
+    {
+      unsigned char * contents;
+      unsigned char * p;
+
+      if (sect->sh_type != proc_type && sect->sh_type != SHT_GNU_ATTRIBUTES)
+	continue;
+
+      contents = (unsigned char *) get_data (NULL, filedata, sect->sh_offset, 1,
+                                             sect->sh_size, _("attributes"));
+      if (contents == NULL)
+	{
+	  res = false;
+	  continue;
+	}
+
+      p = contents;
+      /* The first character is the version of the attributes.
+	 Currently only version 1, (aka 'A') is recognised here.  */
+      if (*p != 'A')
+	{
+	  printf (_("Unknown attributes version '%c'(%d) - expecting 'A'\n"), *p, *p);
+	  res = false;
+	}
+      else
+	{
+	  bfd_vma section_len;
+
+	  section_len = sect->sh_size - 1;
+	  p++;
+
+	  while (section_len > 0)
+	    {
+	      bfd_vma attr_len;
+	      unsigned int namelen;
+	      bool public_section;
+	      bool gnu_section;
+
+	      if (section_len <= 4)
+		{
+		  error (_("Tag section ends prematurely\n"));
+		  res = false;
+		  break;
+		}
+	      attr_len = byte_get (p, 4);
+	      p += 4;
+
+	      if (attr_len > section_len)
+		{
+		  error (_("Bad attribute length (%u > %u)\n"),
+			  (unsigned) attr_len, (unsigned) section_len);
+		  attr_len = section_len;
+		  res = false;
+		}
+	      /* PR 17531: file: 001-101425-0.004  */
+	      else if (attr_len < 5)
+		{
+		  error (_("Attribute length of %u is too small\n"), (unsigned) attr_len);
+		  res = false;
+		  break;
+		}
+
+	      section_len -= attr_len;
+	      attr_len -= 4;
+
+	      namelen = strnlen ((char *) p, attr_len) + 1;
+	      if (namelen == 0 || namelen >= attr_len)
+		{
+		  error (_("Corrupt attribute section name\n"));
+		  res = false;
+		  break;
+		}
+
+	      printf (_("Attribute Section: "));
+	      print_symbol (INT_MAX, (const char *) p);
+	      putchar ('\n');
+
+	      if (public_name && streq ((char *) p, public_name))
+		public_section = true;
+	      else
+		public_section = false;
+
+	      if (streq ((char *) p, "gnu"))
+		gnu_section = true;
+	      else
+		gnu_section = false;
+
+	      p += namelen;
+	      attr_len -= namelen;
+
+	      while (attr_len > 0 && p < contents + sect->sh_size)
+		{
+		  int tag;
+		  unsigned int val;
+		  bfd_vma size;
+		  unsigned char * end;
+
+		  /* PR binutils/17531: Safe handling of corrupt files.  */
+		  if (attr_len < 6)
+		    {
+		      error (_("Unused bytes at end of section\n"));
+		      res = false;
+		      section_len = 0;
+		      break;
+		    }
+
+		  tag = *(p++);
+		  size = byte_get (p, 4);
+		  if (size > attr_len)
+		    {
+		      error (_("Bad subsection length (%u > %u)\n"),
+			      (unsigned) size, (unsigned) attr_len);
+		      res = false;
+		      size = attr_len;
+		    }
+		  /* PR binutils/17531: Safe handling of corrupt files.  */
+		  if (size < 6)
+		    {
+		      error (_("Bad subsection length (%u < 6)\n"),
+			      (unsigned) size);
+		      res = false;
+		      section_len = 0;
+		      break;
+		    }
+
+		  attr_len -= size;
+		  end = p + size - 1;
+		  assert (end <= contents + sect->sh_size);
+		  p += 4;
+
+		  switch (tag)
+		    {
+		    case 1:
+		      printf (_("File Attributes\n"));
+		      break;
+		    case 2:
+		      printf (_("Section Attributes:"));
+		      goto do_numlist;
+		    case 3:
+		      printf (_("Symbol Attributes:"));
+		      /* Fall through.  */
+		    do_numlist:
+		      for (;;)
+			{
+			  READ_ULEB (val, p, end);
+			  if (val == 0)
+			    break;
+			  printf (" %d", val);
+			}
+		      printf ("\n");
+		      break;
+		    default:
+		      printf (_("Unknown tag: %d\n"), tag);
+		      public_section = false;
+		      break;
+		    }
+
+		  if (public_section && display_pub_attribute != NULL)
+		    {
+		      while (p < end)
+			p = display_pub_attribute (p, end);
+		      assert (p == end);
+		    }
+		  else if (gnu_section && display_proc_gnu_attribute != NULL)
+		    {
+		      while (p < end)
+			p = display_gnu_attribute (p,
+						   display_proc_gnu_attribute,
+						   end);
+		      assert (p == end);
+		    }
+		  else if (p < end)
+		    {
+		      printf (_("  Unknown attribute:\n"));
+		      display_raw_attribute (p, end);
+		      p = end;
+		    }
+		  else
+		    attr_len = 0;
+		}
+	    }
+	}
+
+      free (contents);
+    }
+
+  return res;
+}
+
+/* DATA points to the contents of a MIPS GOT that starts at VMA PLTGOT.
+   Print the Address, Access and Initial fields of an entry at VMA ADDR
+   and return the VMA of the next entry, or -1 if there was a problem.
+   Does not read from DATA_END or beyond.  */
+
+static bfd_vma
+print_mips_got_entry (unsigned char * data, bfd_vma pltgot, bfd_vma addr,
+		      unsigned char * data_end)
+{
+  printf ("  ");
+  print_vma (addr, LONG_HEX);
+  printf (" ");
+  if (addr < pltgot + 0xfff0)
+    printf ("%6d(gp)", (int) (addr - pltgot - 0x7ff0));
+  else
+    printf ("%10s", "");
+  printf (" ");
+  if (data == NULL)
+    printf ("%*s", is_32bit_elf ? 8 : 16, _("<unknown>"));
+  else
+    {
+      bfd_vma entry;
+      unsigned char * from = data + addr - pltgot;
+
+      if (from + (is_32bit_elf ? 4 : 8) > data_end)
+	{
+	  warn (_("MIPS GOT entry extends beyond the end of available data\n"));
+	  printf ("%*s", is_32bit_elf ? 8 : 16, _("<corrupt>"));
+	  return (bfd_vma) -1;
+	}
+      else
+	{
+	  entry = byte_get (data + addr - pltgot, is_32bit_elf ? 4 : 8);
+	  print_vma (entry, LONG_HEX);
+	}
+    }
+  return addr + (is_32bit_elf ? 4 : 8);
+}
+
+/* DATA points to the contents of a MIPS PLT GOT that starts at VMA
+   PLTGOT.  Print the Address and Initial fields of an entry at VMA
+   ADDR and return the VMA of the next entry.  */
+
+static bfd_vma
+print_mips_pltgot_entry (unsigned char * data, bfd_vma pltgot, bfd_vma addr)
+{
+  printf ("  ");
+  print_vma (addr, LONG_HEX);
+  printf (" ");
+  if (data == NULL)
+    printf ("%*s", is_32bit_elf ? 8 : 16, _("<unknown>"));
+  else
+    {
+      bfd_vma entry;
+
+      entry = byte_get (data + addr - pltgot, is_32bit_elf ? 4 : 8);
+      print_vma (entry, LONG_HEX);
+    }
+  return addr + (is_32bit_elf ? 4 : 8);
+}
+
+static void
+print_mips_ases (unsigned int mask)
+{
+  if (mask & AFL_ASE_DSP)
+    fputs ("\n\tDSP ASE", stdout);
+  if (mask & AFL_ASE_DSPR2)
+    fputs ("\n\tDSP R2 ASE", stdout);
+  if (mask & AFL_ASE_DSPR3)
+    fputs ("\n\tDSP R3 ASE", stdout);
+  if (mask & AFL_ASE_EVA)
+    fputs ("\n\tEnhanced VA Scheme", stdout);
+  if (mask & AFL_ASE_MCU)
+    fputs ("\n\tMCU (MicroController) ASE", stdout);
+  if (mask & AFL_ASE_MDMX)
+    fputs ("\n\tMDMX ASE", stdout);
+  if (mask & AFL_ASE_MIPS3D)
+    fputs ("\n\tMIPS-3D ASE", stdout);
+  if (mask & AFL_ASE_MT)
+    fputs ("\n\tMT ASE", stdout);
+  if (mask & AFL_ASE_SMARTMIPS)
+    fputs ("\n\tSmartMIPS ASE", stdout);
+  if (mask & AFL_ASE_VIRT)
+    fputs ("\n\tVZ ASE", stdout);
+  if (mask & AFL_ASE_MSA)
+    fputs ("\n\tMSA ASE", stdout);
+  if (mask & AFL_ASE_MIPS16)
+    fputs ("\n\tMIPS16 ASE", stdout);
+  if (mask & AFL_ASE_MICROMIPS)
+    fputs ("\n\tMICROMIPS ASE", stdout);
+  if (mask & AFL_ASE_XPA)
+    fputs ("\n\tXPA ASE", stdout);
+  if (mask & AFL_ASE_MIPS16E2)
+    fputs ("\n\tMIPS16e2 ASE", stdout);
+  if (mask & AFL_ASE_CRC)
+    fputs ("\n\tCRC ASE", stdout);
+  if (mask & AFL_ASE_GINV)
+    fputs ("\n\tGINV ASE", stdout);
+  if (mask & AFL_ASE_LOONGSON_MMI)
+    fputs ("\n\tLoongson MMI ASE", stdout);
+  if (mask & AFL_ASE_LOONGSON_CAM)
+    fputs ("\n\tLoongson CAM ASE", stdout);
+  if (mask & AFL_ASE_LOONGSON_EXT)
+    fputs ("\n\tLoongson EXT ASE", stdout);
+  if (mask & AFL_ASE_LOONGSON_EXT2)
+    fputs ("\n\tLoongson EXT2 ASE", stdout);
+  if (mask == 0)
+    fprintf (stdout, "\n\t%s", _("None"));
+  else if ((mask & ~AFL_ASE_MASK) != 0)
+    fprintf (stdout, "\n\t%s (%x)", _("Unknown"), mask & ~AFL_ASE_MASK);
+}
+
+static void
+print_mips_isa_ext (unsigned int isa_ext)
+{
+  switch (isa_ext)
+    {
+    case 0:
+      fputs (_("None"), stdout);
+      break;
+    case AFL_EXT_XLR:
+      fputs ("RMI XLR", stdout);
+      break;
+    case AFL_EXT_OCTEON3:
+      fputs ("Cavium Networks Octeon3", stdout);
+      break;
+    case AFL_EXT_OCTEON2:
+      fputs ("Cavium Networks Octeon2", stdout);
+      break;
+    case AFL_EXT_OCTEONP:
+      fputs ("Cavium Networks OcteonP", stdout);
+      break;
+    case AFL_EXT_OCTEON:
+      fputs ("Cavium Networks Octeon", stdout);
+      break;
+    case AFL_EXT_5900:
+      fputs ("Toshiba R5900", stdout);
+      break;
+    case AFL_EXT_4650:
+      fputs ("MIPS R4650", stdout);
+      break;
+    case AFL_EXT_4010:
+      fputs ("LSI R4010", stdout);
+      break;
+    case AFL_EXT_4100:
+      fputs ("NEC VR4100", stdout);
+      break;
+    case AFL_EXT_3900:
+      fputs ("Toshiba R3900", stdout);
+      break;
+    case AFL_EXT_10000:
+      fputs ("MIPS R10000", stdout);
+      break;
+    case AFL_EXT_SB1:
+      fputs ("Broadcom SB-1", stdout);
+      break;
+    case AFL_EXT_4111:
+      fputs ("NEC VR4111/VR4181", stdout);
+      break;
+    case AFL_EXT_4120:
+      fputs ("NEC VR4120", stdout);
+      break;
+    case AFL_EXT_5400:
+      fputs ("NEC VR5400", stdout);
+      break;
+    case AFL_EXT_5500:
+      fputs ("NEC VR5500", stdout);
+      break;
+    case AFL_EXT_LOONGSON_2E:
+      fputs ("ST Microelectronics Loongson 2E", stdout);
+      break;
+    case AFL_EXT_LOONGSON_2F:
+      fputs ("ST Microelectronics Loongson 2F", stdout);
+      break;
+    case AFL_EXT_INTERAPTIV_MR2:
+      fputs ("Imagination interAptiv MR2", stdout);
+      break;
+    default:
+      fprintf (stdout, "%s (%d)", _("Unknown"), isa_ext);
+    }
+}
+
+static signed int
+get_mips_reg_size (int reg_size)
+{
+  return (reg_size == AFL_REG_NONE) ? 0
+	 : (reg_size == AFL_REG_32) ? 32
+	 : (reg_size == AFL_REG_64) ? 64
+	 : (reg_size == AFL_REG_128) ? 128
+	 : -1;
+}
+
+static bool
+process_mips_specific (Filedata * filedata)
+{
+  Elf_Internal_Dyn * entry;
+  Elf_Internal_Shdr *sect = NULL;
+  size_t liblist_offset = 0;
+  size_t liblistno = 0;
+  size_t conflictsno = 0;
+  size_t options_offset = 0;
+  size_t conflicts_offset = 0;
+  size_t pltrelsz = 0;
+  size_t pltrel = 0;
+  bfd_vma pltgot = 0;
+  bfd_vma mips_pltgot = 0;
+  bfd_vma jmprel = 0;
+  bfd_vma local_gotno = 0;
+  bfd_vma gotsym = 0;
+  bfd_vma symtabno = 0;
+  bool res = true;
+
+  if (! process_attributes (filedata, NULL, SHT_GNU_ATTRIBUTES, NULL,
+			    display_mips_gnu_attribute))
+    res = false;
+
+  sect = find_section (filedata, ".MIPS.abiflags");
+
+  if (sect != NULL)
+    {
+      Elf_External_ABIFlags_v0 *abiflags_ext;
+      Elf_Internal_ABIFlags_v0 abiflags_in;
+
+      if (sizeof (Elf_External_ABIFlags_v0) != sect->sh_size)
+	{
+	  error (_("Corrupt MIPS ABI Flags section.\n"));
+	  res = false;
+	}
+      else
+	{
+	  abiflags_ext = get_data (NULL, filedata, sect->sh_offset, 1,
+				   sect->sh_size, _("MIPS ABI Flags section"));
+	  if (abiflags_ext)
+	    {
+	      abiflags_in.version = BYTE_GET (abiflags_ext->version);
+	      abiflags_in.isa_level = BYTE_GET (abiflags_ext->isa_level);
+	      abiflags_in.isa_rev = BYTE_GET (abiflags_ext->isa_rev);
+	      abiflags_in.gpr_size = BYTE_GET (abiflags_ext->gpr_size);
+	      abiflags_in.cpr1_size = BYTE_GET (abiflags_ext->cpr1_size);
+	      abiflags_in.cpr2_size = BYTE_GET (abiflags_ext->cpr2_size);
+	      abiflags_in.fp_abi = BYTE_GET (abiflags_ext->fp_abi);
+	      abiflags_in.isa_ext = BYTE_GET (abiflags_ext->isa_ext);
+	      abiflags_in.ases = BYTE_GET (abiflags_ext->ases);
+	      abiflags_in.flags1 = BYTE_GET (abiflags_ext->flags1);
+	      abiflags_in.flags2 = BYTE_GET (abiflags_ext->flags2);
+
+	      printf ("\nMIPS ABI Flags Version: %d\n", abiflags_in.version);
+	      printf ("\nISA: MIPS%d", abiflags_in.isa_level);
+	      if (abiflags_in.isa_rev > 1)
+		printf ("r%d", abiflags_in.isa_rev);
+	      printf ("\nGPR size: %d",
+		      get_mips_reg_size (abiflags_in.gpr_size));
+	      printf ("\nCPR1 size: %d",
+		      get_mips_reg_size (abiflags_in.cpr1_size));
+	      printf ("\nCPR2 size: %d",
+		      get_mips_reg_size (abiflags_in.cpr2_size));
+	      fputs ("\nFP ABI: ", stdout);
+	      print_mips_fp_abi_value (abiflags_in.fp_abi);
+	      fputs ("ISA Extension: ", stdout);
+	      print_mips_isa_ext (abiflags_in.isa_ext);
+	      fputs ("\nASEs:", stdout);
+	      print_mips_ases (abiflags_in.ases);
+	      printf ("\nFLAGS 1: %8.8lx", abiflags_in.flags1);
+	      printf ("\nFLAGS 2: %8.8lx", abiflags_in.flags2);
+	      fputc ('\n', stdout);
+	      free (abiflags_ext);
+	    }
+	}
+    }
+
+  /* We have a lot of special sections.  Thanks SGI!  */
+  if (filedata->dynamic_section == NULL)
+    {
+      /* No dynamic information available.  See if there is static GOT.  */
+      sect = find_section (filedata, ".got");
+      if (sect != NULL)
+	{
+	  unsigned char *data_end;
+	  unsigned char *data;
+	  bfd_vma ent, end;
+	  int addr_size;
+
+	  pltgot = sect->sh_addr;
+
+	  ent = pltgot;
+	  addr_size = (is_32bit_elf ? 4 : 8);
+	  end = pltgot + sect->sh_size;
+
+	  data = (unsigned char *) get_data (NULL, filedata, sect->sh_offset,
+					     end - pltgot, 1,
+					     _("Global Offset Table data"));
+	  /* PR 12855: Null data is handled gracefully throughout.  */
+	  data_end = data + (end - pltgot);
+
+	  printf (_("\nStatic GOT:\n"));
+	  printf (_(" Canonical gp value: "));
+	  print_vma (ent + 0x7ff0, LONG_HEX);
+	  printf ("\n\n");
+
+	  /* In a dynamic binary GOT[0] is reserved for the dynamic
+	     loader to store the lazy resolver pointer, however in
+	     a static binary it may well have been omitted and GOT
+	     reduced to a table of addresses.
+	     PR 21344: Check for the entry being fully available
+	     before fetching it.  */
+	  if (data
+	      && data + ent - pltgot + addr_size <= data_end
+	      && byte_get (data + ent - pltgot, addr_size) == 0)
+	    {
+	      printf (_(" Reserved entries:\n"));
+	      printf (_("  %*s %10s %*s\n"),
+		      addr_size * 2, _("Address"), _("Access"),
+		      addr_size * 2, _("Value"));
+	      ent = print_mips_got_entry (data, pltgot, ent, data_end);
+	      printf ("\n");
+	      if (ent == (bfd_vma) -1)
+		goto sgot_print_fail;
+
+	      /* Check for the MSB of GOT[1] being set, identifying a
+		 GNU object.  This entry will be used by some runtime
+		 loaders, to store the module pointer.  Otherwise this
+		 is an ordinary local entry.
+		 PR 21344: Check for the entry being fully available
+		 before fetching it.  */
+	      if (data
+		  && data + ent - pltgot + addr_size <= data_end
+		  && (byte_get (data + ent - pltgot, addr_size)
+		      >> (addr_size * 8 - 1)) != 0)
+		{
+		  ent = print_mips_got_entry (data, pltgot, ent, data_end);
+		  printf ("\n");
+		  if (ent == (bfd_vma) -1)
+		    goto sgot_print_fail;
+		}
+	      printf ("\n");
+	    }
+
+	  if (data != NULL && ent < end)
+	    {
+	      printf (_(" Local entries:\n"));
+	      printf ("  %*s %10s %*s\n",
+		      addr_size * 2, _("Address"), _("Access"),
+		      addr_size * 2, _("Value"));
+	      while (ent < end)
+		{
+		  ent = print_mips_got_entry (data, pltgot, ent, data_end);
+		  printf ("\n");
+		  if (ent == (bfd_vma) -1)
+		    goto sgot_print_fail;
+		}
+	      printf ("\n");
+	    }
+
+	sgot_print_fail:
+	  free (data);
+	}
+      return res;
+    }
+
+  for (entry = filedata->dynamic_section;
+       /* PR 17531 file: 012-50589-0.004.  */
+       (entry < filedata->dynamic_section + filedata->dynamic_nent
+	&& entry->d_tag != DT_NULL);
+       ++entry)
+    switch (entry->d_tag)
+      {
+      case DT_MIPS_LIBLIST:
+	liblist_offset
+	  = offset_from_vma (filedata, entry->d_un.d_val,
+			     liblistno * sizeof (Elf32_External_Lib));
+	break;
+      case DT_MIPS_LIBLISTNO:
+	liblistno = entry->d_un.d_val;
+	break;
+      case DT_MIPS_OPTIONS:
+	options_offset = offset_from_vma (filedata, entry->d_un.d_val, 0);
+	break;
+      case DT_MIPS_CONFLICT:
+	conflicts_offset
+	  = offset_from_vma (filedata, entry->d_un.d_val,
+			     conflictsno * sizeof (Elf32_External_Conflict));
+	break;
+      case DT_MIPS_CONFLICTNO:
+	conflictsno = entry->d_un.d_val;
+	break;
+      case DT_PLTGOT:
+	pltgot = entry->d_un.d_ptr;
+	break;
+      case DT_MIPS_LOCAL_GOTNO:
+	local_gotno = entry->d_un.d_val;
+	break;
+      case DT_MIPS_GOTSYM:
+	gotsym = entry->d_un.d_val;
+	break;
+      case DT_MIPS_SYMTABNO:
+	symtabno = entry->d_un.d_val;
+	break;
+      case DT_MIPS_PLTGOT:
+	mips_pltgot = entry->d_un.d_ptr;
+	break;
+      case DT_PLTREL:
+	pltrel = entry->d_un.d_val;
+	break;
+      case DT_PLTRELSZ:
+	pltrelsz = entry->d_un.d_val;
+	break;
+      case DT_JMPREL:
+	jmprel = entry->d_un.d_ptr;
+	break;
+      default:
+	break;
+      }
+
+  if (liblist_offset != 0 && liblistno != 0 && do_dynamic)
+    {
+      Elf32_External_Lib * elib;
+      size_t cnt;
+
+      elib = (Elf32_External_Lib *) get_data (NULL, filedata, liblist_offset,
+					      sizeof (Elf32_External_Lib),
+					      liblistno,
+					      _("liblist section data"));
+      if (elib)
+	{
+	  printf (ngettext ("\nSection '.liblist' contains %lu entry:\n",
+			    "\nSection '.liblist' contains %lu entries:\n",
+			    (unsigned long) liblistno),
+		  (unsigned long) liblistno);
+	  fputs (_("     Library              Time Stamp          Checksum   Version Flags\n"),
+		 stdout);
+
+	  for (cnt = 0; cnt < liblistno; ++cnt)
+	    {
+	      Elf32_Lib liblist;
+	      time_t atime;
+	      char timebuf[128];
+	      struct tm * tmp;
+
+	      liblist.l_name = BYTE_GET (elib[cnt].l_name);
+	      atime = BYTE_GET (elib[cnt].l_time_stamp);
+	      liblist.l_checksum = BYTE_GET (elib[cnt].l_checksum);
+	      liblist.l_version = BYTE_GET (elib[cnt].l_version);
+	      liblist.l_flags = BYTE_GET (elib[cnt].l_flags);
+
+	      tmp = gmtime (&atime);
+	      snprintf (timebuf, sizeof (timebuf),
+			"%04u-%02u-%02uT%02u:%02u:%02u",
+			tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
+			tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
+
+	      printf ("%3lu: ", (unsigned long) cnt);
+	      if (VALID_DYNAMIC_NAME (filedata, liblist.l_name))
+		print_symbol (20, GET_DYNAMIC_NAME (filedata, liblist.l_name));
+	      else
+		printf (_("<corrupt: %9ld>"), liblist.l_name);
+	      printf (" %s %#10lx %-7ld", timebuf, liblist.l_checksum,
+		      liblist.l_version);
+
+	      if (liblist.l_flags == 0)
+		puts (_(" NONE"));
+	      else
+		{
+		  static const struct
+		  {
+		    const char * name;
+		    int bit;
+		  }
+		  l_flags_vals[] =
+		  {
+		    { " EXACT_MATCH", LL_EXACT_MATCH },
+		    { " IGNORE_INT_VER", LL_IGNORE_INT_VER },
+		    { " REQUIRE_MINOR", LL_REQUIRE_MINOR },
+		    { " EXPORTS", LL_EXPORTS },
+		    { " DELAY_LOAD", LL_DELAY_LOAD },
+		    { " DELTA", LL_DELTA }
+		  };
+		  int flags = liblist.l_flags;
+		  size_t fcnt;
+
+		  for (fcnt = 0; fcnt < ARRAY_SIZE (l_flags_vals); ++fcnt)
+		    if ((flags & l_flags_vals[fcnt].bit) != 0)
+		      {
+			fputs (l_flags_vals[fcnt].name, stdout);
+			flags ^= l_flags_vals[fcnt].bit;
+		      }
+		  if (flags != 0)
+		    printf (" %#x", (unsigned int) flags);
+
+		  puts ("");
+		}
+	    }
+
+	  free (elib);
+	}
+      else
+	res = false;
+    }
+
+  if (options_offset != 0)
+    {
+      Elf_External_Options * eopt;
+      size_t offset;
+      int cnt;
+      sect = filedata->section_headers;
+
+      /* Find the section header so that we get the size.  */
+      sect = find_section_by_type (filedata, SHT_MIPS_OPTIONS);
+      /* PR 17533 file: 012-277276-0.004.  */
+      if (sect == NULL)
+	{
+	  error (_("No MIPS_OPTIONS header found\n"));
+	  return false;
+	}
+      /* PR 24243  */
+      if (sect->sh_size < sizeof (* eopt))
+	{
+	  error (_("The MIPS options section is too small.\n"));
+	  return false;
+	}
+
+      eopt = (Elf_External_Options *) get_data (NULL, filedata, options_offset, 1,
+                                                sect->sh_size, _("options"));
+      if (eopt)
+	{
+	  Elf_Internal_Options option;
+
+	  offset = cnt = 0;
+	  while (offset <= sect->sh_size - sizeof (* eopt))
+	    {
+	      Elf_External_Options * eoption;
+	      unsigned int optsize;
+
+	      eoption = (Elf_External_Options *) ((char *) eopt + offset);
+
+	      optsize = BYTE_GET (eoption->size);
+
+	      /* PR 17531: file: ffa0fa3b.  */
+	      if (optsize < sizeof (* eopt)
+		  || optsize > sect->sh_size - offset)
+		{
+		  error (_("Invalid size (%u) for MIPS option\n"),
+			 optsize);
+		  free (eopt);
+		  return false;
+		}
+	      offset += optsize;
+	      ++cnt;
+	    }
+
+	  printf (ngettext ("\nSection '%s' contains %d entry:\n",
+			    "\nSection '%s' contains %d entries:\n",
+			    cnt),
+		  printable_section_name (filedata, sect), cnt);
+
+	  offset = 0;
+	  while (cnt-- > 0)
+	    {
+	      size_t len;
+	      Elf_External_Options * eoption;
+
+	      eoption = (Elf_External_Options *) ((char *) eopt + offset);
+
+	      option.kind = BYTE_GET (eoption->kind);
+	      option.size = BYTE_GET (eoption->size);
+	      option.section = BYTE_GET (eoption->section);
+	      option.info = BYTE_GET (eoption->info);
+
+	      switch (option.kind)
+		{
+		case ODK_NULL:
+		  /* This shouldn't happen.  */
+		  printf (" NULL       %" PRId16 " %" PRIx32,
+			  option.section, option.info);
+		  break;
+
+		case ODK_REGINFO:
+		  printf (" REGINFO    ");
+		  if (filedata->file_header.e_machine == EM_MIPS)
+		    {
+		      Elf32_External_RegInfo * ereg;
+		      Elf32_RegInfo reginfo;
+
+		      /* 32bit form.  */
+		      if (option.size < (sizeof (Elf_External_Options)
+					 + sizeof (Elf32_External_RegInfo)))
+			{
+			  printf (_("<corrupt>\n"));
+			  error (_("Truncated MIPS REGINFO option\n"));
+			  cnt = 0;
+			  break;
+			}
+
+		      ereg = (Elf32_External_RegInfo *) (eoption + 1);
+
+		      reginfo.ri_gprmask = BYTE_GET (ereg->ri_gprmask);
+		      reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]);
+		      reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]);
+		      reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]);
+		      reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]);
+		      reginfo.ri_gp_value = BYTE_GET (ereg->ri_gp_value);
+
+		      printf ("GPR %08" PRIx32 "  GP 0x%" PRIx32 "\n",
+			      reginfo.ri_gprmask, reginfo.ri_gp_value);
+		      printf ("          "
+			      "  CPR0 %08" PRIx32 "  CPR1 %08" PRIx32
+			      "  CPR2 %08" PRIx32 "  CPR3 %08" PRIx32 "\n",
+			      reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],
+			      reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);
+		    }
+		  else
+		    {
+		      /* 64 bit form.  */
+		      Elf64_External_RegInfo * ereg;
+		      Elf64_Internal_RegInfo reginfo;
+
+		      if (option.size < (sizeof (Elf_External_Options)
+					 + sizeof (Elf64_External_RegInfo)))
+			{
+			  printf (_("<corrupt>\n"));
+			  error (_("Truncated MIPS REGINFO option\n"));
+			  cnt = 0;
+			  break;
+			}
+
+		      ereg = (Elf64_External_RegInfo *) (eoption + 1);
+		      reginfo.ri_gprmask    = BYTE_GET (ereg->ri_gprmask);
+		      reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]);
+		      reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]);
+		      reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]);
+		      reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]);
+		      reginfo.ri_gp_value   = BYTE_GET (ereg->ri_gp_value);
+
+		      printf ("GPR %08" PRIx32 "  GP 0x%" PRIx64 "\n",
+			      reginfo.ri_gprmask, reginfo.ri_gp_value);
+		      printf ("          "
+			      "  CPR0 %08" PRIx32 "  CPR1 %08" PRIx32
+			      "  CPR2 %08" PRIx32 "  CPR3 %08" PRIx32 "\n",
+			      reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],
+			      reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);
+		    }
+		  offset += option.size;
+		  continue;
+
+		case ODK_EXCEPTIONS:
+		  fputs (" EXCEPTIONS fpe_min(", stdout);
+		  process_mips_fpe_exception (option.info & OEX_FPU_MIN);
+		  fputs (") fpe_max(", stdout);
+		  process_mips_fpe_exception ((option.info & OEX_FPU_MAX) >> 8);
+		  fputs (")", stdout);
+
+		  if (option.info & OEX_PAGE0)
+		    fputs (" PAGE0", stdout);
+		  if (option.info & OEX_SMM)
+		    fputs (" SMM", stdout);
+		  if (option.info & OEX_FPDBUG)
+		    fputs (" FPDBUG", stdout);
+		  if (option.info & OEX_DISMISS)
+		    fputs (" DISMISS", stdout);
+		  break;
+
+		case ODK_PAD:
+		  fputs (" PAD       ", stdout);
+		  if (option.info & OPAD_PREFIX)
+		    fputs (" PREFIX", stdout);
+		  if (option.info & OPAD_POSTFIX)
+		    fputs (" POSTFIX", stdout);
+		  if (option.info & OPAD_SYMBOL)
+		    fputs (" SYMBOL", stdout);
+		  break;
+
+		case ODK_HWPATCH:
+		  fputs (" HWPATCH   ", stdout);
+		  if (option.info & OHW_R4KEOP)
+		    fputs (" R4KEOP", stdout);
+		  if (option.info & OHW_R8KPFETCH)
+		    fputs (" R8KPFETCH", stdout);
+		  if (option.info & OHW_R5KEOP)
+		    fputs (" R5KEOP", stdout);
+		  if (option.info & OHW_R5KCVTL)
+		    fputs (" R5KCVTL", stdout);
+		  break;
+
+		case ODK_FILL:
+		  fputs (" FILL       ", stdout);
+		  /* XXX Print content of info word?  */
+		  break;
+
+		case ODK_TAGS:
+		  fputs (" TAGS       ", stdout);
+		  /* XXX Print content of info word?  */
+		  break;
+
+		case ODK_HWAND:
+		  fputs (" HWAND     ", stdout);
+		  if (option.info & OHWA0_R4KEOP_CHECKED)
+		    fputs (" R4KEOP_CHECKED", stdout);
+		  if (option.info & OHWA0_R4KEOP_CLEAN)
+		    fputs (" R4KEOP_CLEAN", stdout);
+		  break;
+
+		case ODK_HWOR:
+		  fputs (" HWOR      ", stdout);
+		  if (option.info & OHWA0_R4KEOP_CHECKED)
+		    fputs (" R4KEOP_CHECKED", stdout);
+		  if (option.info & OHWA0_R4KEOP_CLEAN)
+		    fputs (" R4KEOP_CLEAN", stdout);
+		  break;
+
+		case ODK_GP_GROUP:
+		  printf (" GP_GROUP  %#06x  self-contained %#06x",
+			  option.info & OGP_GROUP,
+			  (option.info & OGP_SELF) >> 16);
+		  break;
+
+		case ODK_IDENT:
+		  printf (" IDENT     %#06x  self-contained %#06x",
+			  option.info & OGP_GROUP,
+			  (option.info & OGP_SELF) >> 16);
+		  break;
+
+		default:
+		  /* This shouldn't happen.  */
+		  printf (" %3d ???     %" PRId16 " %" PRIx32,
+			  option.kind, option.section, option.info);
+		  break;
+		}
+
+	      len = sizeof (* eopt);
+	      while (len < option.size)
+		{
+		  unsigned char datum = *((unsigned char *) eoption + len);
+
+		  if (ISPRINT (datum))
+		    printf ("%c", datum);
+		  else
+		    printf ("\\%03o", datum);
+		  len ++;
+		}
+	      fputs ("\n", stdout);
+
+	      offset += option.size;
+	    }
+	  free (eopt);
+	}
+      else
+	res = false;
+    }
+
+  if (conflicts_offset != 0 && conflictsno != 0)
+    {
+      Elf32_Conflict * iconf;
+      size_t cnt;
+
+      if (filedata->dynamic_symbols == NULL)
+	{
+	  error (_("conflict list found without a dynamic symbol table\n"));
+	  return false;
+	}
+
+      /* PR 21345 - print a slightly more helpful error message
+	 if we are sure that the cmalloc will fail.  */
+      if (conflictsno > filedata->file_size / sizeof (* iconf))
+	{
+	  error (_("Overlarge number of conflicts detected: %lx\n"),
+		 (long) conflictsno);
+	  return false;
+	}
+
+      iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));
+      if (iconf == NULL)
+	{
+	  error (_("Out of memory allocating space for dynamic conflicts\n"));
+	  return false;
+	}
+
+      if (is_32bit_elf)
+	{
+	  Elf32_External_Conflict * econf32;
+
+	  econf32 = (Elf32_External_Conflict *)
+	    get_data (NULL, filedata, conflicts_offset,
+		      sizeof (*econf32), conflictsno, _("conflict"));
+	  if (!econf32)
+	    {
+	      free (iconf);
+	      return false;
+	    }
+
+	  for (cnt = 0; cnt < conflictsno; ++cnt)
+	    iconf[cnt] = BYTE_GET (econf32[cnt]);
+
+	  free (econf32);
+	}
+      else
+	{
+	  Elf64_External_Conflict * econf64;
+
+	  econf64 = (Elf64_External_Conflict *)
+	    get_data (NULL, filedata, conflicts_offset,
+		      sizeof (*econf64), conflictsno, _("conflict"));
+	  if (!econf64)
+	    {
+	      free (iconf);
+	      return false;
+	    }
+
+	  for (cnt = 0; cnt < conflictsno; ++cnt)
+	    iconf[cnt] = BYTE_GET (econf64[cnt]);
+
+	  free (econf64);
+	}
+
+      printf (ngettext ("\nSection '.conflict' contains %lu entry:\n",
+			"\nSection '.conflict' contains %lu entries:\n",
+			(unsigned long) conflictsno),
+	      (unsigned long) conflictsno);
+      puts (_("  Num:    Index       Value  Name"));
+
+      for (cnt = 0; cnt < conflictsno; ++cnt)
+	{
+	  printf ("%5lu: %8lu  ", (unsigned long) cnt, iconf[cnt]);
+
+	  if (iconf[cnt] >= filedata->num_dynamic_syms)
+	    printf (_("<corrupt symbol index>"));
+	  else
+	    {
+	      Elf_Internal_Sym * psym;
+
+	      psym = & filedata->dynamic_symbols[iconf[cnt]];
+	      print_vma (psym->st_value, FULL_HEX);
+	      putchar (' ');
+	      if (VALID_DYNAMIC_NAME (filedata, psym->st_name))
+		print_symbol (25, GET_DYNAMIC_NAME (filedata, psym->st_name));
+	      else
+		printf (_("<corrupt: %14ld>"), psym->st_name);
+	    }
+	  putchar ('\n');
+	}
+
+      free (iconf);
+    }
+
+  if (pltgot != 0 && local_gotno != 0)
+    {
+      bfd_vma ent, local_end, global_end;
+      size_t i, offset;
+      unsigned char * data;
+      unsigned char * data_end;
+      int addr_size;
+
+      ent = pltgot;
+      addr_size = (is_32bit_elf ? 4 : 8);
+      local_end = pltgot + local_gotno * addr_size;
+
+      /* PR binutils/17533 file: 012-111227-0.004  */
+      if (symtabno < gotsym)
+	{
+	  error (_("The GOT symbol offset (%lu) is greater than the symbol table size (%lu)\n"),
+		 (unsigned long) gotsym, (unsigned long) symtabno);
+	  return false;
+	}
+
+      global_end = local_end + (symtabno - gotsym) * addr_size;
+      /* PR 17531: file: 54c91a34.  */
+      if (global_end < local_end)
+	{
+	  error (_("Too many GOT symbols: %lu\n"), (unsigned long) symtabno);
+	  return false;
+	}
+
+      offset = offset_from_vma (filedata, pltgot, global_end - pltgot);
+      data = (unsigned char *) get_data (NULL, filedata, offset,
+                                         global_end - pltgot, 1,
+					 _("Global Offset Table data"));
+      /* PR 12855: Null data is handled gracefully throughout.  */
+      data_end = data + (global_end - pltgot);
+
+      printf (_("\nPrimary GOT:\n"));
+      printf (_(" Canonical gp value: "));
+      print_vma (pltgot + 0x7ff0, LONG_HEX);
+      printf ("\n\n");
+
+      printf (_(" Reserved entries:\n"));
+      printf (_("  %*s %10s %*s Purpose\n"),
+	      addr_size * 2, _("Address"), _("Access"),
+	      addr_size * 2, _("Initial"));
+      ent = print_mips_got_entry (data, pltgot, ent, data_end);
+      printf (_(" Lazy resolver\n"));
+      if (ent == (bfd_vma) -1)
+	goto got_print_fail;
+
+      /* Check for the MSB of GOT[1] being set, denoting a GNU object.
+	 This entry will be used by some runtime loaders, to store the
+	 module pointer.  Otherwise this is an ordinary local entry.
+	 PR 21344: Check for the entry being fully available before
+	 fetching it.  */
+      if (data
+	  && data + ent - pltgot + addr_size <= data_end
+	  && (byte_get (data + ent - pltgot, addr_size)
+	      >> (addr_size * 8 - 1)) != 0)
+	{
+	  ent = print_mips_got_entry (data, pltgot, ent, data_end);
+	  printf (_(" Module pointer (GNU extension)\n"));
+	  if (ent == (bfd_vma) -1)
+	    goto got_print_fail;
+	}
+      printf ("\n");
+
+      if (data != NULL && ent < local_end)
+	{
+	  printf (_(" Local entries:\n"));
+	  printf ("  %*s %10s %*s\n",
+		  addr_size * 2, _("Address"), _("Access"),
+		  addr_size * 2, _("Initial"));
+	  while (ent < local_end)
+	    {
+	      ent = print_mips_got_entry (data, pltgot, ent, data_end);
+	      printf ("\n");
+	      if (ent == (bfd_vma) -1)
+		goto got_print_fail;
+	    }
+	  printf ("\n");
+	}
+
+      if (data != NULL && gotsym < symtabno)
+	{
+	  int sym_width;
+
+	  printf (_(" Global entries:\n"));
+	  printf ("  %*s %10s %*s %*s %-7s %3s %s\n",
+		  addr_size * 2, _("Address"),
+		  _("Access"),
+		  addr_size * 2, _("Initial"),
+		  addr_size * 2, _("Sym.Val."),
+		  _("Type"),
+		  /* Note for translators: "Ndx" = abbreviated form of "Index".  */
+		  _("Ndx"), _("Name"));
+
+	  sym_width = (is_32bit_elf ? 80 : 160) - 28 - addr_size * 6 - 1;
+
+	  for (i = gotsym; i < symtabno; i++)
+	    {
+	      ent = print_mips_got_entry (data, pltgot, ent, data_end);
+	      printf (" ");
+
+	      if (filedata->dynamic_symbols == NULL)
+		printf (_("<no dynamic symbols>"));
+	      else if (i < filedata->num_dynamic_syms)
+		{
+		  Elf_Internal_Sym * psym = filedata->dynamic_symbols + i;
+
+		  print_vma (psym->st_value, LONG_HEX);
+		  printf (" %-7s %3s ",
+			  get_symbol_type (filedata, ELF_ST_TYPE (psym->st_info)),
+			  get_symbol_index_type (filedata, psym->st_shndx));
+
+		  if (VALID_DYNAMIC_NAME (filedata, psym->st_name))
+		    print_symbol (sym_width,
+				  GET_DYNAMIC_NAME (filedata, psym->st_name));
+		  else
+		    printf (_("<corrupt: %14ld>"), psym->st_name);
+		}
+	      else
+		printf (_("<symbol index %lu exceeds number of dynamic symbols>"),
+			(unsigned long) i);
+
+	      printf ("\n");
+	      if (ent == (bfd_vma) -1)
+		break;
+	    }
+	  printf ("\n");
+	}
+
+    got_print_fail:
+      free (data);
+    }
+
+  if (mips_pltgot != 0 && jmprel != 0 && pltrel != 0 && pltrelsz != 0)
+    {
+      bfd_vma ent, end;
+      size_t offset, rel_offset;
+      unsigned long count, i;
+      unsigned char * data;
+      int addr_size, sym_width;
+      Elf_Internal_Rela * rels;
+
+      rel_offset = offset_from_vma (filedata, jmprel, pltrelsz);
+      if (pltrel == DT_RELA)
+	{
+	  if (!slurp_rela_relocs (filedata, rel_offset, pltrelsz, &rels, &count))
+	    return false;
+	}
+      else
+	{
+	  if (!slurp_rel_relocs (filedata, rel_offset, pltrelsz, &rels, &count))
+	    return false;
+	}
+
+      ent = mips_pltgot;
+      addr_size = (is_32bit_elf ? 4 : 8);
+      end = mips_pltgot + (2 + count) * addr_size;
+
+      offset = offset_from_vma (filedata, mips_pltgot, end - mips_pltgot);
+      data = (unsigned char *) get_data (NULL, filedata, offset, end - mips_pltgot,
+                                         1, _("Procedure Linkage Table data"));
+      if (data == NULL)
+	{
+	  free (rels);
+	  return false;
+	}
+
+      printf ("\nPLT GOT:\n\n");
+      printf (_(" Reserved entries:\n"));
+      printf (_("  %*s %*s Purpose\n"),
+	      addr_size * 2, _("Address"), addr_size * 2, _("Initial"));
+      ent = print_mips_pltgot_entry (data, mips_pltgot, ent);
+      printf (_(" PLT lazy resolver\n"));
+      ent = print_mips_pltgot_entry (data, mips_pltgot, ent);
+      printf (_(" Module pointer\n"));
+      printf ("\n");
+
+      printf (_(" Entries:\n"));
+      printf ("  %*s %*s %*s %-7s %3s %s\n",
+	      addr_size * 2, _("Address"),
+	      addr_size * 2, _("Initial"),
+	      addr_size * 2, _("Sym.Val."), _("Type"), _("Ndx"), _("Name"));
+      sym_width = (is_32bit_elf ? 80 : 160) - 17 - addr_size * 6 - 1;
+      for (i = 0; i < count; i++)
+	{
+	  unsigned long idx = get_reloc_symindex (rels[i].r_info);
+
+	  ent = print_mips_pltgot_entry (data, mips_pltgot, ent);
+	  printf (" ");
+
+	  if (idx >= filedata->num_dynamic_syms)
+	    printf (_("<corrupt symbol index: %lu>"), idx);
+	  else
+	    {
+	      Elf_Internal_Sym * psym = filedata->dynamic_symbols + idx;
+
+	      print_vma (psym->st_value, LONG_HEX);
+	      printf (" %-7s %3s ",
+		      get_symbol_type (filedata, ELF_ST_TYPE (psym->st_info)),
+		      get_symbol_index_type (filedata, psym->st_shndx));
+	      if (VALID_DYNAMIC_NAME (filedata, psym->st_name))
+		print_symbol (sym_width,
+			      GET_DYNAMIC_NAME (filedata, psym->st_name));
+	      else
+		printf (_("<corrupt: %14ld>"), psym->st_name);
+	    }
+	  printf ("\n");
+	}
+      printf ("\n");
+
+      free (data);
+      free (rels);
+    }
+
+  return res;
+}
+
+static bool
+process_nds32_specific (Filedata * filedata)
+{
+  Elf_Internal_Shdr *sect = NULL;
+
+  sect = find_section (filedata, ".nds32_e_flags");
+  if (sect != NULL && sect->sh_size >= 4)
+    {
+      unsigned char *buf;
+      unsigned int flag;
+
+      printf ("\nNDS32 elf flags section:\n");
+      buf = get_data (NULL, filedata, sect->sh_offset, 1, 4,
+		      _("NDS32 elf flags section"));
+
+      if (buf == NULL)
+	return false;
+
+      flag = byte_get (buf, 4);
+      free (buf);
+      switch (flag & 0x3)
+	{
+	case 0:
+	  printf ("(VEC_SIZE):\tNo entry.\n");
+	  break;
+	case 1:
+	  printf ("(VEC_SIZE):\t4 bytes\n");
+	  break;
+	case 2:
+	  printf ("(VEC_SIZE):\t16 bytes\n");
+	  break;
+	case 3:
+	  printf ("(VEC_SIZE):\treserved\n");
+	  break;
+	}
+    }
+
+  return true;
+}
+
+static bool
+process_gnu_liblist (Filedata * filedata)
+{
+  Elf_Internal_Shdr * section;
+  Elf_Internal_Shdr * string_sec;
+  Elf32_External_Lib * elib;
+  char * strtab;
+  size_t strtab_size;
+  size_t cnt;
+  unsigned long num_liblist;
+  unsigned i;
+  bool res = true;
+
+  if (! do_arch)
+    return true;
+
+  for (i = 0, section = filedata->section_headers;
+       i < filedata->file_header.e_shnum;
+       i++, section++)
+    {
+      switch (section->sh_type)
+	{
+	case SHT_GNU_LIBLIST:
+	  if (section->sh_link >= filedata->file_header.e_shnum)
+	    break;
+
+	  elib = (Elf32_External_Lib *)
+              get_data (NULL, filedata, section->sh_offset, 1, section->sh_size,
+                        _("liblist section data"));
+
+	  if (elib == NULL)
+	    {
+	      res = false;
+	      break;
+	    }
+
+	  string_sec = filedata->section_headers + section->sh_link;
+	  strtab = (char *) get_data (NULL, filedata, string_sec->sh_offset, 1,
+                                      string_sec->sh_size,
+                                      _("liblist string table"));
+	  if (strtab == NULL
+	      || section->sh_entsize != sizeof (Elf32_External_Lib))
+	    {
+	      free (elib);
+	      free (strtab);
+	      res = false;
+	      break;
+	    }
+	  strtab_size = string_sec->sh_size;
+
+	  num_liblist = section->sh_size / sizeof (Elf32_External_Lib);
+	  printf (ngettext ("\nLibrary list section '%s' contains %lu entries:\n",
+			    "\nLibrary list section '%s' contains %lu entries:\n",
+			    num_liblist),
+		  printable_section_name (filedata, section),
+		  num_liblist);
+
+	  puts (_("     Library              Time Stamp          Checksum   Version Flags"));
+
+	  for (cnt = 0; cnt < section->sh_size / sizeof (Elf32_External_Lib);
+	       ++cnt)
+	    {
+	      Elf32_Lib liblist;
+	      time_t atime;
+	      char timebuf[128];
+	      struct tm * tmp;
+
+	      liblist.l_name = BYTE_GET (elib[cnt].l_name);
+	      atime = BYTE_GET (elib[cnt].l_time_stamp);
+	      liblist.l_checksum = BYTE_GET (elib[cnt].l_checksum);
+	      liblist.l_version = BYTE_GET (elib[cnt].l_version);
+	      liblist.l_flags = BYTE_GET (elib[cnt].l_flags);
+
+	      tmp = gmtime (&atime);
+	      snprintf (timebuf, sizeof (timebuf),
+			"%04u-%02u-%02uT%02u:%02u:%02u",
+			tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
+			tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
+
+	      printf ("%3lu: ", (unsigned long) cnt);
+	      if (do_wide)
+		printf ("%-20s", liblist.l_name < strtab_size
+			? strtab + liblist.l_name : _("<corrupt>"));
+	      else
+		printf ("%-20.20s", liblist.l_name < strtab_size
+			? strtab + liblist.l_name : _("<corrupt>"));
+	      printf (" %s %#010lx %-7ld %-7ld\n", timebuf, liblist.l_checksum,
+		      liblist.l_version, liblist.l_flags);
+	    }
+
+	  free (elib);
+	  free (strtab);
+	}
+    }
+
+  return res;
+}
+
+static const char *
+get_note_type (Filedata * filedata, unsigned e_type)
+{
+  static char buff[64];
+
+  if (filedata->file_header.e_type == ET_CORE)
+    switch (e_type)
+      {
+      case NT_AUXV:
+	return _("NT_AUXV (auxiliary vector)");
+      case NT_PRSTATUS:
+	return _("NT_PRSTATUS (prstatus structure)");
+      case NT_FPREGSET:
+	return _("NT_FPREGSET (floating point registers)");
+      case NT_PRPSINFO:
+	return _("NT_PRPSINFO (prpsinfo structure)");
+      case NT_TASKSTRUCT:
+	return _("NT_TASKSTRUCT (task structure)");
+      case NT_GDB_TDESC:
+        return _("NT_GDB_TDESC (GDB XML target description)");
+      case NT_PRXFPREG:
+	return _("NT_PRXFPREG (user_xfpregs structure)");
+      case NT_PPC_VMX:
+	return _("NT_PPC_VMX (ppc Altivec registers)");
+      case NT_PPC_VSX:
+	return _("NT_PPC_VSX (ppc VSX registers)");
+      case NT_PPC_TAR:
+	return _("NT_PPC_TAR (ppc TAR register)");
+      case NT_PPC_PPR:
+	return _("NT_PPC_PPR (ppc PPR register)");
+      case NT_PPC_DSCR:
+	return _("NT_PPC_DSCR (ppc DSCR register)");
+      case NT_PPC_EBB:
+	return _("NT_PPC_EBB (ppc EBB registers)");
+      case NT_PPC_PMU:
+	return _("NT_PPC_PMU (ppc PMU registers)");
+      case NT_PPC_TM_CGPR:
+	return _("NT_PPC_TM_CGPR (ppc checkpointed GPR registers)");
+      case NT_PPC_TM_CFPR:
+	return _("NT_PPC_TM_CFPR (ppc checkpointed floating point registers)");
+      case NT_PPC_TM_CVMX:
+	return _("NT_PPC_TM_CVMX (ppc checkpointed Altivec registers)");
+      case NT_PPC_TM_CVSX:
+	return _("NT_PPC_TM_CVSX (ppc checkpointed VSX registers)");
+      case NT_PPC_TM_SPR:
+	return _("NT_PPC_TM_SPR (ppc TM special purpose registers)");
+      case NT_PPC_TM_CTAR:
+	return _("NT_PPC_TM_CTAR (ppc checkpointed TAR register)");
+      case NT_PPC_TM_CPPR:
+	return _("NT_PPC_TM_CPPR (ppc checkpointed PPR register)");
+      case NT_PPC_TM_CDSCR:
+	return _("NT_PPC_TM_CDSCR (ppc checkpointed DSCR register)");
+      case NT_386_TLS:
+	return _("NT_386_TLS (x86 TLS information)");
+      case NT_386_IOPERM:
+	return _("NT_386_IOPERM (x86 I/O permissions)");
+      case NT_X86_XSTATE:
+	return _("NT_X86_XSTATE (x86 XSAVE extended state)");
+      case NT_X86_CET:
+	return _("NT_X86_CET (x86 CET state)");
+      case NT_S390_HIGH_GPRS:
+	return _("NT_S390_HIGH_GPRS (s390 upper register halves)");
+      case NT_S390_TIMER:
+	return _("NT_S390_TIMER (s390 timer register)");
+      case NT_S390_TODCMP:
+	return _("NT_S390_TODCMP (s390 TOD comparator register)");
+      case NT_S390_TODPREG:
+	return _("NT_S390_TODPREG (s390 TOD programmable register)");
+      case NT_S390_CTRS:
+	return _("NT_S390_CTRS (s390 control registers)");
+      case NT_S390_PREFIX:
+	return _("NT_S390_PREFIX (s390 prefix register)");
+      case NT_S390_LAST_BREAK:
+	return _("NT_S390_LAST_BREAK (s390 last breaking event address)");
+      case NT_S390_SYSTEM_CALL:
+	return _("NT_S390_SYSTEM_CALL (s390 system call restart data)");
+      case NT_S390_TDB:
+	return _("NT_S390_TDB (s390 transaction diagnostic block)");
+      case NT_S390_VXRS_LOW:
+	return _("NT_S390_VXRS_LOW (s390 vector registers 0-15 upper half)");
+      case NT_S390_VXRS_HIGH:
+	return _("NT_S390_VXRS_HIGH (s390 vector registers 16-31)");
+      case NT_S390_GS_CB:
+	return _("NT_S390_GS_CB (s390 guarded-storage registers)");
+      case NT_S390_GS_BC:
+	return _("NT_S390_GS_BC (s390 guarded-storage broadcast control)");
+      case NT_ARM_VFP:
+	return _("NT_ARM_VFP (arm VFP registers)");
+      case NT_ARM_TLS:
+	return _("NT_ARM_TLS (AArch TLS registers)");
+      case NT_ARM_HW_BREAK:
+	return _("NT_ARM_HW_BREAK (AArch hardware breakpoint registers)");
+      case NT_ARM_HW_WATCH:
+	return _("NT_ARM_HW_WATCH (AArch hardware watchpoint registers)");
+      case NT_ARM_SVE:
+	return _("NT_ARM_SVE (AArch SVE registers)");
+      case NT_ARM_PAC_MASK:
+	return _("NT_ARM_PAC_MASK (AArch pointer authentication code masks)");
+      case NT_ARM_TAGGED_ADDR_CTRL:
+	return _("NT_ARM_TAGGED_ADDR_CTRL (AArch tagged address control)");
+      case NT_ARC_V2:
+	return _("NT_ARC_V2 (ARC HS accumulator/extra registers)");
+      case NT_RISCV_CSR:
+	return _("NT_RISCV_CSR (RISC-V control and status registers)");
+      case NT_PSTATUS:
+	return _("NT_PSTATUS (pstatus structure)");
+      case NT_FPREGS:
+	return _("NT_FPREGS (floating point registers)");
+      case NT_PSINFO:
+	return _("NT_PSINFO (psinfo structure)");
+      case NT_LWPSTATUS:
+	return _("NT_LWPSTATUS (lwpstatus_t structure)");
+      case NT_LWPSINFO:
+	return _("NT_LWPSINFO (lwpsinfo_t structure)");
+      case NT_WIN32PSTATUS:
+	return _("NT_WIN32PSTATUS (win32_pstatus structure)");
+      case NT_SIGINFO:
+	return _("NT_SIGINFO (siginfo_t data)");
+      case NT_FILE:
+	return _("NT_FILE (mapped files)");
+      case NT_MEMTAG:
+	return _("NT_MEMTAG (memory tags)");
+      default:
+	break;
+      }
+  else
+    switch (e_type)
+      {
+      case NT_VERSION:
+	return _("NT_VERSION (version)");
+      case NT_ARCH:
+	return _("NT_ARCH (architecture)");
+      case NT_GNU_BUILD_ATTRIBUTE_OPEN:
+	return _("OPEN");
+      case NT_GNU_BUILD_ATTRIBUTE_FUNC:
+	return _("func");
+      case NT_GO_BUILDID:
+	return _("GO BUILDID");
+      default:
+	break;
+      }
+
+  snprintf (buff, sizeof (buff), _("Unknown note type: (0x%08x)"), e_type);
+  return buff;
+}
+
+static bool
+print_core_note (Elf_Internal_Note *pnote)
+{
+  unsigned int addr_size = is_32bit_elf ? 4 : 8;
+  bfd_vma count, page_size;
+  unsigned char *descdata, *filenames, *descend;
+
+  if (pnote->type != NT_FILE)
+    {
+      if (do_wide)
+	printf ("\n");
+      return true;
+    }
+
+#ifndef BFD64
+  if (!is_32bit_elf)
+    {
+      printf (_("    Cannot decode 64-bit note in 32-bit build\n"));
+      /* Still "successful".  */
+      return true;
+    }
+#endif
+
+  if (pnote->descsz < 2 * addr_size)
+    {
+      error (_("    Malformed note - too short for header\n"));
+      return false;
+    }
+
+  descdata = (unsigned char *) pnote->descdata;
+  descend = descdata + pnote->descsz;
+
+  if (descdata[pnote->descsz - 1] != '\0')
+    {
+      error (_("    Malformed note - does not end with \\0\n"));
+      return false;
+    }
+
+  count = byte_get (descdata, addr_size);
+  descdata += addr_size;
+
+  page_size = byte_get (descdata, addr_size);
+  descdata += addr_size;
+
+  if (count > ((bfd_vma) -1 - 2 * addr_size) / (3 * addr_size)
+      || pnote->descsz < 2 * addr_size + count * 3 * addr_size)
+    {
+      error (_("    Malformed note - too short for supplied file count\n"));
+      return false;
+    }
+
+  printf (_("    Page size: "));
+  print_vma (page_size, DEC);
+  printf ("\n");
+
+  printf (_("    %*s%*s%*s\n"),
+	  (int) (2 + 2 * addr_size), _("Start"),
+	  (int) (4 + 2 * addr_size), _("End"),
+	  (int) (4 + 2 * addr_size), _("Page Offset"));
+  filenames = descdata + count * 3 * addr_size;
+  while (count-- > 0)
+    {
+      bfd_vma start, end, file_ofs;
+
+      if (filenames == descend)
+	{
+	  error (_("    Malformed note - filenames end too early\n"));
+	  return false;
+	}
+
+      start = byte_get (descdata, addr_size);
+      descdata += addr_size;
+      end = byte_get (descdata, addr_size);
+      descdata += addr_size;
+      file_ofs = byte_get (descdata, addr_size);
+      descdata += addr_size;
+
+      printf ("    ");
+      print_vma (start, FULL_HEX);
+      printf ("  ");
+      print_vma (end, FULL_HEX);
+      printf ("  ");
+      print_vma (file_ofs, FULL_HEX);
+      printf ("\n        %s\n", filenames);
+
+      filenames += 1 + strlen ((char *) filenames);
+    }
+
+  return true;
+}
+
+static const char *
+get_gnu_elf_note_type (unsigned e_type)
+{
+  /* NB/ Keep this switch statement in sync with print_gnu_note ().  */
+  switch (e_type)
+    {
+    case NT_GNU_ABI_TAG:
+      return _("NT_GNU_ABI_TAG (ABI version tag)");
+    case NT_GNU_HWCAP:
+      return _("NT_GNU_HWCAP (DSO-supplied software HWCAP info)");
+    case NT_GNU_BUILD_ID:
+      return _("NT_GNU_BUILD_ID (unique build ID bitstring)");
+    case NT_GNU_GOLD_VERSION:
+      return _("NT_GNU_GOLD_VERSION (gold version)");
+    case NT_GNU_PROPERTY_TYPE_0:
+      return _("NT_GNU_PROPERTY_TYPE_0");
+    case NT_GNU_BUILD_ATTRIBUTE_OPEN:
+      return _("NT_GNU_BUILD_ATTRIBUTE_OPEN");
+    case NT_GNU_BUILD_ATTRIBUTE_FUNC:
+      return _("NT_GNU_BUILD_ATTRIBUTE_FUNC");
+    default:
+      {
+	static char buff[64];
+
+	snprintf (buff, sizeof (buff), _("Unknown note type: (0x%08x)"), e_type);
+	return buff;
+      }
+    }
+}
+
+static void
+decode_x86_compat_isa (unsigned int bitmask)
+{
+  while (bitmask)
+    {
+      unsigned int bit = bitmask & (- bitmask);
+
+      bitmask &= ~ bit;
+      switch (bit)
+	{
+	case GNU_PROPERTY_X86_COMPAT_ISA_1_486:
+	  printf ("i486");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_ISA_1_586:
+	  printf ("586");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_ISA_1_686:
+	  printf ("686");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_ISA_1_SSE:
+	  printf ("SSE");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_ISA_1_SSE2:
+	  printf ("SSE2");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_ISA_1_SSE3:
+	  printf ("SSE3");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_ISA_1_SSSE3:
+	  printf ("SSSE3");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_ISA_1_SSE4_1:
+	  printf ("SSE4_1");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_ISA_1_SSE4_2:
+	  printf ("SSE4_2");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_ISA_1_AVX:
+	  printf ("AVX");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_ISA_1_AVX2:
+	  printf ("AVX2");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512F:
+	  printf ("AVX512F");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512CD:
+	  printf ("AVX512CD");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512ER:
+	  printf ("AVX512ER");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512PF:
+	  printf ("AVX512PF");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512VL:
+	  printf ("AVX512VL");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512DQ:
+	  printf ("AVX512DQ");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512BW:
+	  printf ("AVX512BW");
+	  break;
+	default:
+	  printf (_("<unknown: %x>"), bit);
+	  break;
+	}
+      if (bitmask)
+	printf (", ");
+    }
+}
+
+static void
+decode_x86_compat_2_isa (unsigned int bitmask)
+{
+  if (!bitmask)
+    {
+      printf (_("<None>"));
+      return;
+    }
+
+  while (bitmask)
+    {
+      unsigned int bit = bitmask & (- bitmask);
+
+      bitmask &= ~ bit;
+      switch (bit)
+	{
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_CMOV:
+	  printf ("CMOV");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_SSE:
+	  printf ("SSE");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_SSE2:
+	  printf ("SSE2");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_SSE3:
+	  printf ("SSE3");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_SSSE3:
+	  printf ("SSSE3");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_SSE4_1:
+	  printf ("SSE4_1");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_SSE4_2:
+	  printf ("SSE4_2");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX:
+	  printf ("AVX");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX2:
+	  printf ("AVX2");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_FMA:
+	  printf ("FMA");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512F:
+	  printf ("AVX512F");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512CD:
+	  printf ("AVX512CD");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512ER:
+	  printf ("AVX512ER");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512PF:
+	  printf ("AVX512PF");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512VL:
+	  printf ("AVX512VL");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512DQ:
+	  printf ("AVX512DQ");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512BW:
+	  printf ("AVX512BW");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512_4FMAPS:
+	  printf ("AVX512_4FMAPS");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512_4VNNIW:
+	  printf ("AVX512_4VNNIW");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512_BITALG:
+	  printf ("AVX512_BITALG");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512_IFMA:
+	  printf ("AVX512_IFMA");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512_VBMI:
+	  printf ("AVX512_VBMI");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512_VBMI2:
+	  printf ("AVX512_VBMI2");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512_VNNI:
+	  printf ("AVX512_VNNI");
+	  break;
+	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512_BF16:
+	  printf ("AVX512_BF16");
+	  break;
+	default:
+	  printf (_("<unknown: %x>"), bit);
+	  break;
+	}
+      if (bitmask)
+	printf (", ");
+    }
+}
+
+static void
+decode_x86_isa (unsigned int bitmask)
+{
+  while (bitmask)
+    {
+      unsigned int bit = bitmask & (- bitmask);
+
+      bitmask &= ~ bit;
+      switch (bit)
+	{
+	case GNU_PROPERTY_X86_ISA_1_BASELINE:
+	  printf ("x86-64-baseline");
+	  break;
+	case GNU_PROPERTY_X86_ISA_1_V2:
+	  printf ("x86-64-v2");
+	  break;
+	case GNU_PROPERTY_X86_ISA_1_V3:
+	  printf ("x86-64-v3");
+	  break;
+	case GNU_PROPERTY_X86_ISA_1_V4:
+	  printf ("x86-64-v4");
+	  break;
+	default:
+	  printf (_("<unknown: %x>"), bit);
+	  break;
+	}
+      if (bitmask)
+	printf (", ");
+    }
+}
+
+static void
+decode_x86_feature_1 (unsigned int bitmask)
+{
+  if (!bitmask)
+    {
+      printf (_("<None>"));
+      return;
+    }
+
+  while (bitmask)
+    {
+      unsigned int bit = bitmask & (- bitmask);
+
+      bitmask &= ~ bit;
+      switch (bit)
+	{
+	case GNU_PROPERTY_X86_FEATURE_1_IBT:
+	  printf ("IBT");
+	  break;
+	case GNU_PROPERTY_X86_FEATURE_1_SHSTK:
+	  printf ("SHSTK");
+	  break;
+	case GNU_PROPERTY_X86_FEATURE_1_LAM_U48:
+	  printf ("LAM_U48");
+	  break;
+	case GNU_PROPERTY_X86_FEATURE_1_LAM_U57:
+	  printf ("LAM_U57");
+	  break;
+	default:
+	  printf (_("<unknown: %x>"), bit);
+	  break;
+	}
+      if (bitmask)
+	printf (", ");
+    }
+}
+
+static void
+decode_x86_feature_2 (unsigned int bitmask)
+{
+  if (!bitmask)
+    {
+      printf (_("<None>"));
+      return;
+    }
+
+  while (bitmask)
+    {
+      unsigned int bit = bitmask & (- bitmask);
+
+      bitmask &= ~ bit;
+      switch (bit)
+	{
+	case GNU_PROPERTY_X86_FEATURE_2_X86:
+	  printf ("x86");
+	  break;
+	case GNU_PROPERTY_X86_FEATURE_2_X87:
+	  printf ("x87");
+	  break;
+	case GNU_PROPERTY_X86_FEATURE_2_MMX:
+	  printf ("MMX");
+	  break;
+	case GNU_PROPERTY_X86_FEATURE_2_XMM:
+	  printf ("XMM");
+	  break;
+	case GNU_PROPERTY_X86_FEATURE_2_YMM:
+	  printf ("YMM");
+	  break;
+	case GNU_PROPERTY_X86_FEATURE_2_ZMM:
+	  printf ("ZMM");
+	  break;
+	case GNU_PROPERTY_X86_FEATURE_2_TMM:
+	  printf ("TMM");
+	  break;
+	case GNU_PROPERTY_X86_FEATURE_2_MASK:
+	  printf ("MASK");
+	  break;
+	case GNU_PROPERTY_X86_FEATURE_2_FXSR:
+	  printf ("FXSR");
+	  break;
+	case GNU_PROPERTY_X86_FEATURE_2_XSAVE:
+	  printf ("XSAVE");
+	  break;
+	case GNU_PROPERTY_X86_FEATURE_2_XSAVEOPT:
+	  printf ("XSAVEOPT");
+	  break;
+	case GNU_PROPERTY_X86_FEATURE_2_XSAVEC:
+	  printf ("XSAVEC");
+	  break;
+	default:
+	  printf (_("<unknown: %x>"), bit);
+	  break;
+	}
+      if (bitmask)
+	printf (", ");
+    }
+}
+
+static void
+decode_aarch64_feature_1_and (unsigned int bitmask)
+{
+  while (bitmask)
+    {
+      unsigned int bit = bitmask & (- bitmask);
+
+      bitmask &= ~ bit;
+      switch (bit)
+	{
+	case GNU_PROPERTY_AARCH64_FEATURE_1_BTI:
+	  printf ("BTI");
+	  break;
+
+	case GNU_PROPERTY_AARCH64_FEATURE_1_PAC:
+	  printf ("PAC");
+	  break;
+
+	default:
+	  printf (_("<unknown: %x>"), bit);
+	  break;
+	}
+      if (bitmask)
+	printf (", ");
+    }
+}
+
+static void
+print_gnu_property_note (Filedata * filedata, Elf_Internal_Note * pnote)
+{
+  unsigned char * ptr = (unsigned char *) pnote->descdata;
+  unsigned char * ptr_end = ptr + pnote->descsz;
+  unsigned int    size = is_32bit_elf ? 4 : 8;
+
+  printf (_("      Properties: "));
+
+  if (pnote->descsz < 8 || (pnote->descsz % size) != 0)
+    {
+      printf (_("<corrupt GNU_PROPERTY_TYPE, size = %#lx>\n"), pnote->descsz);
+      return;
+    }
+
+  while (ptr < ptr_end)
+    {
+      unsigned int j;
+      unsigned int type;
+      unsigned int datasz;
+
+      if ((size_t) (ptr_end - ptr) < 8)
+	{
+	  printf (_("<corrupt descsz: %#lx>\n"), pnote->descsz);
+	  break;
+	}
+
+      type = byte_get (ptr, 4);
+      datasz = byte_get (ptr + 4, 4);
+
+      ptr += 8;
+
+      if (datasz > (size_t) (ptr_end - ptr))
+	{
+	  printf (_("<corrupt type (%#x) datasz: %#x>\n"),
+		  type, datasz);
+	  break;
+	}
+
+      if (type >= GNU_PROPERTY_LOPROC && type <= GNU_PROPERTY_HIPROC)
+	{
+	  if (filedata->file_header.e_machine == EM_X86_64
+	      || filedata->file_header.e_machine == EM_IAMCU
+	      || filedata->file_header.e_machine == EM_386)
+	    {
+	      unsigned int bitmask;
+
+	      if (datasz == 4)
+		bitmask = byte_get (ptr, 4);
+	      else
+		bitmask = 0;
+
+	      switch (type)
+		{
+		case GNU_PROPERTY_X86_ISA_1_USED:
+		  if (datasz != 4)
+		    printf (_("x86 ISA used: <corrupt length: %#x> "),
+			    datasz);
+		  else
+		    {
+		      printf ("x86 ISA used: ");
+		      decode_x86_isa (bitmask);
+		    }
+		  goto next;
+
+		case GNU_PROPERTY_X86_ISA_1_NEEDED:
+		  if (datasz != 4)
+		    printf (_("x86 ISA needed: <corrupt length: %#x> "),
+			    datasz);
+		  else
+		    {
+		      printf ("x86 ISA needed: ");
+		      decode_x86_isa (bitmask);
+		    }
+		  goto next;
+
+		case GNU_PROPERTY_X86_FEATURE_1_AND:
+		  if (datasz != 4)
+		    printf (_("x86 feature: <corrupt length: %#x> "),
+			    datasz);
+		  else
+		    {
+		      printf ("x86 feature: ");
+		      decode_x86_feature_1 (bitmask);
+		    }
+		  goto next;
+
+		case GNU_PROPERTY_X86_FEATURE_2_USED:
+		  if (datasz != 4)
+		    printf (_("x86 feature used: <corrupt length: %#x> "),
+			    datasz);
+		  else
+		    {
+		      printf ("x86 feature used: ");
+		      decode_x86_feature_2 (bitmask);
+		    }
+		  goto next;
+
+		case GNU_PROPERTY_X86_FEATURE_2_NEEDED:
+		  if (datasz != 4)
+		    printf (_("x86 feature needed: <corrupt length: %#x> "), datasz);
+		  else
+		    {
+		      printf ("x86 feature needed: ");
+		      decode_x86_feature_2 (bitmask);
+		    }
+		  goto next;
+
+		case GNU_PROPERTY_X86_COMPAT_ISA_1_USED:
+		  if (datasz != 4)
+		    printf (_("x86 ISA used: <corrupt length: %#x> "),
+			    datasz);
+		  else
+		    {
+		      printf ("x86 ISA used: ");
+		      decode_x86_compat_isa (bitmask);
+		    }
+		  goto next;
+
+		case GNU_PROPERTY_X86_COMPAT_ISA_1_NEEDED:
+		  if (datasz != 4)
+		    printf (_("x86 ISA needed: <corrupt length: %#x> "),
+			    datasz);
+		  else
+		    {
+		      printf ("x86 ISA needed: ");
+		      decode_x86_compat_isa (bitmask);
+		    }
+		  goto next;
+
+		case GNU_PROPERTY_X86_COMPAT_2_ISA_1_USED:
+		  if (datasz != 4)
+		    printf (_("x86 ISA used: <corrupt length: %#x> "),
+			    datasz);
+		  else
+		    {
+		      printf ("x86 ISA used: ");
+		      decode_x86_compat_2_isa (bitmask);
+		    }
+		  goto next;
+
+		case GNU_PROPERTY_X86_COMPAT_2_ISA_1_NEEDED:
+		  if (datasz != 4)
+		    printf (_("x86 ISA needed: <corrupt length: %#x> "),
+			    datasz);
+		  else
+		    {
+		      printf ("x86 ISA needed: ");
+		      decode_x86_compat_2_isa (bitmask);
+		    }
+		  goto next;
+
+		default:
+		  break;
+		}
+	    }
+	  else if (filedata->file_header.e_machine == EM_AARCH64)
+	    {
+	      if (type == GNU_PROPERTY_AARCH64_FEATURE_1_AND)
+		{
+		  printf ("AArch64 feature: ");
+		  if (datasz != 4)
+		    printf (_("<corrupt length: %#x> "), datasz);
+		  else
+		    decode_aarch64_feature_1_and (byte_get (ptr, 4));
+		  goto next;
+		}
+	    }
+	}
+      else
+	{
+	  switch (type)
+	    {
+	    case GNU_PROPERTY_STACK_SIZE:
+	      printf (_("stack size: "));
+	      if (datasz != size)
+		printf (_("<corrupt length: %#x> "), datasz);
+	      else
+		printf ("%#lx", (unsigned long) byte_get (ptr, size));
+	      goto next;
+
+	    case GNU_PROPERTY_NO_COPY_ON_PROTECTED:
+	      printf ("no copy on protected ");
+	      if (datasz)
+		printf (_("<corrupt length: %#x> "), datasz);
+	      goto next;
+
+	    default:
+	      if ((type >= GNU_PROPERTY_UINT32_AND_LO
+		   && type <= GNU_PROPERTY_UINT32_AND_HI)
+		  || (type >= GNU_PROPERTY_UINT32_OR_LO
+		      && type <= GNU_PROPERTY_UINT32_OR_HI))
+		{
+		  if (type <= GNU_PROPERTY_UINT32_AND_HI)
+		    printf (_("UINT32_AND (%#x): "), type);
+		  else
+		    printf (_("UINT32_OR (%#x): "), type);
+		  if (datasz != 4)
+		    printf (_("<corrupt length: %#x> "), datasz);
+		  else
+		    printf ("%#x", (unsigned int) byte_get (ptr, 4));
+		  goto next;
+		}
+	      break;
+	    }
+	}
+
+      if (type < GNU_PROPERTY_LOPROC)
+	printf (_("<unknown type %#x data: "), type);
+      else if (type < GNU_PROPERTY_LOUSER)
+	printf (_("<processor-specific type %#x data: "), type);
+      else
+	printf (_("<application-specific type %#x data: "), type);
+      for (j = 0; j < datasz; ++j)
+	printf ("%02x ", ptr[j] & 0xff);
+      printf (">");
+
+    next:
+      ptr += ((datasz + (size - 1)) & ~ (size - 1));
+      if (ptr == ptr_end)
+	break;
+
+      if (do_wide)
+	printf (", ");
+      else
+	printf ("\n\t");
+    }
+
+  printf ("\n");
+}
+
+static bool
+print_gnu_note (Filedata * filedata, Elf_Internal_Note *pnote)
+{
+  /* NB/ Keep this switch statement in sync with get_gnu_elf_note_type ().  */
+  switch (pnote->type)
+    {
+    case NT_GNU_BUILD_ID:
+      {
+	unsigned long i;
+
+	printf (_("    Build ID: "));
+	for (i = 0; i < pnote->descsz; ++i)
+	  printf ("%02x", pnote->descdata[i] & 0xff);
+	printf ("\n");
+      }
+      break;
+
+    case NT_GNU_ABI_TAG:
+      {
+	unsigned long os, major, minor, subminor;
+	const char *osname;
+
+	/* PR 17531: file: 030-599401-0.004.  */
+	if (pnote->descsz < 16)
+	  {
+	    printf (_("    <corrupt GNU_ABI_TAG>\n"));
+	    break;
+	  }
+
+	os = byte_get ((unsigned char *) pnote->descdata, 4);
+	major = byte_get ((unsigned char *) pnote->descdata + 4, 4);
+	minor = byte_get ((unsigned char *) pnote->descdata + 8, 4);
+	subminor = byte_get ((unsigned char *) pnote->descdata + 12, 4);
+
+	switch (os)
+	  {
+	  case GNU_ABI_TAG_LINUX:
+	    osname = "Linux";
+	    break;
+	  case GNU_ABI_TAG_HURD:
+	    osname = "Hurd";
+	    break;
+	  case GNU_ABI_TAG_SOLARIS:
+	    osname = "Solaris";
+	    break;
+	  case GNU_ABI_TAG_FREEBSD:
+	    osname = "FreeBSD";
+	    break;
+	  case GNU_ABI_TAG_NETBSD:
+	    osname = "NetBSD";
+	    break;
+	  case GNU_ABI_TAG_SYLLABLE:
+	    osname = "Syllable";
+	    break;
+	  case GNU_ABI_TAG_NACL:
+	    osname = "NaCl";
+	    break;
+	  default:
+	    osname = "Unknown";
+	    break;
+	  }
+
+	printf (_("    OS: %s, ABI: %ld.%ld.%ld\n"), osname,
+		major, minor, subminor);
+      }
+      break;
+
+    case NT_GNU_GOLD_VERSION:
+      {
+	unsigned long i;
+
+	printf (_("    Version: "));
+	for (i = 0; i < pnote->descsz && pnote->descdata[i] != '\0'; ++i)
+	  printf ("%c", pnote->descdata[i]);
+	printf ("\n");
+      }
+      break;
+
+    case NT_GNU_HWCAP:
+      {
+	unsigned long num_entries, mask;
+
+	/* Hardware capabilities information.  Word 0 is the number of entries.
+	   Word 1 is a bitmask of enabled entries.  The rest of the descriptor
+	   is a series of entries, where each entry is a single byte followed
+	   by a nul terminated string.  The byte gives the bit number to test
+	   if enabled in the bitmask.  */
+	printf (_("      Hardware Capabilities: "));
+	if (pnote->descsz < 8)
+	  {
+	    error (_("<corrupt GNU_HWCAP>\n"));
+	    return false;
+	  }
+	num_entries = byte_get ((unsigned char *) pnote->descdata, 4);
+	mask = byte_get ((unsigned char *) pnote->descdata + 4, 4);
+	printf (_("num entries: %ld, enabled mask: %lx\n"), num_entries, mask);
+	/* FIXME: Add code to display the entries... */
+      }
+      break;
+
+    case NT_GNU_PROPERTY_TYPE_0:
+      print_gnu_property_note (filedata, pnote);
+      break;
+
+    default:
+      /* Handle unrecognised types.  An error message should have already been
+	 created by get_gnu_elf_note_type(), so all that we need to do is to
+	 display the data.  */
+      {
+	unsigned long i;
+
+	printf (_("    Description data: "));
+	for (i = 0; i < pnote->descsz; ++i)
+	  printf ("%02x ", pnote->descdata[i] & 0xff);
+	printf ("\n");
+      }
+      break;
+    }
+
+  return true;
+}
+
+static const char *
+get_v850_elf_note_type (enum v850_notes n_type)
+{
+  static char buff[64];
+
+  switch (n_type)
+    {
+    case V850_NOTE_ALIGNMENT:  return _("Alignment of 8-byte objects");
+    case V850_NOTE_DATA_SIZE:  return _("Sizeof double and long double");
+    case V850_NOTE_FPU_INFO:   return _("Type of FPU support needed");
+    case V850_NOTE_SIMD_INFO:  return _("Use of SIMD instructions");
+    case V850_NOTE_CACHE_INFO: return _("Use of cache");
+    case V850_NOTE_MMU_INFO:   return _("Use of MMU");
+    default:
+      snprintf (buff, sizeof (buff), _("Unknown note type: (0x%08x)"), n_type);
+      return buff;
+    }
+}
+
+static bool
+print_v850_note (Elf_Internal_Note * pnote)
+{
+  unsigned int val;
+
+  if (pnote->descsz != 4)
+    return false;
+
+  val = byte_get ((unsigned char *) pnote->descdata, pnote->descsz);
+
+  if (val == 0)
+    {
+      printf (_("not set\n"));
+      return true;
+    }
+
+  switch (pnote->type)
+    {
+    case V850_NOTE_ALIGNMENT:
+      switch (val)
+	{
+	case EF_RH850_DATA_ALIGN4: printf (_("4-byte\n")); return true;
+	case EF_RH850_DATA_ALIGN8: printf (_("8-byte\n")); return true;
+	}
+      break;
+
+    case V850_NOTE_DATA_SIZE:
+      switch (val)
+	{
+	case EF_RH850_DOUBLE32: printf (_("4-bytes\n")); return true;
+	case EF_RH850_DOUBLE64: printf (_("8-bytes\n")); return true;
+	}
+      break;
+
+    case V850_NOTE_FPU_INFO:
+      switch (val)
+	{
+	case EF_RH850_FPU20: printf (_("FPU-2.0\n")); return true;
+	case EF_RH850_FPU30: printf (_("FPU-3.0\n")); return true;
+	}
+      break;
+
+    case V850_NOTE_MMU_INFO:
+    case V850_NOTE_CACHE_INFO:
+    case V850_NOTE_SIMD_INFO:
+      if (val == EF_RH850_SIMD)
+	{
+	  printf (_("yes\n"));
+	  return true;
+	}
+      break;
+
+    default:
+      /* An 'unknown note type' message will already have been displayed.  */
+      break;
+    }
+
+  printf (_("unknown value: %x\n"), val);
+  return false;
+}
+
+static bool
+process_netbsd_elf_note (Elf_Internal_Note * pnote)
+{
+  unsigned int version;
+
+  switch (pnote->type)
+    {
+    case NT_NETBSD_IDENT:
+      if (pnote->descsz < 1)
+	break;
+      version = byte_get ((unsigned char *) pnote->descdata, sizeof (version));
+      if ((version / 10000) % 100)
+	printf ("  NetBSD\t\t0x%08lx\tIDENT %u (%u.%u%s%c)\n", pnote->descsz,
+		version, version / 100000000, (version / 1000000) % 100,
+		(version / 10000) % 100 > 26 ? "Z" : "",
+		'A' + (version / 10000) % 26);
+      else
+	printf ("  NetBSD\t\t0x%08lx\tIDENT %u (%u.%u.%u)\n", pnote->descsz,
+		version, version / 100000000, (version / 1000000) % 100,
+		(version / 100) % 100);
+      return true;
+
+    case NT_NETBSD_MARCH:
+      printf ("  NetBSD\t\t0x%08lx\tMARCH <%s>\n", pnote->descsz,
+	      pnote->descdata);
+      return true;
+
+    case NT_NETBSD_PAX:
+      if (pnote->descsz < 1)
+	break;
+      version = byte_get ((unsigned char *) pnote->descdata, sizeof (version));
+      printf ("  NetBSD\t\t0x%08lx\tPaX <%s%s%s%s%s%s>\n", pnote->descsz,
+	      ((version & NT_NETBSD_PAX_MPROTECT) ? "+mprotect" : ""),
+	      ((version & NT_NETBSD_PAX_NOMPROTECT) ? "-mprotect" : ""),
+	      ((version & NT_NETBSD_PAX_GUARD) ? "+guard" : ""),
+	      ((version & NT_NETBSD_PAX_NOGUARD) ? "-guard" : ""),
+	      ((version & NT_NETBSD_PAX_ASLR) ? "+ASLR" : ""),
+	      ((version & NT_NETBSD_PAX_NOASLR) ? "-ASLR" : ""));
+      return true;
+    }
+
+  printf ("  NetBSD\t0x%08lx\tUnknown note type: (0x%08lx)\n",
+	  pnote->descsz, pnote->type);
+  return false;
+}
+
+static const char *
+get_freebsd_elfcore_note_type (Filedata * filedata, unsigned e_type)
+{
+  switch (e_type)
+    {
+    case NT_FREEBSD_THRMISC:
+      return _("NT_THRMISC (thrmisc structure)");
+    case NT_FREEBSD_PROCSTAT_PROC:
+      return _("NT_PROCSTAT_PROC (proc data)");
+    case NT_FREEBSD_PROCSTAT_FILES:
+      return _("NT_PROCSTAT_FILES (files data)");
+    case NT_FREEBSD_PROCSTAT_VMMAP:
+      return _("NT_PROCSTAT_VMMAP (vmmap data)");
+    case NT_FREEBSD_PROCSTAT_GROUPS:
+      return _("NT_PROCSTAT_GROUPS (groups data)");
+    case NT_FREEBSD_PROCSTAT_UMASK:
+      return _("NT_PROCSTAT_UMASK (umask data)");
+    case NT_FREEBSD_PROCSTAT_RLIMIT:
+      return _("NT_PROCSTAT_RLIMIT (rlimit data)");
+    case NT_FREEBSD_PROCSTAT_OSREL:
+      return _("NT_PROCSTAT_OSREL (osreldate data)");
+    case NT_FREEBSD_PROCSTAT_PSSTRINGS:
+      return _("NT_PROCSTAT_PSSTRINGS (ps_strings data)");
+    case NT_FREEBSD_PROCSTAT_AUXV:
+      return _("NT_PROCSTAT_AUXV (auxv data)");
+    case NT_FREEBSD_PTLWPINFO:
+      return _("NT_PTLWPINFO (ptrace_lwpinfo structure)");
+    }
+  return get_note_type (filedata, e_type);
+}
+
+static const char *
+get_netbsd_elfcore_note_type (Filedata * filedata, unsigned e_type)
+{
+  static char buff[64];
+
+  switch (e_type)
+    {
+    case NT_NETBSDCORE_PROCINFO:
+      /* NetBSD core "procinfo" structure.  */
+      return _("NetBSD procinfo structure");
+
+    case NT_NETBSDCORE_AUXV:
+      return _("NetBSD ELF auxiliary vector data");
+
+    case NT_NETBSDCORE_LWPSTATUS:
+      return _("PT_LWPSTATUS (ptrace_lwpstatus structure)");
+
+    default:
+      /* As of Jan 2020 there are no other machine-independent notes
+	 defined for NetBSD core files.  If the note type is less
+	 than the start of the machine-dependent note types, we don't
+	 understand it.  */
+
+      if (e_type < NT_NETBSDCORE_FIRSTMACH)
+	{
+	  snprintf (buff, sizeof (buff), _("Unknown note type: (0x%08x)"), e_type);
+	  return buff;
+	}
+      break;
+    }
+
+  switch (filedata->file_header.e_machine)
+    {
+    /* On the Alpha, SPARC (32-bit and 64-bit), PT_GETREGS == mach+0
+       and PT_GETFPREGS == mach+2.  */
+
+    case EM_OLD_ALPHA:
+    case EM_ALPHA:
+    case EM_SPARC:
+    case EM_SPARC32PLUS:
+    case EM_SPARCV9:
+      switch (e_type)
+	{
+	case NT_NETBSDCORE_FIRSTMACH + 0:
+	  return _("PT_GETREGS (reg structure)");
+	case NT_NETBSDCORE_FIRSTMACH + 2:
+	  return _("PT_GETFPREGS (fpreg structure)");
+	default:
+	  break;
+	}
+      break;
+
+    /* On SuperH, PT_GETREGS == mach+3 and PT_GETFPREGS == mach+5.
+       There's also old PT___GETREGS40 == mach + 1 for old reg
+       structure which lacks GBR.  */
+    case EM_SH:
+      switch (e_type)
+	{
+	case NT_NETBSDCORE_FIRSTMACH + 1:
+	  return _("PT___GETREGS40 (old reg structure)");
+	case NT_NETBSDCORE_FIRSTMACH + 3:
+	  return _("PT_GETREGS (reg structure)");
+	case NT_NETBSDCORE_FIRSTMACH + 5:
+	  return _("PT_GETFPREGS (fpreg structure)");
+	default:
+	  break;
+	}
+      break;
+
+    /* On all other arch's, PT_GETREGS == mach+1 and
+       PT_GETFPREGS == mach+3.  */
+    default:
+      switch (e_type)
+	{
+	case NT_NETBSDCORE_FIRSTMACH + 1:
+	  return _("PT_GETREGS (reg structure)");
+	case NT_NETBSDCORE_FIRSTMACH + 3:
+	  return _("PT_GETFPREGS (fpreg structure)");
+	default:
+	  break;
+	}
+    }
+
+  snprintf (buff, sizeof (buff), "PT_FIRSTMACH+%d",
+	    e_type - NT_NETBSDCORE_FIRSTMACH);
+  return buff;
+}
+
+static const char *
+get_stapsdt_note_type (unsigned e_type)
+{
+  static char buff[64];
+
+  switch (e_type)
+    {
+    case NT_STAPSDT:
+      return _("NT_STAPSDT (SystemTap probe descriptors)");
+
+    default:
+      break;
+    }
+
+  snprintf (buff, sizeof (buff), _("Unknown note type: (0x%08x)"), e_type);
+  return buff;
+}
+
+static bool
+print_stapsdt_note (Elf_Internal_Note *pnote)
+{
+  size_t len, maxlen;
+  unsigned long addr_size = is_32bit_elf ? 4 : 8;
+  char *data = pnote->descdata;
+  char *data_end = pnote->descdata + pnote->descsz;
+  bfd_vma pc, base_addr, semaphore;
+  char *provider, *probe, *arg_fmt;
+
+  if (pnote->descsz < (addr_size * 3))
+    goto stapdt_note_too_small;
+
+  pc = byte_get ((unsigned char *) data, addr_size);
+  data += addr_size;
+
+  base_addr = byte_get ((unsigned char *) data, addr_size);
+  data += addr_size;
+
+  semaphore = byte_get ((unsigned char *) data, addr_size);
+  data += addr_size;
+
+  if (data >= data_end)
+    goto stapdt_note_too_small;
+  maxlen = data_end - data;
+  len = strnlen (data, maxlen);
+  if (len < maxlen)
+    {
+      provider = data;
+      data += len + 1;
+    }
+  else
+    goto stapdt_note_too_small;
+
+  if (data >= data_end)
+    goto stapdt_note_too_small;
+  maxlen = data_end - data;
+  len = strnlen (data, maxlen);
+  if (len < maxlen)
+    {
+      probe = data;
+      data += len + 1;
+    }
+  else
+    goto stapdt_note_too_small;
+
+  if (data >= data_end)
+    goto stapdt_note_too_small;
+  maxlen = data_end - data;
+  len = strnlen (data, maxlen);
+  if (len < maxlen)
+    {
+      arg_fmt = data;
+      data += len + 1;
+    }
+  else
+    goto stapdt_note_too_small;
+
+  printf (_("    Provider: %s\n"), provider);
+  printf (_("    Name: %s\n"), probe);
+  printf (_("    Location: "));
+  print_vma (pc, FULL_HEX);
+  printf (_(", Base: "));
+  print_vma (base_addr, FULL_HEX);
+  printf (_(", Semaphore: "));
+  print_vma (semaphore, FULL_HEX);
+  printf ("\n");
+  printf (_("    Arguments: %s\n"), arg_fmt);
+
+  return data == data_end;
+
+ stapdt_note_too_small:
+  printf (_("  <corrupt - note is too small>\n"));
+  error (_("corrupt stapdt note - the data size is too small\n"));
+  return false;
+}
+
+static const char *
+get_ia64_vms_note_type (unsigned e_type)
+{
+  static char buff[64];
+
+  switch (e_type)
+    {
+    case NT_VMS_MHD:
+      return _("NT_VMS_MHD (module header)");
+    case NT_VMS_LNM:
+      return _("NT_VMS_LNM (language name)");
+    case NT_VMS_SRC:
+      return _("NT_VMS_SRC (source files)");
+    case NT_VMS_TITLE:
+      return "NT_VMS_TITLE";
+    case NT_VMS_EIDC:
+      return _("NT_VMS_EIDC (consistency check)");
+    case NT_VMS_FPMODE:
+      return _("NT_VMS_FPMODE (FP mode)");
+    case NT_VMS_LINKTIME:
+      return "NT_VMS_LINKTIME";
+    case NT_VMS_IMGNAM:
+      return _("NT_VMS_IMGNAM (image name)");
+    case NT_VMS_IMGID:
+      return _("NT_VMS_IMGID (image id)");
+    case NT_VMS_LINKID:
+      return _("NT_VMS_LINKID (link id)");
+    case NT_VMS_IMGBID:
+      return _("NT_VMS_IMGBID (build id)");
+    case NT_VMS_GSTNAM:
+      return _("NT_VMS_GSTNAM (sym table name)");
+    case NT_VMS_ORIG_DYN:
+      return "NT_VMS_ORIG_DYN";
+    case NT_VMS_PATCHTIME:
+      return "NT_VMS_PATCHTIME";
+    default:
+      snprintf (buff, sizeof (buff), _("Unknown note type: (0x%08x)"), e_type);
+      return buff;
+    }
+}
+
+static bool
+print_ia64_vms_note (Elf_Internal_Note * pnote)
+{
+  int maxlen = pnote->descsz;
+
+  if (maxlen < 2 || (unsigned long) maxlen != pnote->descsz)
+    goto desc_size_fail;
+
+  switch (pnote->type)
+    {
+    case NT_VMS_MHD:
+      if (maxlen <= 36)
+	goto desc_size_fail;
+
+      int l = (int) strnlen (pnote->descdata + 34, maxlen - 34);
+
+      printf (_("    Creation date  : %.17s\n"), pnote->descdata);
+      printf (_("    Last patch date: %.17s\n"), pnote->descdata + 17);
+      if (l + 34 < maxlen)
+	{
+	  printf (_("    Module name    : %s\n"), pnote->descdata + 34);
+	  if (l + 35 < maxlen)
+	    printf (_("    Module version : %s\n"), pnote->descdata + 34 + l + 1);
+	  else
+	    printf (_("    Module version : <missing>\n"));
+	}
+      else
+	{
+	  printf (_("    Module name    : <missing>\n"));
+	  printf (_("    Module version : <missing>\n"));
+	}
+      break;
+
+    case NT_VMS_LNM:
+      printf (_("   Language: %.*s\n"), maxlen, pnote->descdata);
+      break;
+
+#ifdef BFD64
+    case NT_VMS_FPMODE:
+      printf (_("   Floating Point mode: "));
+      if (maxlen < 8)
+	goto desc_size_fail;
+      /* FIXME: Generate an error if descsz > 8 ?  */
+
+      printf ("0x%016" BFD_VMA_FMT "x\n",
+	      (bfd_vma) byte_get ((unsigned char *)pnote->descdata, 8));
+      break;
+
+    case NT_VMS_LINKTIME:
+      printf (_("   Link time: "));
+      if (maxlen < 8)
+	goto desc_size_fail;
+      /* FIXME: Generate an error if descsz > 8 ?  */
+
+      print_vms_time
+	((bfd_int64_t) byte_get ((unsigned char *)pnote->descdata, 8));
+      printf ("\n");
+      break;
+
+    case NT_VMS_PATCHTIME:
+      printf (_("   Patch time: "));
+      if (maxlen < 8)
+	goto desc_size_fail;
+      /* FIXME: Generate an error if descsz > 8 ?  */
+
+      print_vms_time
+	((bfd_int64_t) byte_get ((unsigned char *)pnote->descdata, 8));
+      printf ("\n");
+      break;
+
+    case NT_VMS_ORIG_DYN:
+      if (maxlen < 34)
+	goto desc_size_fail;
+
+      printf (_("   Major id: %u,  minor id: %u\n"),
+              (unsigned) byte_get ((unsigned char *)pnote->descdata, 4),
+              (unsigned) byte_get ((unsigned char *)pnote->descdata + 4, 4));
+      printf (_("   Last modified  : "));
+      print_vms_time
+        ((bfd_int64_t) byte_get ((unsigned char *)pnote->descdata + 8, 8));
+      printf (_("\n   Link flags  : "));
+      printf ("0x%016" BFD_VMA_FMT "x\n",
+              (bfd_vma) byte_get ((unsigned char *)pnote->descdata + 16, 8));
+      printf (_("   Header flags: 0x%08x\n"),
+              (unsigned) byte_get ((unsigned char *)pnote->descdata + 24, 4));
+      printf (_("   Image id    : %.*s\n"), maxlen - 32, pnote->descdata + 32);
+      break;
+#endif
+
+    case NT_VMS_IMGNAM:
+      printf (_("    Image name: %.*s\n"), maxlen, pnote->descdata);
+      break;
+
+    case NT_VMS_GSTNAM:
+      printf (_("    Global symbol table name: %.*s\n"), maxlen, pnote->descdata);
+      break;
+
+    case NT_VMS_IMGID:
+      printf (_("    Image id: %.*s\n"), maxlen, pnote->descdata);
+      break;
+
+    case NT_VMS_LINKID:
+      printf (_("    Linker id: %.*s\n"), maxlen, pnote->descdata);
+      break;
+
+    default:
+      return false;
+    }
+
+  return true;
+
+ desc_size_fail:
+  printf (_("  <corrupt - data size is too small>\n"));
+  error (_("corrupt IA64 note: data size is too small\n"));
+  return false;
+}
+
+struct build_attr_cache {
+  Filedata *filedata;
+  char *strtab;
+  unsigned long strtablen;
+  Elf_Internal_Sym *symtab;
+  unsigned long nsyms;
+} ba_cache;
+
+/* Find the symbol associated with a build attribute that is attached
+   to address OFFSET.  If PNAME is non-NULL then store the name of
+   the symbol (if found) in the provided pointer,  Returns NULL if a
+   symbol could not be found.  */
+
+static Elf_Internal_Sym *
+get_symbol_for_build_attribute (Filedata *filedata,
+				unsigned long offset,
+				bool is_open_attr,
+				const char **pname)
+{
+  Elf_Internal_Sym *saved_sym = NULL;
+  Elf_Internal_Sym *sym;
+
+  if (filedata->section_headers != NULL
+      && (ba_cache.filedata == NULL || filedata != ba_cache.filedata))
+    {
+      Elf_Internal_Shdr * symsec;
+
+      free (ba_cache.strtab);
+      ba_cache.strtab = NULL;
+      free (ba_cache.symtab);
+      ba_cache.symtab = NULL;
+
+      /* Load the symbol and string sections.  */
+      for (symsec = filedata->section_headers;
+	   symsec < filedata->section_headers + filedata->file_header.e_shnum;
+	   symsec ++)
+	{
+	  if (symsec->sh_type == SHT_SYMTAB
+	      && get_symtab (filedata, symsec,
+			     &ba_cache.symtab, &ba_cache.nsyms,
+			     &ba_cache.strtab, &ba_cache.strtablen))
+	    break;
+	}
+      ba_cache.filedata = filedata;
+    }
+
+  if (ba_cache.symtab == NULL)
+    return NULL;
+
+  /* Find a symbol whose value matches offset.  */
+  for (sym = ba_cache.symtab; sym < ba_cache.symtab + ba_cache.nsyms; sym ++)
+    if (sym->st_value == offset)
+      {
+	if (sym->st_name >= ba_cache.strtablen)
+	  /* Huh ?  This should not happen.  */
+	  continue;
+
+	if (ba_cache.strtab[sym->st_name] == 0)
+	  continue;
+
+	/* The AArch64 and ARM architectures define mapping symbols
+	   (eg $d, $x, $t) which we want to ignore.  */
+	if (ba_cache.strtab[sym->st_name] == '$'
+	    && ba_cache.strtab[sym->st_name + 1] != 0
+	    && ba_cache.strtab[sym->st_name + 2] == 0)
+	  continue;
+
+	if (is_open_attr)
+	  {
+	    /* For OPEN attributes we prefer GLOBAL over LOCAL symbols
+	       and FILE or OBJECT symbols over NOTYPE symbols.  We skip
+	       FUNC symbols entirely.  */
+	    switch (ELF_ST_TYPE (sym->st_info))
+	      {
+	      case STT_OBJECT:
+	      case STT_FILE:
+		saved_sym = sym;
+		if (sym->st_size)
+		  {
+		    /* If the symbol has a size associated
+		       with it then we can stop searching.  */
+		    sym = ba_cache.symtab + ba_cache.nsyms;
+		  }
+		continue;
+
+	      case STT_FUNC:
+		/* Ignore function symbols.  */
+		continue;
+
+	      default:
+		break;
+	      }
+
+	    switch (ELF_ST_BIND (sym->st_info))
+	      {
+	      case STB_GLOBAL:
+		if (saved_sym == NULL
+		    || ELF_ST_TYPE (saved_sym->st_info) != STT_OBJECT)
+		  saved_sym = sym;
+		break;
+
+	      case STB_LOCAL:
+		if (saved_sym == NULL)
+		  saved_sym = sym;
+		break;
+
+	      default:
+		break;
+	      }
+	  }
+	else
+	  {
+	    if (ELF_ST_TYPE (sym->st_info) != STT_FUNC)
+	      continue;
+
+	    saved_sym = sym;
+	    break;
+	  }
+      }
+
+  if (saved_sym && pname)
+    * pname = ba_cache.strtab + saved_sym->st_name;
+
+  return saved_sym;
+}
+
+/* Returns true iff addr1 and addr2 are in the same section.  */
+
+static bool
+same_section (Filedata * filedata, unsigned long addr1, unsigned long addr2)
+{
+  Elf_Internal_Shdr * a1;
+  Elf_Internal_Shdr * a2;
+
+  a1 = find_section_by_address (filedata, addr1);
+  a2 = find_section_by_address (filedata, addr2);
+
+  return a1 == a2 && a1 != NULL;
+}
+
+static bool
+print_gnu_build_attribute_description (Elf_Internal_Note *  pnote,
+				       Filedata *           filedata)
+{
+  static unsigned long global_offset = 0;
+  static unsigned long global_end = 0;
+  static unsigned long func_offset = 0;
+  static unsigned long func_end = 0;
+
+  Elf_Internal_Sym *sym;
+  const char *name;
+  unsigned long start;
+  unsigned long end;
+  bool is_open_attr = pnote->type == NT_GNU_BUILD_ATTRIBUTE_OPEN;
+
+  switch (pnote->descsz)
+    {
+    case 0:
+      /* A zero-length description means that the range of
+	 the previous note of the same type should be used.  */
+      if (is_open_attr)
+	{
+	  if (global_end > global_offset)
+	    printf (_("    Applies to region from %#lx to %#lx\n"),
+		    global_offset, global_end);
+	  else
+	    printf (_("    Applies to region from %#lx\n"), global_offset);
+	}
+      else
+	{
+	  if (func_end > func_offset)
+	    printf (_("    Applies to region from %#lx to %#lx\n"), func_offset, func_end);
+	  else
+	    printf (_("    Applies to region from %#lx\n"), func_offset);
+	}
+      return true;
+
+    case 4:
+      start = byte_get ((unsigned char *) pnote->descdata, 4);
+      end = 0;
+      break;
+
+    case 8:
+      start = byte_get ((unsigned char *) pnote->descdata, 4);
+      end = byte_get ((unsigned char *) pnote->descdata + 4, 4);
+      break;
+
+    case 16:
+      start = byte_get ((unsigned char *) pnote->descdata, 8);
+      end = byte_get ((unsigned char *) pnote->descdata + 8, 8);
+      break;
+
+    default:
+      error (_("    <invalid description size: %lx>\n"), pnote->descsz);
+      printf (_("    <invalid descsz>"));
+      return false;
+    }
+
+  name = NULL;
+  sym = get_symbol_for_build_attribute (filedata, start, is_open_attr, & name);
+  /* As of version 5 of the annobin plugin, filename symbols are biased by 2
+     in order to avoid them being confused with the start address of the
+     first function in the file...  */
+  if (sym == NULL && is_open_attr)
+    sym = get_symbol_for_build_attribute (filedata, start + 2, is_open_attr,
+					  & name);
+
+  if (end == 0 && sym != NULL && sym->st_size > 0)
+    end = start + sym->st_size;
+
+  if (is_open_attr)
+    {
+      /* FIXME: Need to properly allow for section alignment.
+	 16 is just the alignment used on x86_64.  */
+      if (global_end > 0
+	  && start > BFD_ALIGN (global_end, 16)
+	  /* Build notes are not guaranteed to be organised in order of
+	     increasing address, but we should find the all of the notes
+	     for one section in the same place.  */
+	  && same_section (filedata, start, global_end))
+	warn (_("Gap in build notes detected from %#lx to %#lx\n"),
+	      global_end + 1, start - 1);
+
+      printf (_("    Applies to region from %#lx"), start);
+      global_offset = start;
+
+      if (end)
+	{
+	  printf (_(" to %#lx"), end);
+	  global_end = end;
+	}
+    }
+  else
+    {
+      printf (_("    Applies to region from %#lx"), start);
+      func_offset = start;
+
+      if (end)
+	{
+	  printf (_(" to %#lx"), end);
+	  func_end = end;
+	}
+    }
+
+  if (sym && name)
+    printf (_(" (%s)"), name);
+
+  printf ("\n");
+  return true;
+}
+
+static bool
+print_gnu_build_attribute_name (Elf_Internal_Note * pnote)
+{
+  static const char string_expected [2] = { GNU_BUILD_ATTRIBUTE_TYPE_STRING, 0 };
+  static const char number_expected [2] = { GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC, 0 };
+  static const char bool_expected [3] = { GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE, GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE, 0 };
+  char         name_type;
+  char         name_attribute;
+  const char * expected_types;
+  const char * name = pnote->namedata;
+  const char * text;
+  signed int   left;
+
+  if (name == NULL || pnote->namesz < 2)
+    {
+      error (_("corrupt name field in GNU build attribute note: size = %ld\n"), pnote->namesz);
+      print_symbol (-20, _("  <corrupt name>"));
+      return false;
+    }
+
+  if (do_wide)
+    left = 28;
+  else
+    left = 20;
+
+  /* Version 2 of the spec adds a "GA" prefix to the name field.  */
+  if (name[0] == 'G' && name[1] == 'A')
+    {
+      if (pnote->namesz < 4)
+	{
+	  error (_("corrupt name field in GNU build attribute note: size = %ld\n"), pnote->namesz);
+	  print_symbol (-20, _("  <corrupt name>"));
+	  return false;
+	}
+
+      printf ("GA");
+      name += 2;
+      left -= 2;
+    }
+
+  switch ((name_type = * name))
+    {
+    case GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC:
+    case GNU_BUILD_ATTRIBUTE_TYPE_STRING:
+    case GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE:
+    case GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE:
+      printf ("%c", * name);
+      left --;
+      break;
+    default:
+      error (_("unrecognised attribute type in name field: %d\n"), name_type);
+      print_symbol (-20, _("<unknown name type>"));
+      return false;
+    }
+
+  ++ name;
+  text = NULL;
+
+  switch ((name_attribute = * name))
+    {
+    case GNU_BUILD_ATTRIBUTE_VERSION:
+      text = _("<version>");
+      expected_types = string_expected;
+      ++ name;
+      break;
+    case GNU_BUILD_ATTRIBUTE_STACK_PROT:
+      text = _("<stack prot>");
+      expected_types = "!+*";
+      ++ name;
+      break;
+    case GNU_BUILD_ATTRIBUTE_RELRO:
+      text = _("<relro>");
+      expected_types = bool_expected;
+      ++ name;
+      break;
+    case GNU_BUILD_ATTRIBUTE_STACK_SIZE:
+      text = _("<stack size>");
+      expected_types = number_expected;
+      ++ name;
+      break;
+    case GNU_BUILD_ATTRIBUTE_TOOL:
+      text = _("<tool>");
+      expected_types = string_expected;
+      ++ name;
+      break;
+    case GNU_BUILD_ATTRIBUTE_ABI:
+      text = _("<ABI>");
+      expected_types = "$*";
+      ++ name;
+      break;
+    case GNU_BUILD_ATTRIBUTE_PIC:
+      text = _("<PIC>");
+      expected_types = number_expected;
+      ++ name;
+      break;
+    case GNU_BUILD_ATTRIBUTE_SHORT_ENUM:
+      text = _("<short enum>");
+      expected_types = bool_expected;
+      ++ name;
+      break;
+    default:
+      if (ISPRINT (* name))
+	{
+	  int len = strnlen (name, pnote->namesz - (name - pnote->namedata)) + 1;
+
+	  if (len > left && ! do_wide)
+	    len = left;
+	  printf ("%.*s:", len, name);
+	  left -= len;
+	  name += len;
+	}
+      else
+	{
+	  static char tmpbuf [128];
+
+	  error (_("unrecognised byte in name field: %d\n"), * name);
+	  sprintf (tmpbuf, _("<unknown:_%d>"), * name);
+	  text = tmpbuf;
+	  name ++;
+	}
+      expected_types = "*$!+";
+      break;
+    }
+
+  if (text)
+    left -= printf ("%s", text);
+
+  if (strchr (expected_types, name_type) == NULL)
+    warn (_("attribute does not have an expected type (%c)\n"), name_type);
+
+  if ((unsigned long)(name - pnote->namedata) > pnote->namesz)
+    {
+      error (_("corrupt name field: namesz: %lu but parsing gets to %ld\n"),
+	     (unsigned long) pnote->namesz,
+	     (long) (name - pnote->namedata));
+      return false;
+    }
+
+  if (left < 1 && ! do_wide)
+    return true;
+
+  switch (name_type)
+    {
+    case GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC:
+      {
+	unsigned int        bytes;
+	unsigned long long  val = 0;
+	unsigned int        shift = 0;
+	char *              decoded = NULL;
+
+	bytes = pnote->namesz - (name - pnote->namedata);
+	if (bytes > 0)
+	  /* The -1 is because the name field is always 0 terminated, and we
+	     want to be able to ensure that the shift in the while loop below
+	     will not overflow.  */
+	  -- bytes;
+
+	if (bytes > sizeof (val))
+	  {
+	    error (_("corrupt numeric name field: too many bytes in the value: %x\n"),
+		   bytes);
+	    bytes = sizeof (val);
+	  }
+	/* We do not bother to warn if bytes == 0 as this can
+	   happen with some early versions of the gcc plugin.  */
+
+	while (bytes --)
+	  {
+	    unsigned long long byte = *name++ & 0xff;
+
+	    val |= byte << shift;
+	    shift += 8;
+	  }
+
+	switch (name_attribute)
+	  {
+	  case GNU_BUILD_ATTRIBUTE_PIC:
+	    switch (val)
+	      {
+	      case 0: decoded = "static"; break;
+	      case 1: decoded = "pic"; break;
+	      case 2: decoded = "PIC"; break;
+	      case 3: decoded = "pie"; break;
+	      case 4: decoded = "PIE"; break;
+	      default: break;
+	      }
+	    break;
+	  case GNU_BUILD_ATTRIBUTE_STACK_PROT:
+	    switch (val)
+	      {
+		/* Based upon the SPCT_FLAG_xxx enum values in gcc/cfgexpand.c.  */
+	      case 0: decoded = "off"; break;
+	      case 1: decoded = "on"; break;
+	      case 2: decoded = "all"; break;
+	      case 3: decoded = "strong"; break;
+	      case 4: decoded = "explicit"; break;
+	      default: break;
+	      }
+	    break;
+	  default:
+	    break;
+	  }
+
+	if (decoded != NULL)
+	  {
+	    print_symbol (-left, decoded);
+	    left = 0;
+	  }
+	else if (val == 0)
+	  {
+	    printf ("0x0");
+	    left -= 3;
+	  }
+	else
+	  {
+	    if (do_wide)
+	      left -= printf ("0x%llx", val);
+	    else
+	      left -= printf ("0x%-.*llx", left, val);
+	  }
+      }
+      break;
+    case GNU_BUILD_ATTRIBUTE_TYPE_STRING:
+      left -= print_symbol (- left, name);
+      break;
+    case GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE:
+      left -= print_symbol (- left, "true");
+      break;
+    case GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE:
+      left -= print_symbol (- left, "false");
+      break;
+    }
+
+  if (do_wide && left > 0)
+    printf ("%-*s", left, " ");
+
+  return true;
+}
+
+/* Note that by the ELF standard, the name field is already null byte
+   terminated, and namesz includes the terminating null byte.
+   I.E. the value of namesz for the name "FSF" is 4.
+
+   If the value of namesz is zero, there is no name present.  */
+
+static bool
+process_note (Elf_Internal_Note *  pnote,
+	      Filedata *           filedata)
+{
+  const char * name = pnote->namesz ? pnote->namedata : "(NONE)";
+  const char * nt;
+
+  if (pnote->namesz == 0)
+    /* If there is no note name, then use the default set of
+       note type strings.  */
+    nt = get_note_type (filedata, pnote->type);
+
+  else if (startswith (pnote->namedata, "GNU"))
+    /* GNU-specific object file notes.  */
+    nt = get_gnu_elf_note_type (pnote->type);
+
+  else if (startswith (pnote->namedata, "FreeBSD"))
+    /* FreeBSD-specific core file notes.  */
+    nt = get_freebsd_elfcore_note_type (filedata, pnote->type);
+
+  else if (startswith (pnote->namedata, "NetBSD-CORE"))
+    /* NetBSD-specific core file notes.  */
+    nt = get_netbsd_elfcore_note_type (filedata, pnote->type);
+
+  else if (startswith (pnote->namedata, "NetBSD"))
+    /* NetBSD-specific core file notes.  */
+    return process_netbsd_elf_note (pnote);
+
+  else if (startswith (pnote->namedata, "PaX"))
+    /* NetBSD-specific core file notes.  */
+    return process_netbsd_elf_note (pnote);
+
+  else if (startswith (pnote->namedata, "SPU/"))
+    {
+      /* SPU-specific core file notes.  */
+      nt = pnote->namedata + 4;
+      name = "SPU";
+    }
+
+  else if (startswith (pnote->namedata, "IPF/VMS"))
+    /* VMS/ia64-specific file notes.  */
+    nt = get_ia64_vms_note_type (pnote->type);
+
+  else if (startswith (pnote->namedata, "stapsdt"))
+    nt = get_stapsdt_note_type (pnote->type);
+
+  else
+    /* Don't recognize this note name; just use the default set of
+       note type strings.  */
+    nt = get_note_type (filedata, pnote->type);
+
+  printf ("  ");
+
+  if (((startswith (pnote->namedata, "GA")
+	&& strchr ("*$!+", pnote->namedata[2]) != NULL)
+       || strchr ("*$!+", pnote->namedata[0]) != NULL)
+      && (pnote->type == NT_GNU_BUILD_ATTRIBUTE_OPEN
+	  || pnote->type == NT_GNU_BUILD_ATTRIBUTE_FUNC))
+    print_gnu_build_attribute_name (pnote);
+  else
+    print_symbol (-20, name);
+
+  if (do_wide)
+    printf (" 0x%08lx\t%s\t", pnote->descsz, nt);
+  else
+    printf (" 0x%08lx\t%s\n", pnote->descsz, nt);
+
+  if (startswith (pnote->namedata, "IPF/VMS"))
+    return print_ia64_vms_note (pnote);
+  else if (startswith (pnote->namedata, "GNU"))
+    return print_gnu_note (filedata, pnote);
+  else if (startswith (pnote->namedata, "stapsdt"))
+    return print_stapsdt_note (pnote);
+  else if (startswith (pnote->namedata, "CORE"))
+    return print_core_note (pnote);
+  else if (((startswith (pnote->namedata, "GA")
+	     && strchr ("*$!+", pnote->namedata[2]) != NULL)
+	    || strchr ("*$!+", pnote->namedata[0]) != NULL)
+	   && (pnote->type == NT_GNU_BUILD_ATTRIBUTE_OPEN
+	       || pnote->type == NT_GNU_BUILD_ATTRIBUTE_FUNC))
+    return print_gnu_build_attribute_description (pnote, filedata);
+
+  if (pnote->descsz)
+    {
+      unsigned long i;
+
+      printf (_("   description data: "));
+      for (i = 0; i < pnote->descsz; i++)
+	printf ("%02x ", pnote->descdata[i] & 0xff);
+      if (!do_wide)
+	printf ("\n");
+    }
+
+  if (do_wide)
+    printf ("\n");
+
+  return true;
+}
+
+static bool
+process_notes_at (Filedata *           filedata,
+		  Elf_Internal_Shdr *  section,
+		  bfd_vma              offset,
+		  bfd_vma              length,
+		  bfd_vma              align)
+{
+  Elf_External_Note *pnotes;
+  Elf_External_Note *external;
+  char *end;
+  bool res = true;
+
+  if (length <= 0)
+    return false;
+
+  if (section)
+    {
+      pnotes = (Elf_External_Note *) get_section_contents (section, filedata);
+      if (pnotes)
+	{
+	  if (! apply_relocations (filedata, section, (unsigned char *) pnotes, length, NULL, NULL))
+	    {
+	      free (pnotes);
+	      return false;
+	    }
+	}
+    }
+  else
+    pnotes = (Elf_External_Note *) get_data (NULL, filedata, offset, 1, length,
+					     _("notes"));
+
+  if (pnotes == NULL)
+    return false;
+
+  external = pnotes;
+
+  if (filedata->is_separate)
+    printf (_("In linked file '%s': "), filedata->file_name);
+  else
+    printf ("\n");
+  if (section)
+    printf (_("Displaying notes found in: %s\n"), printable_section_name (filedata, section));
+  else
+    printf (_("Displaying notes found at file offset 0x%08lx with length 0x%08lx:\n"),
+	    (unsigned long) offset, (unsigned long) length);
+
+  /* NB: Some note sections may have alignment value of 0 or 1.  gABI
+     specifies that notes should be aligned to 4 bytes in 32-bit
+     objects and to 8 bytes in 64-bit objects.  As a Linux extension,
+     we also support 4 byte alignment in 64-bit objects.  If section
+     alignment is less than 4, we treate alignment as 4 bytes.   */
+  if (align < 4)
+    align = 4;
+  else if (align != 4 && align != 8)
+    {
+      warn (_("Corrupt note: alignment %ld, expecting 4 or 8\n"),
+	    (long) align);
+      free (pnotes);
+      return false;
+    }
+
+  printf (_("  %-20s %-10s\tDescription\n"), _("Owner"), _("Data size"));
+
+  end = (char *) pnotes + length;
+  while ((char *) external < end)
+    {
+      Elf_Internal_Note inote;
+      size_t min_notesz;
+      char * next;
+      char * temp = NULL;
+      size_t data_remaining = end - (char *) external;
+
+      if (!is_ia64_vms (filedata))
+	{
+	  /* PR binutils/15191
+	     Make sure that there is enough data to read.  */
+	  min_notesz = offsetof (Elf_External_Note, name);
+	  if (data_remaining < min_notesz)
+	    {
+	      warn (ngettext ("Corrupt note: only %ld byte remains, "
+			      "not enough for a full note\n",
+			      "Corrupt note: only %ld bytes remain, "
+			      "not enough for a full note\n",
+			      data_remaining),
+		    (long) data_remaining);
+	      break;
+	    }
+	  data_remaining -= min_notesz;
+
+	  inote.type     = BYTE_GET (external->type);
+	  inote.namesz   = BYTE_GET (external->namesz);
+	  inote.namedata = external->name;
+	  inote.descsz   = BYTE_GET (external->descsz);
+	  inote.descdata = ((char *) external
+			    + ELF_NOTE_DESC_OFFSET (inote.namesz, align));
+	  inote.descpos  = offset + (inote.descdata - (char *) pnotes);
+	  next = ((char *) external
+		  + ELF_NOTE_NEXT_OFFSET (inote.namesz, inote.descsz, align));
+	}
+      else
+	{
+	  Elf64_External_VMS_Note *vms_external;
+
+	  /* PR binutils/15191
+	     Make sure that there is enough data to read.  */
+	  min_notesz = offsetof (Elf64_External_VMS_Note, name);
+	  if (data_remaining < min_notesz)
+	    {
+	      warn (ngettext ("Corrupt note: only %ld byte remains, "
+			      "not enough for a full note\n",
+			      "Corrupt note: only %ld bytes remain, "
+			      "not enough for a full note\n",
+			      data_remaining),
+		    (long) data_remaining);
+	      break;
+	    }
+	  data_remaining -= min_notesz;
+
+	  vms_external = (Elf64_External_VMS_Note *) external;
+	  inote.type     = BYTE_GET (vms_external->type);
+	  inote.namesz   = BYTE_GET (vms_external->namesz);
+	  inote.namedata = vms_external->name;
+	  inote.descsz   = BYTE_GET (vms_external->descsz);
+	  inote.descdata = inote.namedata + align_power (inote.namesz, 3);
+	  inote.descpos  = offset + (inote.descdata - (char *) pnotes);
+	  next = inote.descdata + align_power (inote.descsz, 3);
+	}
+
+      /* PR 17531: file: 3443835e.  */
+      /* PR 17531: file: id:000000,sig:11,src:006986,op:havoc,rep:4.  */
+      if ((size_t) (inote.descdata - inote.namedata) < inote.namesz
+	  || (size_t) (inote.descdata - inote.namedata) > data_remaining
+	  || (size_t) (next - inote.descdata) < inote.descsz
+	  || ((size_t) (next - inote.descdata)
+	      > data_remaining - (size_t) (inote.descdata - inote.namedata)))
+	{
+	  warn (_("note with invalid namesz and/or descsz found at offset 0x%lx\n"),
+		(unsigned long) ((char *) external - (char *) pnotes));
+	  warn (_(" type: 0x%lx, namesize: 0x%08lx, descsize: 0x%08lx, alignment: %u\n"),
+		inote.type, inote.namesz, inote.descsz, (int) align);
+	  break;
+	}
+
+      external = (Elf_External_Note *) next;
+
+      /* Verify that name is null terminated.  It appears that at least
+	 one version of Linux (RedHat 6.0) generates corefiles that don't
+	 comply with the ELF spec by failing to include the null byte in
+	 namesz.  */
+      if (inote.namesz > 0 && inote.namedata[inote.namesz - 1] != '\0')
+	{
+	  if ((size_t) (inote.descdata - inote.namedata) == inote.namesz)
+	    {
+	      temp = (char *) malloc (inote.namesz + 1);
+	      if (temp == NULL)
+		{
+		  error (_("Out of memory allocating space for inote name\n"));
+		  res = false;
+		  break;
+		}
+
+	      memcpy (temp, inote.namedata, inote.namesz);
+	      inote.namedata = temp;
+	    }
+	  inote.namedata[inote.namesz] = 0;
+	}
+
+      if (! process_note (& inote, filedata))
+	res = false;
+
+      free (temp);
+      temp = NULL;
+    }
+
+  free (pnotes);
+
+  return res;
+}
+
+static bool
+process_corefile_note_segments (Filedata * filedata)
+{
+  Elf_Internal_Phdr *segment;
+  unsigned int i;
+  bool res = true;
+
+  if (! get_program_headers (filedata))
+    return true;
+
+  for (i = 0, segment = filedata->program_headers;
+       i < filedata->file_header.e_phnum;
+       i++, segment++)
+    {
+      if (segment->p_type == PT_NOTE)
+	if (! process_notes_at (filedata, NULL,
+				(bfd_vma) segment->p_offset,
+				(bfd_vma) segment->p_filesz,
+				(bfd_vma) segment->p_align))
+	  res = false;
+    }
+
+  return res;
+}
+
+static bool
+process_v850_notes (Filedata * filedata, bfd_vma offset, bfd_vma length)
+{
+  Elf_External_Note * pnotes;
+  Elf_External_Note * external;
+  char * end;
+  bool res = true;
+
+  if (length <= 0)
+    return false;
+
+  pnotes = (Elf_External_Note *) get_data (NULL, filedata, offset, 1, length,
+                                           _("v850 notes"));
+  if (pnotes == NULL)
+    return false;
+
+  external = pnotes;
+  end = (char*) pnotes + length;
+
+  printf (_("\nDisplaying contents of Renesas V850 notes section at offset 0x%lx with length 0x%lx:\n"),
+	  (unsigned long) offset, (unsigned long) length);
+
+  while ((char *) external + sizeof (Elf_External_Note) < end)
+    {
+      Elf_External_Note * next;
+      Elf_Internal_Note inote;
+
+      inote.type     = BYTE_GET (external->type);
+      inote.namesz   = BYTE_GET (external->namesz);
+      inote.namedata = external->name;
+      inote.descsz   = BYTE_GET (external->descsz);
+      inote.descdata = inote.namedata + align_power (inote.namesz, 2);
+      inote.descpos  = offset + (inote.descdata - (char *) pnotes);
+
+      if (inote.descdata < (char *) pnotes || inote.descdata >= end)
+	{
+	  warn (_("Corrupt note: name size is too big: %lx\n"), inote.namesz);
+	  inote.descdata = inote.namedata;
+	  inote.namesz   = 0;
+	}
+
+      next = (Elf_External_Note *) (inote.descdata + align_power (inote.descsz, 2));
+
+      if (   ((char *) next > end)
+	  || ((char *) next <  (char *) pnotes))
+	{
+	  warn (_("corrupt descsz found in note at offset 0x%lx\n"),
+		(unsigned long) ((char *) external - (char *) pnotes));
+	  warn (_(" type: 0x%lx, namesize: 0x%lx, descsize: 0x%lx\n"),
+		inote.type, inote.namesz, inote.descsz);
+	  break;
+	}
+
+      external = next;
+
+      /* Prevent out-of-bounds indexing.  */
+      if (   inote.namedata + inote.namesz > end
+	  || inote.namedata + inote.namesz < inote.namedata)
+        {
+          warn (_("corrupt namesz found in note at offset 0x%lx\n"),
+                (unsigned long) ((char *) external - (char *) pnotes));
+          warn (_(" type: 0x%lx, namesize: 0x%lx, descsize: 0x%lx\n"),
+                inote.type, inote.namesz, inote.descsz);
+          break;
+        }
+
+      printf ("  %s: ", get_v850_elf_note_type (inote.type));
+
+      if (! print_v850_note (& inote))
+	{
+	  res = false;
+	  printf ("<corrupt sizes: namesz: %lx, descsz: %lx>\n",
+		  inote.namesz, inote.descsz);
+	}
+    }
+
+  free (pnotes);
+
+  return res;
+}
+
+static bool
+process_note_sections (Filedata * filedata)
+{
+  Elf_Internal_Shdr *section;
+  unsigned long i;
+  unsigned int n = 0;
+  bool res = true;
+
+  for (i = 0, section = filedata->section_headers;
+       i < filedata->file_header.e_shnum && section != NULL;
+       i++, section++)
+    {
+      if (section->sh_type == SHT_NOTE)
+	{
+	  if (! process_notes_at (filedata, section,
+				  (bfd_vma) section->sh_offset,
+				  (bfd_vma) section->sh_size,
+				  (bfd_vma) section->sh_addralign))
+	    res = false;
+	  n++;
+	}
+
+      if ((   filedata->file_header.e_machine == EM_V800
+	   || filedata->file_header.e_machine == EM_V850
+	   || filedata->file_header.e_machine == EM_CYGNUS_V850)
+	  && section->sh_type == SHT_RENESAS_INFO)
+	{
+	  if (! process_v850_notes (filedata,
+				    (bfd_vma) section->sh_offset,
+				    (bfd_vma) section->sh_size))
+	    res = false;
+	  n++;
+	}
+    }
+
+  if (n == 0)
+    /* Try processing NOTE segments instead.  */
+    return process_corefile_note_segments (filedata);
+
+  return res;
+}
+
+static bool
+process_notes (Filedata * filedata)
+{
+  /* If we have not been asked to display the notes then do nothing.  */
+  if (! do_notes)
+    return true;
+
+  if (filedata->file_header.e_type != ET_CORE)
+    return process_note_sections (filedata);
+
+  /* No program headers means no NOTE segment.  */
+  if (filedata->file_header.e_phnum > 0)
+    return process_corefile_note_segments (filedata);
+
+  if (filedata->is_separate)
+    printf (_("No notes found in linked file '%s'.\n"),
+	    filedata->file_name);
+  else
+    printf (_("No notes found file.\n"));
+
+  return true;
+}
+
+static unsigned char *
+display_public_gnu_attributes (unsigned char * start,
+			       const unsigned char * const end)
+{
+  printf (_("  Unknown GNU attribute: %s\n"), start);
+
+  start += strnlen ((char *) start, end - start);
+  display_raw_attribute (start, end);
+
+  return (unsigned char *) end;
+}
+
+static unsigned char *
+display_generic_attribute (unsigned char * start,
+			   unsigned int tag,
+			   const unsigned char * const end)
+{
+  if (tag == 0)
+    return (unsigned char *) end;
+
+  return display_tag_value (tag, start, end);
+}
+
+static bool
+process_arch_specific (Filedata * filedata)
+{
+  if (! do_arch)
+    return true;
+
+  switch (filedata->file_header.e_machine)
+    {
+    case EM_ARC:
+    case EM_ARC_COMPACT:
+    case EM_ARC_COMPACT2:
+      return process_attributes (filedata, "ARC", SHT_ARC_ATTRIBUTES,
+				 display_arc_attribute,
+				 display_generic_attribute);
+    case EM_ARM:
+      return process_attributes (filedata, "aeabi", SHT_ARM_ATTRIBUTES,
+				 display_arm_attribute,
+				 display_generic_attribute);
+
+    case EM_MIPS:
+    case EM_MIPS_RS3_LE:
+      return process_mips_specific (filedata);
+
+    case EM_MSP430:
+     return process_attributes (filedata, "mspabi", SHT_MSP430_ATTRIBUTES,
+				display_msp430_attribute,
+				display_msp430_gnu_attribute);
+
+    case EM_RISCV:
+     return process_attributes (filedata, "riscv", SHT_RISCV_ATTRIBUTES,
+				display_riscv_attribute,
+				display_generic_attribute);
+
+    case EM_NDS32:
+      return process_nds32_specific (filedata);
+
+    case EM_68K:
+      return process_attributes (filedata, NULL, SHT_GNU_ATTRIBUTES, NULL,
+				 display_m68k_gnu_attribute);
+
+    case EM_PPC:
+    case EM_PPC64:
+      return process_attributes (filedata, NULL, SHT_GNU_ATTRIBUTES, NULL,
+				 display_power_gnu_attribute);
+
+    case EM_S390:
+    case EM_S390_OLD:
+      return process_attributes (filedata, NULL, SHT_GNU_ATTRIBUTES, NULL,
+				 display_s390_gnu_attribute);
+
+    case EM_SPARC:
+    case EM_SPARC32PLUS:
+    case EM_SPARCV9:
+      return process_attributes (filedata, NULL, SHT_GNU_ATTRIBUTES, NULL,
+				 display_sparc_gnu_attribute);
+
+    case EM_TI_C6000:
+      return process_attributes (filedata, "c6xabi", SHT_C6000_ATTRIBUTES,
+				 display_tic6x_attribute,
+				 display_generic_attribute);
+
+    case EM_CSKY:
+      return process_attributes (filedata, "csky", SHT_CSKY_ATTRIBUTES,
+				 display_csky_attribute, NULL);
+
+    default:
+      return process_attributes (filedata, "gnu", SHT_GNU_ATTRIBUTES,
+				 display_public_gnu_attributes,
+				 display_generic_attribute);
+    }
+}
+
+static bool
+get_file_header (Filedata * filedata)
+{
+  /* Read in the identity array.  */
+  if (fread (filedata->file_header.e_ident, EI_NIDENT, 1, filedata->handle) != 1)
+    return false;
+
+  /* Determine how to read the rest of the header.  */
+  switch (filedata->file_header.e_ident[EI_DATA])
+    {
+    default:
+    case ELFDATANONE:
+    case ELFDATA2LSB:
+      byte_get = byte_get_little_endian;
+      byte_put = byte_put_little_endian;
+      break;
+    case ELFDATA2MSB:
+      byte_get = byte_get_big_endian;
+      byte_put = byte_put_big_endian;
+      break;
+    }
+
+  /* For now we only support 32 bit and 64 bit ELF files.  */
+  is_32bit_elf = (filedata->file_header.e_ident[EI_CLASS] != ELFCLASS64);
+
+  /* Read in the rest of the header.  */
+  if (is_32bit_elf)
+    {
+      Elf32_External_Ehdr ehdr32;
+
+      if (fread (ehdr32.e_type, sizeof (ehdr32) - EI_NIDENT, 1, filedata->handle) != 1)
+	return false;
+
+      filedata->file_header.e_type      = BYTE_GET (ehdr32.e_type);
+      filedata->file_header.e_machine   = BYTE_GET (ehdr32.e_machine);
+      filedata->file_header.e_version   = BYTE_GET (ehdr32.e_version);
+      filedata->file_header.e_entry     = BYTE_GET (ehdr32.e_entry);
+      filedata->file_header.e_phoff     = BYTE_GET (ehdr32.e_phoff);
+      filedata->file_header.e_shoff     = BYTE_GET (ehdr32.e_shoff);
+      filedata->file_header.e_flags     = BYTE_GET (ehdr32.e_flags);
+      filedata->file_header.e_ehsize    = BYTE_GET (ehdr32.e_ehsize);
+      filedata->file_header.e_phentsize = BYTE_GET (ehdr32.e_phentsize);
+      filedata->file_header.e_phnum     = BYTE_GET (ehdr32.e_phnum);
+      filedata->file_header.e_shentsize = BYTE_GET (ehdr32.e_shentsize);
+      filedata->file_header.e_shnum     = BYTE_GET (ehdr32.e_shnum);
+      filedata->file_header.e_shstrndx  = BYTE_GET (ehdr32.e_shstrndx);
+    }
+  else
+    {
+      Elf64_External_Ehdr ehdr64;
+
+      /* If we have been compiled with sizeof (bfd_vma) == 4, then
+	 we will not be able to cope with the 64bit data found in
+	 64 ELF files.  Detect this now and abort before we start
+	 overwriting things.  */
+      if (sizeof (bfd_vma) < 8)
+	{
+	  error (_("This instance of readelf has been built without support for a\n\
+64 bit data type and so it cannot read 64 bit ELF files.\n"));
+	  return false;
+	}
+
+      if (fread (ehdr64.e_type, sizeof (ehdr64) - EI_NIDENT, 1, filedata->handle) != 1)
+	return false;
+
+      filedata->file_header.e_type      = BYTE_GET (ehdr64.e_type);
+      filedata->file_header.e_machine   = BYTE_GET (ehdr64.e_machine);
+      filedata->file_header.e_version   = BYTE_GET (ehdr64.e_version);
+      filedata->file_header.e_entry     = BYTE_GET (ehdr64.e_entry);
+      filedata->file_header.e_phoff     = BYTE_GET (ehdr64.e_phoff);
+      filedata->file_header.e_shoff     = BYTE_GET (ehdr64.e_shoff);
+      filedata->file_header.e_flags     = BYTE_GET (ehdr64.e_flags);
+      filedata->file_header.e_ehsize    = BYTE_GET (ehdr64.e_ehsize);
+      filedata->file_header.e_phentsize = BYTE_GET (ehdr64.e_phentsize);
+      filedata->file_header.e_phnum     = BYTE_GET (ehdr64.e_phnum);
+      filedata->file_header.e_shentsize = BYTE_GET (ehdr64.e_shentsize);
+      filedata->file_header.e_shnum     = BYTE_GET (ehdr64.e_shnum);
+      filedata->file_header.e_shstrndx  = BYTE_GET (ehdr64.e_shstrndx);
+    }
+
+  return true;
+}
+
+static void
+free_filedata (Filedata *filedata)
+{
+  free (filedata->program_interpreter);
+  free (filedata->program_headers);
+  free (filedata->section_headers);
+  free (filedata->string_table);
+  free (filedata->dump.dump_sects);
+  free (filedata->dynamic_strings);
+  free (filedata->dynamic_symbols);
+  free (filedata->dynamic_syminfo);
+  free (filedata->dynamic_section);
+
+  while (filedata->symtab_shndx_list != NULL)
+    {
+      elf_section_list *next = filedata->symtab_shndx_list->next;
+      free (filedata->symtab_shndx_list);
+      filedata->symtab_shndx_list = next;
+    }
+
+  free (filedata->section_headers_groups);
+
+  if (filedata->section_groups)
+    {
+      size_t i;
+      struct group_list * g;
+      struct group_list * next;
+
+      for (i = 0; i < filedata->group_count; i++)
+	{
+	  for (g = filedata->section_groups [i].root; g != NULL; g = next)
+	    {
+	      next = g->next;
+	      free (g);
+	    }
+	}
+
+      free (filedata->section_groups);
+    }
+  memset (&filedata->section_headers, 0,
+	  sizeof (Filedata) - offsetof (Filedata, section_headers));
+}
+
+static void
+close_file (Filedata * filedata)
+{
+  if (filedata)
+    {
+      if (filedata->handle)
+	fclose (filedata->handle);
+      free (filedata);
+    }
+}
+
+void
+close_debug_file (void * data)
+{
+  free_filedata ((Filedata *) data);
+  close_file ((Filedata *) data);
+}
+
+static Filedata *
+open_file (const char * pathname, bool is_separate)
+{
+  struct stat  statbuf;
+  Filedata *   filedata = NULL;
+
+  if (stat (pathname, & statbuf) < 0
+      || ! S_ISREG (statbuf.st_mode))
+    goto fail;
+
+  filedata = calloc (1, sizeof * filedata);
+  if (filedata == NULL)
+    goto fail;
+
+  filedata->handle = fopen (pathname, "rb");
+  if (filedata->handle == NULL)
+    goto fail;
+
+  filedata->file_size = (bfd_size_type) statbuf.st_size;
+  filedata->file_name = pathname;
+  filedata->is_separate = is_separate;
+
+  if (! get_file_header (filedata))
+    goto fail;
+
+  if (!get_section_headers (filedata, false))
+    goto fail;
+
+  return filedata;
+
+ fail:
+  if (filedata)
+    {
+      if (filedata->handle)
+        fclose (filedata->handle);
+      free (filedata);
+    }
+  return NULL;
+}
+
+void *
+open_debug_file (const char * pathname)
+{
+  return open_file (pathname, true);
+}
+
+static void
+initialise_dump_sects (Filedata * filedata)
+{
+  /* Initialise the dump_sects array from the cmdline_dump_sects array.
+     Note we do this even if cmdline_dump_sects is empty because we
+     must make sure that the dump_sets array is zeroed out before each
+     object file is processed.  */
+  if (filedata->dump.num_dump_sects > cmdline.num_dump_sects)
+    memset (filedata->dump.dump_sects, 0,
+	    filedata->dump.num_dump_sects * sizeof (*filedata->dump.dump_sects));
+
+  if (cmdline.num_dump_sects > 0)
+    {
+      if (filedata->dump.num_dump_sects == 0)
+	/* A sneaky way of allocating the dump_sects array.  */
+	request_dump_bynumber (&filedata->dump, cmdline.num_dump_sects, 0);
+
+      assert (filedata->dump.num_dump_sects >= cmdline.num_dump_sects);
+      memcpy (filedata->dump.dump_sects, cmdline.dump_sects,
+	      cmdline.num_dump_sects * sizeof (*filedata->dump.dump_sects));
+    }
+}
+
+/* Process one ELF object file according to the command line options.
+   This file may actually be stored in an archive.  The file is
+   positioned at the start of the ELF object.  Returns TRUE if no
+   problems were encountered, FALSE otherwise.  */
+
+static bool
+process_object (Filedata * filedata)
+{
+  bool have_separate_files;
+  unsigned int i;
+  bool res;
+
+  if (! get_file_header (filedata))
+    {
+      error (_("%s: Failed to read file header\n"), filedata->file_name);
+      return false;
+    }
+
+  /* Initialise per file variables.  */
+  for (i = ARRAY_SIZE (filedata->version_info); i--;)
+    filedata->version_info[i] = 0;
+
+  for (i = ARRAY_SIZE (filedata->dynamic_info); i--;)
+    filedata->dynamic_info[i] = 0;
+  filedata->dynamic_info_DT_GNU_HASH = 0;
+  filedata->dynamic_info_DT_MIPS_XHASH = 0;
+
+  /* Process the file.  */
+  if (show_name)
+    printf (_("\nFile: %s\n"), filedata->file_name);
+
+  initialise_dump_sects (filedata);
+
+  /* There may be some extensions in the first section header.  Don't
+     bomb if we can't read it.  */
+  get_section_headers (filedata, true);
+
+  if (! process_file_header (filedata))
+    {
+      res = false;
+      goto out;
+    }
+
+  /* Throw away the single section header read above, so that we
+     re-read the entire set.  */
+  free (filedata->section_headers);
+  filedata->section_headers = NULL;
+
+  if (! process_section_headers (filedata))
+    {
+      /* Without loaded section headers we cannot process lots of things.  */
+      do_unwind = do_version = do_dump = do_arch = false;
+
+      if (! do_using_dynamic)
+	do_syms = do_dyn_syms = do_reloc = false;
+    }
+
+  if (! process_section_groups (filedata))
+    /* Without loaded section groups we cannot process unwind.  */
+    do_unwind = false;
+
+  process_program_headers (filedata);
+
+  res = process_dynamic_section (filedata);
+
+  if (! process_relocs (filedata))
+    res = false;
+
+  if (! process_unwind (filedata))
+    res = false;
+
+  if (! process_symbol_table (filedata))
+    res = false;
+
+  if (! process_lto_symbol_tables (filedata))
+    res = false;
+
+  if (! process_syminfo (filedata))
+    res = false;
+
+  if (! process_version_sections (filedata))
+    res = false;
+
+  if (filedata->file_header.e_shstrndx != SHN_UNDEF)
+    have_separate_files = load_separate_debug_files (filedata, filedata->file_name);
+  else
+    have_separate_files = false;
+
+  if (! process_section_contents (filedata))
+    res = false;
+
+  if (have_separate_files)
+    {
+      separate_info * d;
+
+      for (d = first_separate_info; d != NULL; d = d->next)
+	{
+	  initialise_dump_sects (d->handle);
+
+	  if (process_links && ! process_file_header (d->handle))
+	    res = false;
+	  else if (! process_section_headers (d->handle))
+	    res = false;
+	  else if (! process_section_contents (d->handle))
+	    res = false;
+	  else if (process_links)
+	    {
+	      if (! process_section_groups (d->handle))
+		res = false;
+	      process_program_headers (d->handle);
+	      if (! process_dynamic_section (d->handle))
+		res = false;
+	      if (! process_relocs (d->handle))
+		res = false;
+	      if (! process_unwind (d->handle))
+		res = false;
+	      if (! process_symbol_table (d->handle))
+		res = false;
+	      if (! process_lto_symbol_tables (d->handle))
+		res = false;
+	      if (! process_syminfo (d->handle))
+		res = false;
+	      if (! process_version_sections (d->handle))
+		res = false;
+	      if (! process_notes (d->handle))
+		res = false;
+	    }
+	}
+
+      /* The file handles are closed by the call to free_debug_memory() below.  */
+    }
+
+  if (! process_notes (filedata))
+    res = false;
+
+  if (! process_gnu_liblist (filedata))
+    res = false;
+
+  if (! process_arch_specific (filedata))
+    res = false;
+
+ out:
+  free_filedata (filedata);
+
+  free_debug_memory ();
+
+  return res;
+}
+
+/* Process an ELF archive.
+   On entry the file is positioned just after the ARMAG string.
+   Returns TRUE upon success, FALSE otherwise.  */
+
+static bool
+process_archive (Filedata * filedata, bool is_thin_archive)
+{
+  struct archive_info arch;
+  struct archive_info nested_arch;
+  size_t got;
+  bool ret = true;
+
+  show_name = true;
+
+  /* The ARCH structure is used to hold information about this archive.  */
+  arch.file_name = NULL;
+  arch.file = NULL;
+  arch.index_array = NULL;
+  arch.sym_table = NULL;
+  arch.longnames = NULL;
+
+  /* The NESTED_ARCH structure is used as a single-item cache of information
+     about a nested archive (when members of a thin archive reside within
+     another regular archive file).  */
+  nested_arch.file_name = NULL;
+  nested_arch.file = NULL;
+  nested_arch.index_array = NULL;
+  nested_arch.sym_table = NULL;
+  nested_arch.longnames = NULL;
+
+  if (setup_archive (&arch, filedata->file_name, filedata->handle,
+		     filedata->file_size, is_thin_archive,
+		     do_archive_index) != 0)
+    {
+      ret = false;
+      goto out;
+    }
+
+  if (do_archive_index)
+    {
+      if (arch.sym_table == NULL)
+	error (_("%s: unable to dump the index as none was found\n"),
+	       filedata->file_name);
+      else
+	{
+	  unsigned long i, l;
+	  unsigned long current_pos;
+
+	  printf (_("Index of archive %s: (%lu entries, 0x%lx bytes "
+		    "in the symbol table)\n"),
+		  filedata->file_name, (unsigned long) arch.index_num,
+		  arch.sym_size);
+
+	  current_pos = ftell (filedata->handle);
+
+	  for (i = l = 0; i < arch.index_num; i++)
+	    {
+	      if (i == 0
+		  || (i > 0 && arch.index_array[i] != arch.index_array[i - 1]))
+		{
+		  char * member_name
+		    = get_archive_member_name_at (&arch, arch.index_array[i],
+						  &nested_arch);
+
+		  if (member_name != NULL)
+		    {
+		      char * qualified_name
+			= make_qualified_name (&arch, &nested_arch,
+					       member_name);
+
+		      if (qualified_name != NULL)
+			{
+			  printf (_("Contents of binary %s at offset "),
+				  qualified_name);
+			  (void) print_vma (arch.index_array[i], PREFIX_HEX);
+			  putchar ('\n');
+			  free (qualified_name);
+			}
+		      free (member_name);
+		    }
+		}
+
+	      if (l >= arch.sym_size)
+		{
+		  error (_("%s: end of the symbol table reached "
+			   "before the end of the index\n"),
+			 filedata->file_name);
+		  ret = false;
+		  break;
+		}
+	      /* PR 17531: file: 0b6630b2.  */
+	      printf ("\t%.*s\n",
+		      (int) (arch.sym_size - l), arch.sym_table + l);
+	      l += strnlen (arch.sym_table + l, arch.sym_size - l) + 1;
+	    }
+
+	  if (arch.uses_64bit_indices)
+	    l = (l + 7) & ~ 7;
+	  else
+	    l += l & 1;
+
+	  if (l < arch.sym_size)
+	    {
+	      error (ngettext ("%s: %ld byte remains in the symbol table, "
+			       "but without corresponding entries in "
+			       "the index table\n",
+			       "%s: %ld bytes remain in the symbol table, "
+			       "but without corresponding entries in "
+			       "the index table\n",
+			       arch.sym_size - l),
+		     filedata->file_name, arch.sym_size - l);
+	      ret = false;
+	    }
+
+	  if (fseek (filedata->handle, current_pos, SEEK_SET) != 0)
+	    {
+	      error (_("%s: failed to seek back to start of object files "
+		       "in the archive\n"),
+		     filedata->file_name);
+	      ret = false;
+	      goto out;
+	    }
+	}
+
+      if (!do_dynamic && !do_syms && !do_reloc && !do_unwind && !do_sections
+	  && !do_segments && !do_header && !do_dump && !do_version
+	  && !do_histogram && !do_debugging && !do_arch && !do_notes
+	  && !do_section_groups && !do_dyn_syms)
+	{
+	  ret = true; /* Archive index only.  */
+	  goto out;
+	}
+    }
+
+  while (1)
+    {
+      char * name;
+      size_t namelen;
+      char * qualified_name;
+
+      /* Read the next archive header.  */
+      if (fseek (filedata->handle, arch.next_arhdr_offset, SEEK_SET) != 0)
+	{
+	  error (_("%s: failed to seek to next archive header\n"),
+		 arch.file_name);
+	  ret = false;
+	  break;
+	}
+      got = fread (&arch.arhdr, 1, sizeof arch.arhdr, filedata->handle);
+      if (got != sizeof arch.arhdr)
+	{
+	  if (got == 0)
+	    break;
+	  /* PR 24049 - we cannot use filedata->file_name as this will
+	     have already been freed.  */
+	  error (_("%s: failed to read archive header\n"), arch.file_name);
+
+	  ret = false;
+	  break;
+	}
+      if (memcmp (arch.arhdr.ar_fmag, ARFMAG, 2) != 0)
+	{
+	  error (_("%s: did not find a valid archive header\n"),
+		 arch.file_name);
+	  ret = false;
+	  break;
+	}
+
+      arch.next_arhdr_offset += sizeof arch.arhdr;
+
+      filedata->archive_file_size = strtoul (arch.arhdr.ar_size, NULL, 10);
+      if (filedata->archive_file_size & 01)
+	++filedata->archive_file_size;
+
+      name = get_archive_member_name (&arch, &nested_arch);
+      if (name == NULL)
+	{
+	  error (_("%s: bad archive file name\n"), arch.file_name);
+	  ret = false;
+	  break;
+	}
+      namelen = strlen (name);
+
+      qualified_name = make_qualified_name (&arch, &nested_arch, name);
+      if (qualified_name == NULL)
+	{
+	  error (_("%s: bad archive file name\n"), arch.file_name);
+	  free (name);
+	  ret = false;
+	  break;
+	}
+
+      if (is_thin_archive && arch.nested_member_origin == 0)
+	{
+	  /* This is a proxy for an external member of a thin archive.  */
+	  Filedata * member_filedata;
+	  char * member_file_name = adjust_relative_path
+	    (filedata->file_name, name, namelen);
+
+	  free (name);
+	  if (member_file_name == NULL)
+	    {
+	      free (qualified_name);
+	      ret = false;
+	      break;
+	    }
+
+	  member_filedata = open_file (member_file_name, false);
+	  if (member_filedata == NULL)
+	    {
+	      error (_("Input file '%s' is not readable.\n"), member_file_name);
+	      free (member_file_name);
+	      free (qualified_name);
+	      ret = false;
+	      break;
+	    }
+
+	  filedata->archive_file_offset = arch.nested_member_origin;
+	  member_filedata->file_name = qualified_name;
+
+	  /* The call to process_object() expects the file to be at the beginning.  */
+	  rewind (member_filedata->handle);
+
+	  if (! process_object (member_filedata))
+	    ret = false;
+
+	  close_file (member_filedata);
+	  free (member_file_name);
+	}
+      else if (is_thin_archive)
+	{
+	  Filedata thin_filedata;
+
+	  memset (&thin_filedata, 0, sizeof (thin_filedata));
+
+	  /* PR 15140: Allow for corrupt thin archives.  */
+	  if (nested_arch.file == NULL)
+	    {
+	      error (_("%s: contains corrupt thin archive: %s\n"),
+		     qualified_name, name);
+	      free (qualified_name);
+	      free (name);
+	      ret = false;
+	      break;
+	    }
+	  free (name);
+
+	  /* This is a proxy for a member of a nested archive.  */
+	  filedata->archive_file_offset
+	    = arch.nested_member_origin + sizeof arch.arhdr;
+
+	  /* The nested archive file will have been opened and setup by
+	     get_archive_member_name.  */
+	  if (fseek (nested_arch.file, filedata->archive_file_offset,
+		     SEEK_SET) != 0)
+	    {
+	      error (_("%s: failed to seek to archive member.\n"),
+		     nested_arch.file_name);
+	      free (qualified_name);
+	      ret = false;
+	      break;
+	    }
+
+	  thin_filedata.handle = nested_arch.file;
+	  thin_filedata.file_name = qualified_name;
+
+	  if (! process_object (& thin_filedata))
+	    ret = false;
+	}
+      else
+	{
+	  free (name);
+	  filedata->archive_file_offset = arch.next_arhdr_offset;
+	  filedata->file_name = qualified_name;
+	  if (! process_object (filedata))
+	    ret = false;
+	  arch.next_arhdr_offset += filedata->archive_file_size;
+	  /* Stop looping with "negative" archive_file_size.  */
+	  if (arch.next_arhdr_offset < filedata->archive_file_size)
+	    arch.next_arhdr_offset = -1ul;
+	}
+
+      free (qualified_name);
+    }
+
+ out:
+  if (nested_arch.file != NULL)
+    fclose (nested_arch.file);
+  release_archive (&nested_arch);
+  release_archive (&arch);
+
+  return ret;
+}
+
+static bool
+process_file (char * file_name)
+{
+  Filedata * filedata = NULL;
+  struct stat statbuf;
+  char armag[SARMAG];
+  bool ret = false;
+  char * name;
+  char * saved_program_name;
+
+  /* Overload program_name to include file_name.  Doing this means
+     that warning/error messages will positively identify the file
+     concerned even when multiple instances of readelf are running.  */
+  name = xmalloc (strlen (program_name) + strlen (file_name) + 3);
+  sprintf (name, "%s: %s", program_name, file_name);
+  saved_program_name = program_name;
+  program_name = name;
+
+  if (stat (file_name, &statbuf) < 0)
+    {
+      if (errno == ENOENT)
+	error (_("No such file\n"));
+      else
+	error (_("Could not locate file.  System error message: %s\n"),
+	       strerror (errno));
+      goto done;
+    }
+
+  if (! S_ISREG (statbuf.st_mode))
+    {
+      error (_("Not an ordinary file\n"));
+      goto done;
+    }
+
+  filedata = calloc (1, sizeof * filedata);
+  if (filedata == NULL)
+    {
+      error (_("Out of memory allocating file data structure\n"));
+      goto done;
+    }
+
+  filedata->file_name = file_name;
+  filedata->handle = fopen (file_name, "rb");
+  if (filedata->handle == NULL)
+    {
+      error (_("Not readable\n"));
+      goto done;
+    }
+
+  if (fread (armag, SARMAG, 1, filedata->handle) != 1)
+    {
+      error (_("Failed to read file's magic number\n"));
+      goto done;
+    }
+
+  filedata->file_size = (bfd_size_type) statbuf.st_size;
+  filedata->is_separate = false;
+
+  if (memcmp (armag, ARMAG, SARMAG) == 0)
+    {
+      if (process_archive (filedata, false))
+	ret = true;
+    }
+  else if (memcmp (armag, ARMAGT, SARMAG) == 0)
+    {
+      if (process_archive (filedata, true))
+	ret = true;
+    }
+  else
+    {
+      if (do_archive_index && !check_all)
+	error (_("Not an archive so its index cannot be displayed.\n"));
+
+      rewind (filedata->handle);
+      filedata->archive_file_size = filedata->archive_file_offset = 0;
+
+      if (process_object (filedata))
+	ret = true;
+    }
+
+ done:
+  if (filedata)
+    {
+      if (filedata->handle != NULL)
+	fclose (filedata->handle);
+      free (filedata->section_headers);
+      free (filedata->program_headers);
+      free (filedata->string_table);
+      free (filedata->dump.dump_sects);
+      free (filedata);
+    }
+  free (program_name);
+  program_name = saved_program_name;
+
+  free (ba_cache.strtab);
+  ba_cache.strtab = NULL;
+  free (ba_cache.symtab);
+  ba_cache.symtab = NULL;
+  ba_cache.filedata = NULL;
+
+  return ret;
+}
+
+#ifdef SUPPORT_DISASSEMBLY
+/* Needed by the i386 disassembler.  For extra credit, someone could
+   fix this so that we insert symbolic addresses here, esp for GOT/PLT
+   symbols.  */
+
+void
+print_address (unsigned int addr, FILE * outfile)
+{
+  fprintf (outfile,"0x%8.8x", addr);
+}
+
+/* Needed by the i386 disassembler.  */
+
+void
+db_task_printsym (unsigned int addr)
+{
+  print_address (addr, stderr);
+}
+#endif
+
+int
+main (int argc, char ** argv)
+{
+  int err;
+
+#ifdef HAVE_LC_MESSAGES
+  setlocale (LC_MESSAGES, "");
+#endif
+  setlocale (LC_CTYPE, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+
+  expandargv (&argc, &argv);
+
+  parse_args (& cmdline, argc, argv);
+
+  if (optind < (argc - 1))
+    /* When displaying information for more than one file,
+       prefix the information with the file name.  */
+    show_name = true;
+  else if (optind >= argc)
+    {
+      /* Ensure that the warning is always displayed.  */
+      do_checks = true;
+
+      warn (_("Nothing to do.\n"));
+      usage (stderr);
+    }
+
+  err = false;
+  while (optind < argc)
+    if (! process_file (argv[optind++]))
+      err = true;
+
+  free (cmdline.dump_sects);
+
+  free (dump_ctf_symtab_name);
+  free (dump_ctf_strtab_name);
+  free (dump_ctf_parent_name);
+
+  return err ? EXIT_FAILURE : EXIT_SUCCESS;
+}
diff -rupN binutils.orig/binutils/strings.c binutils-2.37/binutils/strings.c
--- binutils.orig/binutils/strings.c	2021-11-09 12:34:21.663802935 +0000
+++ binutils-2.37/binutils/strings.c	2021-11-09 12:34:46.293643851 +0000
@@ -55,6 +55,19 @@
    -T {bfdname}
 		Specify a non-default object file format.
 
+  --unicode={default|locale|invalid|hex|escape|highlight}
+  -u {d|l|i|x|e|h}
+                Determine how to handle UTF-8 unicode characters.  The default
+		is no special treatment.  All other versions of this option
+		only apply if the encoding is valid and enabling the option
+		implies --encoding=S.
+		The 'locale' option displays the characters according to the
+		current locale.  The 'invalid' option treats them as
+		non-string characters.  The 'hex' option displays them as hex
+		byte sequences.  The 'escape' option displays them as escape
+		sequences and the 'highlight' option displays them as
+		coloured escape sequences.
+
   --output-separator=sep_string
   -s sep_string	String used to separate parsed strings in output.
 		Default is newline.
@@ -76,6 +89,22 @@
 #include "safe-ctype.h"
 #include "bucomm.h"
 
+#ifndef streq
+#define streq(a,b) (strcmp ((a),(b)) == 0)
+#endif
+
+typedef enum unicode_display_type
+{
+  unicode_default = 0,
+  unicode_locale,
+  unicode_escape,
+  unicode_hex,
+  unicode_highlight,
+  unicode_invalid
+} unicode_display_type;
+
+static unicode_display_type unicode_display = unicode_default;
+
 #define STRING_ISGRAPHIC(c) \
       (   (c) >= 0 \
        && (c) <= 255 \
@@ -94,7 +123,7 @@ extern int errno;
 static int address_radix;
 
 /* Minimum length of sequence of graphic chars to trigger output.  */
-static int string_min;
+static uint string_min;
 
 /* Whether or not we include all whitespace as a graphic char.   */
 static bool include_all_whitespace;
@@ -121,21 +150,22 @@ static char *output_separator;
 static struct option long_options[] =
 {
   {"all", no_argument, NULL, 'a'},
+  {"bytes", required_argument, NULL, 'n'},
   {"data", no_argument, NULL, 'd'},
+  {"encoding", required_argument, NULL, 'e'},
+  {"help", no_argument, NULL, 'h'},
+  {"include-all-whitespace", no_argument, NULL, 'w'},
+  {"output-separator", required_argument, NULL, 's'},
   {"print-file-name", no_argument, NULL, 'f'},
-  {"bytes", required_argument, NULL, 'n'},
   {"radix", required_argument, NULL, 't'},
-  {"include-all-whitespace", no_argument, NULL, 'w'},
-  {"encoding", required_argument, NULL, 'e'},
   {"target", required_argument, NULL, 'T'},
-  {"output-separator", required_argument, NULL, 's'},
-  {"help", no_argument, NULL, 'h'},
+  {"unicode", required_argument, NULL, 'U'},
   {"version", no_argument, NULL, 'v'},
   {NULL, 0, NULL, 0}
 };
 
 static bool strings_file (char *);
-static void print_strings (const char *, FILE *, file_ptr, int, int, char *);
+static void print_strings (const char *, FILE *, file_ptr, int, char *);
 static void usage (FILE *, int) ATTRIBUTE_NORETURN;
 
 int main (int, char **);
@@ -171,7 +201,7 @@ main (int argc, char **argv)
   encoding = 's';
   output_separator = NULL;
 
-  while ((optc = getopt_long (argc, argv, "adfhHn:wot:e:T:s:Vv0123456789",
+  while ((optc = getopt_long (argc, argv, "adfhHn:wot:e:T:s:U:Vv0123456789",
 			      long_options, (int *) 0)) != EOF)
     {
       switch (optc)
@@ -244,6 +274,23 @@ main (int argc, char **argv)
 	  output_separator = optarg;
           break;
 
+	case 'U':
+	  if (streq (optarg, "default") || streq (optarg, "d"))
+	    unicode_display = unicode_default;
+	  else if (streq (optarg, "locale") || streq (optarg, "l"))
+	    unicode_display = unicode_locale;
+	  else if (streq (optarg, "escape") || streq (optarg, "e"))
+	    unicode_display = unicode_escape;
+	  else if (streq (optarg, "invalid") || streq (optarg, "i"))
+	    unicode_display = unicode_invalid;
+	  else if (streq (optarg, "hex") || streq (optarg, "x"))
+	    unicode_display = unicode_hex;
+	  else if (streq (optarg, "highlight") || streq (optarg, "h"))
+	    unicode_display = unicode_highlight;
+	  else
+	    fatal (_("invalid argument to -U/--unicode: %s"), optarg);
+	  break;
+
 	case 'V':
 	case 'v':
 	  print_version ("strings");
@@ -258,6 +305,9 @@ main (int argc, char **argv)
 	}
     }
 
+  if (unicode_display != unicode_default)
+    encoding = 'S';
+
   if (numeric_opt != 0)
     {
       string_min = (int) strtoul (argv[numeric_opt - 1] + 1, &s, 0);
@@ -293,14 +343,14 @@ main (int argc, char **argv)
     {
       datasection_only = false;
       SET_BINARY (fileno (stdin));
-      print_strings ("{standard input}", stdin, 0, 0, 0, (char *) NULL);
+      print_strings ("{standard input}", stdin, 0, 0, (char *) NULL);
       files_given = true;
     }
   else
     {
       for (; optind < argc; ++optind)
 	{
-	  if (strcmp (argv[optind], "-") == 0)
+	  if (streq (argv[optind], "-"))
 	    datasection_only = false;
 	  else
 	    {
@@ -342,7 +392,7 @@ strings_a_section (bfd *abfd, asection *
     }
 
   *got_a_section = true;
-  print_strings (filename, NULL, sect->filepos, 0, sectsize, (char *) mem);
+  print_strings (filename, NULL, sect->filepos, sectsize, (char *) mem);
   free (mem);
 }
 
@@ -427,7 +477,7 @@ strings_file (char *file)
 	  return false;
 	}
 
-      print_strings (file, stream, (file_ptr) 0, 0, 0, (char *) 0);
+      print_strings (file, stream, (file_ptr) 0, 0, (char *) NULL);
 
       if (fclose (stream) == EOF)
 	{
@@ -551,11 +601,627 @@ unget_part_char (long c, file_ptr *addre
 	}
     }
 }
+
+static void
+print_filename_and_address (const char * filename, file_ptr address)
+{
+  if (print_filenames)
+    printf ("%s: ", filename);
+
+  if (! print_addresses)
+    return;
+
+  switch (address_radix)
+    {
+    case 8:
+      if (sizeof (address) > sizeof (long))
+	{
+#ifndef __MSVCRT__
+	  printf ("%7llo ", (unsigned long long) address);
+#else
+	  printf ("%7I64o ", (unsigned long long) address);
+#endif
+	}
+      else
+	printf ("%7lo ", (unsigned long) address);
+      break;
+
+    case 10:
+      if (sizeof (address) > sizeof (long))
+	{
+#ifndef __MSVCRT__
+	  printf ("%7llu ", (unsigned long long) address);
+#else
+	  printf ("%7I64d ", (unsigned long long) address);
+#endif
+	}
+      else
+	printf ("%7ld ", (long) address);
+      break;
+
+    case 16:
+      if (sizeof (address) > sizeof (long))
+	{
+#ifndef __MSVCRT__
+	  printf ("%7llx ", (unsigned long long) address);
+#else
+	  printf ("%7I64x ", (unsigned long long) address);
+#endif
+	}
+      else
+	printf ("%7lx ", (unsigned long) address);
+      break;
+    }
+}
+
+/* Return non-zero if the bytes starting at BUFFER form a valid UTF-8 encoding.
+   If the encoding is valid then returns the number of bytes it uses.  */
+
+static unsigned int
+is_valid_utf8 (const unsigned char * buffer, unsigned long buflen)
+{
+  if (buffer[0] < 0xc0)
+    return 0;
+
+  if (buflen < 2)
+    return 0;
+
+  if ((buffer[1] & 0xc0) != 0x80)
+    return 0;
+
+  if ((buffer[0] & 0x20) == 0)
+    return 2;
+
+  if (buflen < 3)
+    return 0;
+
+  if ((buffer[2] & 0xc0) != 0x80)
+    return 0;
+  
+  if ((buffer[0] & 0x10) == 0)
+    return 3;
+
+  if (buflen < 4)
+    return 0;
+
+  if ((buffer[3] & 0xc0) != 0x80)
+    return 0;
+
+  return 4;
+}
+
+/* Display a UTF-8 encoded character in BUFFER according to the setting
+   of unicode_display.  The character is known to be valid.
+   Returns the number of bytes consumed.  */
+
+static uint
+display_utf8_char (const unsigned char * buffer)
+{
+  uint j;
+  uint utf8_len;
+
+  switch (buffer[0] & 0x30)
+    {
+    case 0x00:
+    case 0x10:
+      utf8_len = 2;
+      break;
+    case 0x20:
+      utf8_len = 3;
+      break;
+    default:
+      utf8_len = 4;
+    }
+      
+  switch (unicode_display)
+    {
+    default:
+      fprintf (stderr, "ICE: unexpected unicode display type\n");
+      break;
+
+    case unicode_escape:
+    case unicode_highlight:
+      if (unicode_display == unicode_highlight && isatty (1))
+	printf ("\x1B[31;47m"); /* Red.  */
+
+      switch (utf8_len)
+	{
+	case 2:
+	  printf ("\\u%02x%02x",
+		  ((buffer[0] & 0x1c) >> 2), 
+		  ((buffer[0] & 0x03) << 6) | (buffer[1] & 0x3f));
+	  break;
+
+	case 3:
+	  printf ("\\u%02x%02x",
+		  ((buffer[0] & 0x0f) << 4) | ((buffer[1] & 0x3c) >> 2),
+		  ((buffer[1] & 0x03) << 6) | ((buffer[2] & 0x3f)));
+	  break;
+
+	case 4:
+	  printf ("\\u%02x%02x%02x",
+		  ((buffer[0] & 0x07) << 6) | ((buffer[1] & 0x3c) >> 2),
+		  ((buffer[1] & 0x03) << 6) | ((buffer[2] & 0x3c) >> 2),
+		  ((buffer[2] & 0x03) << 6) | ((buffer[3] & 0x3f)));
+	  break;
+	default:
+	  /* URG.  */
+	  break;
+	}
+
+      if (unicode_display == unicode_highlight && isatty (1))
+	printf ("\033[0m"); /* Default colour.  */
+      break;
+
+    case unicode_hex:
+      putchar ('<');
+      printf ("0x");
+      for (j = 0; j < utf8_len; j++)
+	printf ("%02x", buffer [j]);
+      putchar ('>');
+      break;
+
+    case unicode_locale:
+      printf ("%.1s", buffer);
+      break;
+    }
+
+  return utf8_len;
+}
+
+/* Display strings in BUFFER.  Treat any UTF-8 encoded characters encountered
+   according to the setting of the unicode_display variable.  The buffer
+   contains BUFLEN bytes.
+
+   Display the characters as if they started at ADDRESS and are contained in
+   FILENAME.  */
+
+static void
+print_unicode_buffer (const char *            filename,
+		      file_ptr                address,
+		      const unsigned char *   buffer,
+		      unsigned long           buflen)
+{
+  /* Paranoia checks...  */
+  if (filename == NULL
+      || buffer == NULL
+      || unicode_display == unicode_default
+      || encoding != 'S'
+      || encoding_bytes != 1)
+    {
+      fprintf (stderr, "ICE: bad arguments to print_unicode_buffer\n");
+      return;
+    }
+
+  if (buflen == 0)
+    return;
+
+  /* We must only display strings that are at least string_min *characters*
+     long.  So we scan the buffer in two stages.  First we locate the start
+     of a potential string.  Then we walk along it until we have found
+     string_min characters.  Then we go back to the start point and start
+     displaying characters according to the unicode_display setting.  */
+
+  unsigned long start_point = 0;
+  unsigned long i = 0;
+  unsigned int char_len = 1;
+  unsigned int num_found = 0;
+
+  for (i = 0; i < buflen; i += char_len)
+    {
+      int c = buffer[i];
+
+      char_len = 1;
+
+      /* Find the first potential character of a string.  */
+      if (! STRING_ISGRAPHIC (c))
+	{
+	  num_found = 0;
+	  continue;
+	}
+
+      if (c > 126)
+	{
+	  if (c < 0xc0)
+	    {
+	      num_found = 0;
+	      continue;
+	    }
+
+	  if ((char_len = is_valid_utf8 (buffer + i, buflen - i)) == 0)
+	    {
+	      char_len = 1;
+	      num_found = 0;
+	      continue;
+	    }
+
+	  if (unicode_display == unicode_invalid)
+	    {
+	      /* We have found a valid UTF-8 character, but we treat it as non-graphic.  */
+	      num_found = 0;
+	      continue;
+	    }
+	}
+
+      if (num_found == 0)
+	/* We have found a potential starting point for a string.  */
+	start_point = i;
+
+      ++ num_found;
+
+      if (num_found >= string_min)
+	break;
+    }
+
+  if (num_found < string_min)
+    return;
+
+  print_filename_and_address (filename, address + start_point);
+  
+  /* We have found string_min characters.  Display them and any
+     more that follow.  */
+  for (i = start_point; i < buflen; i += char_len)
+    {
+      int c = buffer[i];
+
+      char_len = 1;
+
+      if (! STRING_ISGRAPHIC (c))
+	break;
+      else if (c < 127)
+	putchar (c);
+      else if (! is_valid_utf8 (buffer + i, buflen - i))
+	break;
+      else if (unicode_display == unicode_invalid)
+	break;
+      else
+	char_len = display_utf8_char (buffer + i);
+    }
+
+  if (output_separator)
+    fputs (output_separator, stdout);
+  else
+    putchar ('\n');
+
+  /* FIXME: Using tail recursion here is lazy programming...  */
+  print_unicode_buffer (filename, address + i, buffer + i, buflen - i);
+}
+
+static int
+get_unicode_byte (FILE * stream, unsigned char * putback, uint * num_putback, uint * num_read)
+{
+  if (* num_putback > 0)
+    {
+      * num_putback = * num_putback - 1;
+      return putback [* num_putback];
+    }
+
+  * num_read = * num_read + 1;
+
+#if defined(HAVE_GETC_UNLOCKED) && HAVE_DECL_GETC_UNLOCKED
+  return getc_unlocked (stream);
+#else
+  return getc (stream);
+#endif
+}
+
+/* Helper function for print_unicode_stream.  */
+
+static void
+print_unicode_stream_body (const char *     filename,
+			   file_ptr         address,
+			   FILE *           stream,
+			   unsigned char *  putback_buf,
+			   uint             num_putback,
+			   unsigned char *  print_buf)
+{
+  /* It would be nice if we could just read the stream into a buffer
+     and then process if with print_unicode_buffer.  But the input
+     might be huge or it might time-locked (eg stdin).  So instead
+     we go one byte at a time...  */
+
+  file_ptr start_point = 0;
+  uint num_read = 0;
+  uint num_chars = 0;
+  uint num_print = 0;
+  int c;
+
+  /* Find a series of string_min characters.  Put them into print_buf.  */
+  do
+    {
+      if (num_chars >= string_min)
+	break;
+
+      c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+      if (c == EOF)
+	break;
+
+      if (! STRING_ISGRAPHIC (c))
+	{
+	  num_chars = num_print = 0;
+	  continue;
+	}
+
+      if (num_chars == 0)
+	start_point = num_read - 1;
+
+      if (c < 127)
+	{
+	  print_buf[num_print] = c;
+	  num_chars ++;
+	  num_print ++;
+	  continue;
+	}
+
+      if (c < 0xc0)
+	{
+	  num_chars = num_print = 0;
+	  continue;
+	}
+
+      /* We *might* have a UTF-8 sequence.  Time to start peeking.  */
+      char utf8[4];
+
+      utf8[0] = c;
+      c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+      if (c == EOF)
+	break;
+      utf8[1] = c;
+
+      if ((utf8[1] & 0xc0) != 0x80)
+	{
+	  /* Invalid UTF-8.  */
+	  putback_buf[num_putback++] = utf8[1];
+	  num_chars = num_print = 0;
+	  continue;
+	}
+      else if ((utf8[0] & 0x20) == 0)
+	{
+	  /* A valid 2-byte UTF-8 encoding.  */
+	  if (unicode_display == unicode_invalid)
+	    {
+	      putback_buf[num_putback++] = utf8[1];
+	      num_chars = num_print = 0;
+	    }
+	  else
+	    {
+	      print_buf[num_print ++] = utf8[0];
+	      print_buf[num_print ++] = utf8[1];
+	      num_chars ++;
+	    }
+	  continue;
+	}
+
+      c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+      if (c == EOF)
+	break;
+      utf8[2] = c;
+
+      if ((utf8[2] & 0xc0) != 0x80)
+	{
+	  /* Invalid UTF-8.  */
+	  putback_buf[num_putback++] = utf8[2];
+	  putback_buf[num_putback++] = utf8[1];
+	  num_chars = num_print = 0;
+	  continue;
+	}
+      else if ((utf8[0] & 0x10) == 0)
+	{
+	  /* A valid 3-byte UTF-8 encoding.  */
+	  if (unicode_display == unicode_invalid)
+	    {
+	      putback_buf[num_putback++] = utf8[2];
+	      putback_buf[num_putback++] = utf8[1];
+	      num_chars = num_print = 0;
+	    }
+	  else
+	    {
+	      print_buf[num_print ++] = utf8[0];
+	      print_buf[num_print ++] = utf8[1];
+	      print_buf[num_print ++] = utf8[2];
+	      num_chars ++;
+	    }
+	  continue;
+	}
+
+      c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+      if (c == EOF)
+	break;
+      utf8[3] = c;
+
+      if ((utf8[3] & 0xc0) != 0x80)
+	{
+	  /* Invalid UTF-8.  */
+	  putback_buf[num_putback++] = utf8[3];
+	  putback_buf[num_putback++] = utf8[2];
+	  putback_buf[num_putback++] = utf8[1];
+	  num_chars = num_print = 0;
+	}
+      /* We have a valid 4-byte UTF-8 encoding.  */
+      else if (unicode_display == unicode_invalid)
+	{
+	  putback_buf[num_putback++] = utf8[3];
+	  putback_buf[num_putback++] = utf8[1];
+	  putback_buf[num_putback++] = utf8[2];
+	  num_chars = num_print = 0;
+	}
+      else
+	{
+	  print_buf[num_print ++] = utf8[0];
+	  print_buf[num_print ++] = utf8[1];
+	  print_buf[num_print ++] = utf8[2];
+	  print_buf[num_print ++] = utf8[3];
+	  num_chars ++;
+	}
+    }
+  while (1);
+
+  if (num_chars >= string_min)
+    {
+      /* We know that we have string_min valid characters in print_buf,
+	 and there may be more to come in the stream.  Start displaying
+	 them.  */
+
+      print_filename_and_address (filename, address + start_point);
+
+      uint i;
+      for (i = 0; i < num_print;)
+	{
+	  if (print_buf[i] < 127)
+	    putchar (print_buf[i++]);
+	  else
+	    i += display_utf8_char (print_buf + i);
+	}
+
+      /* OK so now we have to start read unchecked bytes.  */
+
+        /* Find a series of string_min characters.  Put them into print_buf.  */
+      do
+	{
+	  c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+	  if (c == EOF)
+	    break;
+
+	  if (! STRING_ISGRAPHIC (c))
+	    break;
+
+	  if (c < 127)
+	    {
+	      putchar (c);
+	      continue;
+	    }
+
+	  if (c < 0xc0)
+	    break;
+
+	  /* We *might* have a UTF-8 sequence.  Time to start peeking.  */
+	  unsigned char utf8[4];
+
+	  utf8[0] = c;
+	  c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+	  if (c == EOF)
+	    break;
+	  utf8[1] = c;
+
+	  if ((utf8[1] & 0xc0) != 0x80)
+	    {
+	      /* Invalid UTF-8.  */
+	      putback_buf[num_putback++] = utf8[1];
+	      break;
+	    }
+	  else if ((utf8[0] & 0x20) == 0)
+	    {
+	      /* Valid 2-byte UTF-8.  */
+	      if (unicode_display == unicode_invalid)
+		{
+		  putback_buf[num_putback++] = utf8[1];
+		  break;
+		}
+	      else
+		{
+		  (void) display_utf8_char (utf8);
+		  continue;
+		}
+	    }
+
+	  c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+	  if (c == EOF)
+	    break;
+	  utf8[2] = c;
+
+	  if ((utf8[2] & 0xc0) != 0x80)
+	    {
+	      /* Invalid UTF-8.  */
+	      putback_buf[num_putback++] = utf8[2];
+	      putback_buf[num_putback++] = utf8[1];
+	      break;
+	    }
+	  else if ((utf8[0] & 0x10) == 0)
+	    {
+	      /* Valid 3-byte UTF-8.  */
+	      if (unicode_display == unicode_invalid)
+		{
+		  putback_buf[num_putback++] = utf8[2];
+		  putback_buf[num_putback++] = utf8[1];
+		  break;
+		}
+	      else
+		{
+		  (void) display_utf8_char (utf8);
+		  continue;
+		}
+	    }
+
+	  c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+	  if (c == EOF)
+	    break;
+	  utf8[3] = c;
+
+	  if ((utf8[3] & 0xc0) != 0x80)
+	    {
+	      /* Invalid UTF-8.  */
+	      putback_buf[num_putback++] = utf8[3];
+	      putback_buf[num_putback++] = utf8[2];
+	      putback_buf[num_putback++] = utf8[1];
+	      break;
+	    }
+	  else if (unicode_display == unicode_invalid)
+	    {
+	      putback_buf[num_putback++] = utf8[3];
+	      putback_buf[num_putback++] = utf8[2];
+	      putback_buf[num_putback++] = utf8[1];
+	      break;
+	    }
+	  else
+	    /* A valid 4-byte UTF-8 encoding.  */
+	    (void) display_utf8_char (utf8);
+	}
+      while (1);
+
+      if (output_separator)
+	fputs (output_separator, stdout);
+      else
+	putchar ('\n');
+    }
+
+  if (c != EOF)
+    /* FIXME: Using tail recursion here is lazy, but it works.  */
+    print_unicode_stream_body (filename, address + num_read, stream, putback_buf, num_putback, print_buf);
+}
+
+/* Display strings read in from STREAM.  Treat any UTF-8 encoded characters
+   encountered according to the setting of the unicode_display variable.
+   The stream is positioned at ADDRESS and is attached to FILENAME.  */
+
+static void
+print_unicode_stream (const char * filename,
+		      file_ptr     address,
+		      FILE *       stream)
+{
+  /* Paranoia checks...  */
+  if (filename == NULL
+      || stream == NULL
+      || unicode_display == unicode_default
+      || encoding != 'S'
+      || encoding_bytes != 1)
+    {
+      fprintf (stderr, "ICE: bad arguments to print_unicode_stream\n");
+      return;
+    }
+
+  /* Allocate space for string_min 4-byte utf-8 characters.  */
+  unsigned char * print_buf = xmalloc ((4 * string_min) + 1);
+  /* We should never have to put back more than 4 bytes.  */
+  unsigned char putback_buf[5];
+  uint num_putback = 0;
+
+  print_unicode_stream_body (filename, address, stream, putback_buf, num_putback, print_buf);
+  free (print_buf);
+}
 
 /* Find the strings in file FILENAME, read from STREAM.
    Assume that STREAM is positioned so that the next byte read
    is at address ADDRESS in the file.
-   Stop reading at address STOP_POINT in the file, if nonzero.
 
    If STREAM is NULL, do not read from it.
    The caller can supply a buffer of characters
@@ -566,20 +1232,29 @@ unget_part_char (long c, file_ptr *addre
 
 static void
 print_strings (const char *filename, FILE *stream, file_ptr address,
-	       int stop_point, int magiccount, char *magic)
+	       int magiccount, char *magic)
 {
+  if (unicode_display != unicode_default)
+    {
+      if (magic != NULL)
+	print_unicode_buffer (filename, address,
+			      (const unsigned char *) magic, magiccount);
+
+      if (stream != NULL)
+	print_unicode_stream (filename, address, stream);
+      return;
+    }
+
   char *buf = (char *) xmalloc (sizeof (char) * (string_min + 1));
 
   while (1)
     {
       file_ptr start;
-      int i;
+      uint i;
       long c;
 
       /* See if the next `string_min' chars are all graphic chars.  */
     tryline:
-      if (stop_point && address >= stop_point)
-	break;
       start = address;
       for (i = 0; i < string_min; i++)
 	{
@@ -601,51 +1276,7 @@ print_strings (const char *filename, FIL
 
       /* We found a run of `string_min' graphic characters.  Print up
 	 to the next non-graphic character.  */
-
-      if (print_filenames)
-	printf ("%s: ", filename);
-      if (print_addresses)
-	switch (address_radix)
-	  {
-	  case 8:
-	    if (sizeof (start) > sizeof (long))
-	      {
-#ifndef __MSVCRT__
-		printf ("%7llo ", (unsigned long long) start);
-#else
-		printf ("%7I64o ", (unsigned long long) start);
-#endif
-	      }
-	    else
-	      printf ("%7lo ", (unsigned long) start);
-	    break;
-
-	  case 10:
-	    if (sizeof (start) > sizeof (long))
-	      {
-#ifndef __MSVCRT__
-		printf ("%7llu ", (unsigned long long) start);
-#else
-		printf ("%7I64d ", (unsigned long long) start);
-#endif
-	      }
-	    else
-	      printf ("%7ld ", (long) start);
-	    break;
-
-	  case 16:
-	    if (sizeof (start) > sizeof (long))
-	      {
-#ifndef __MSVCRT__
-		printf ("%7llx ", (unsigned long long) start);
-#else
-		printf ("%7I64x ", (unsigned long long) start);
-#endif
-	      }
-	    else
-	      printf ("%7lx ", (unsigned long) start);
-	    break;
-	  }
+      print_filename_and_address (filename, start);
 
       buf[i] = '\0';
       fputs (buf, stdout);
@@ -697,6 +1328,8 @@ usage (FILE *stream, int status)
   -T --target=<BFDNAME>     Specify the binary file format\n\
   -e --encoding={s,S,b,l,B,L} Select character size and endianness:\n\
                             s = 7-bit, S = 8-bit, {b,l} = 16-bit, {B,L} = 32-bit\n\
+  --unicode={default|show|invalid|hex|escape|highlight}\n\
+  -u {d|s|i|x|e|h}          Specify how to treat UTF-8 encoded unicode characters\n\
   -s --output-separator=<string> String used to separate strings in output.\n\
   @<file>                   Read options from <file>\n\
   -h --help                 Display this information\n\
diff -rupN binutils.orig/binutils/testsuite/binutils-all/nm.hex.unicode binutils-2.37/binutils/testsuite/binutils-all/nm.hex.unicode
--- binutils.orig/binutils/testsuite/binutils-all/nm.hex.unicode	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.37/binutils/testsuite/binutils-all/nm.hex.unicode	2021-11-09 12:36:58.045780720 +0000
@@ -0,0 +1,3 @@
+#...
+.*he<0xe280ae>oll<0xe280ac>
+#pass
diff -rupN binutils.orig/binutils/testsuite/binutils-all/objdump.highlight.unicode binutils-2.37/binutils/testsuite/binutils-all/objdump.highlight.unicode
--- binutils.orig/binutils/testsuite/binutils-all/objdump.highlight.unicode	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.37/binutils/testsuite/binutils-all/objdump.highlight.unicode	2021-11-09 12:37:28.046580043 +0000
@@ -0,0 +1,3 @@
+#...
+.*he\\u202eoll\\u202c
+#pass
diff -rupN binutils.orig/binutils/testsuite/binutils-all/readelf.invalid.unicode binutils-2.37/binutils/testsuite/binutils-all/readelf.invalid.unicode
--- binutils.orig/binutils/testsuite/binutils-all/readelf.invalid.unicode	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.37/binutils/testsuite/binutils-all/readelf.invalid.unicode	2021-11-09 12:37:15.069666851 +0000
@@ -0,0 +1,3 @@
+#...
+.*he\{0xe280ae\}oll\{0xe280ac\}
+#pass
diff -rupN binutils.orig/binutils/testsuite/binutils-all/strings.escape.unicode binutils-2.37/binutils/testsuite/binutils-all/strings.escape.unicode
--- binutils.orig/binutils/testsuite/binutils-all/strings.escape.unicode	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.37/binutils/testsuite/binutils-all/strings.escape.unicode	2021-11-09 12:36:46.692856666 +0000
@@ -0,0 +1,3 @@
+#...
+he\\u202eoll\\u202c
+#pass
diff -rupN binutils.orig/binutils/testsuite/binutils-all/trick-hello.s binutils-2.37/binutils/testsuite/binutils-all/trick-hello.s
--- binutils.orig/binutils/testsuite/binutils-all/trick-hello.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.37/binutils/testsuite/binutils-all/trick-hello.s	2021-11-09 12:35:31.566351425 +0000
@@ -0,0 +1,33 @@
+	.file	"trick-hello.c"
+	.text
+	.section	.rodata
+.LC0:
+	.string	"hah, gotcha!"
+	.text
+	.globl	he‮oll‬
+	.type	he‮oll‬, %function
+he‮oll‬:
+.LFB0:
+	nop
+.LFE0:
+	.size	he‮oll‬, .-he‮oll‬
+	.section	.rodata
+.LC1:
+	.string	"Hello world"
+	.text
+	.globl	hello
+	.type	hello, %function
+hello:
+.LFB1:
+	nop
+.LFE1:
+	.size	hello, .-hello
+	.globl	main
+	.type	main, %function
+main:
+.LFB2:
+	nop
+.LFE2:
+	.size	main, .-main
+	.ident	"GCC: (GNU) 11.2.1 20210728 (Red Hat 11.2.1-1)"
+
diff -rupN binutils.orig/binutils/testsuite/binutils-all/unicode.exp binutils-2.37/binutils/testsuite/binutils-all/unicode.exp
--- binutils.orig/binutils/testsuite/binutils-all/unicode.exp	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.37/binutils/testsuite/binutils-all/unicode.exp	2021-11-09 12:35:23.631402678 +0000
@@ -0,0 +1,71 @@
+#   Copyright (C) 2021 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+# Written by Nick Clifton <nickc@redhat.com>
+
+proc unicode_test { program options binary_file regexp_file } {
+
+    global srcdir
+    global subdir
+
+    set testname "unicode $program $options [file rootname [file tail $binary_file]]"
+
+    send_log "exec $program $options $binary_file > prog.out\n"
+    set got [remote_exec host "$program $options $binary_file" "" "/dev/null" "prog.out"]
+
+    if { [lindex $got 0] != 0 } then {
+	fail "$testname (reason: execution failed)"
+	send_log $got
+	send_log "\n"
+	return
+    }
+
+    if { ![string match "" [lindex $got 1]] } then {
+	fail "$testname (reason: error output)"
+	send_log $got
+	send_log "\n"
+	return
+    }
+
+    if { [regexp_diff prog.out $srcdir/$subdir/$regexp_file] } then {
+	send_log [file_contents prog.out]
+	send_log "\n"
+	fail $testname
+	return
+    }
+
+    pass $testname
+}
+
+# Assemble the test file.
+if {![binutils_assemble $srcdir/$subdir/trick-hello.s tmpdir/trick-hello.o]} then {
+    unsupported "unicode tests (failed to assemble test file)"
+} else {
+    if ![is_remote host] {
+	set tempfile tmpdir/trick-hello.o
+    } else {
+	set tempfile [remote_download host tmpdir/trick-hello.o]
+    }
+
+    global NM STRINGS OBJDUMP READELF
+    unicode_test $NM      {--unicode=hex}    $tempfile nm.hex.unicode
+    unicode_test $STRINGS {--unicode=escape} $tempfile strings.escape.unicode
+    unicode_test $OBJDUMP {-tUh}             $tempfile objdump.highlight.unicode
+
+    if [is_elf_format] {
+	unicode_test $READELF {-sUi}         $tempfile readelf.invalid.unicode
+    }
+}
