diff -cpr ../binutils-2.24.orig/binutils/ar.c ./binutils/ar.c
*** ../binutils-2.24.orig/binutils/ar.c	2014-11-13 11:08:46.808741776 +0000
--- ./binutils/ar.c	2014-11-13 11:10:10.510151199 +0000
*************** extract_file (bfd *abfd)
*** 1031,1036 ****
--- 1031,1045 ----
    bfd_size_type size;
    struct stat buf;
  
+   /* PR binutils/17533: Do not allow directory traversal
+      outside of the current directory tree.  */
+   if (! is_valid_archive_path (bfd_get_filename (abfd)))
+     {
+       non_fatal (_("illegal pathname found in archive member: %s"),
+ 		 bfd_get_filename (abfd));
+       return;
+     }
+ 
    if (bfd_stat_arch_elt (abfd, &buf) != 0)
      /* xgettext:c-format */
      fatal (_("internal stat error on %s"), bfd_get_filename (abfd));
diff -cpr ../binutils-2.24.orig/binutils/bucomm.c ./binutils/bucomm.c
*** ../binutils-2.24.orig/binutils/bucomm.c	2014-11-13 11:08:46.791741693 +0000
--- ./binutils/bucomm.c	2014-11-13 11:10:10.511151188 +0000
*************** bfd_get_archive_filename (const bfd *abf
*** 624,626 ****
--- 624,652 ----
  	   bfd_get_filename (abfd));
    return buf;
  }
+ 
+ /* Returns TRUE iff PATHNAME, a filename of an archive member,
+    is valid for writing.  For security reasons absolute paths
+    and paths containing /../ are not allowed.  See PR 17533.  */
+ 
+ bfd_boolean
+ is_valid_archive_path (char const * pathname)
+ {
+   const char * n = pathname;
+ 
+   if (IS_ABSOLUTE_PATH (n))
+     return FALSE;
+ 
+   while (*n)
+     {
+       if (*n == '.' && *++n == '.' && ( ! *++n || IS_DIR_SEPARATOR (*n)))
+ 	return FALSE;
+ 
+       while (*n && ! IS_DIR_SEPARATOR (*n))
+ 	n++;
+       while (IS_DIR_SEPARATOR (*n))
+ 	n++;
+     }
+ 
+   return TRUE;
+ }
diff -cpr ../binutils-2.24.orig/binutils/bucomm.h ./binutils/bucomm.h
*** ../binutils-2.24.orig/binutils/bucomm.h	2014-11-13 11:08:46.798741727 +0000
--- ./binutils/bucomm.h	2014-11-13 11:10:10.511151188 +0000
*************** bfd_vma parse_vma (const char *, const c
*** 58,63 ****
--- 58,65 ----
  
  off_t get_file_size (const char *);
  
+ bfd_boolean is_valid_archive_path (char const *);
+ 
  extern char *program_name;
  
  /* filemode.c */
diff -cpr ../binutils-2.24.orig/binutils/objcopy.c ./binutils/objcopy.c
*** ../binutils-2.24.orig/binutils/objcopy.c	2014-11-13 11:08:46.798741727 +0000
--- ./binutils/objcopy.c	2014-11-13 11:10:10.514151156 +0000
*************** copy_archive (bfd *ibfd, bfd *obfd, cons
*** 2182,2187 ****
--- 2182,2197 ----
        bfd_boolean del = TRUE;
        bfd_boolean ok_object;
  
+       /* PR binutils/17533: Do not allow directory traversal
+ 	 outside of the current directory tree by archive members.  */
+       if (! is_valid_archive_path (bfd_get_filename (this_element)))
+ 	{
+ 	  non_fatal (_("illegal pathname found in archive member: %s"),
+ 		     bfd_get_filename (this_element));
+ 	  status = 1;
+ 	  goto cleanup_and_exit;
+ 	}
+ 
        /* Create an output file for this member.  */
        output_name = concat (dir, "/",
  			    bfd_get_filename (this_element), (char *) 0);
*************** copy_archive (bfd *ibfd, bfd *obfd, cons
*** 2191,2198 ****
  	{
  	  output_name = make_tempdir (output_name);
  	  if (output_name == NULL)
! 	    fatal (_("cannot create tempdir for archive copying (error: %s)"),
! 		   strerror (errno));
  
  	  l = (struct name_list *) xmalloc (sizeof (struct name_list));
  	  l->name = output_name;
--- 2201,2212 ----
  	{
  	  output_name = make_tempdir (output_name);
  	  if (output_name == NULL)
! 	    {
! 	      non_fatal (_("cannot create tempdir for archive copying (error: %s)"),
! 			 strerror (errno));
! 	      status = 1;
! 	      goto cleanup_and_exit;
! 	    }
  
  	  l = (struct name_list *) xmalloc (sizeof (struct name_list));
  	  l->name = output_name;
*************** copy_archive (bfd *ibfd, bfd *obfd, cons
*** 2234,2240 ****
  	{
  	  bfd_nonfatal_message (output_name, NULL, NULL, NULL);
  	  status = 1;
! 	  return;
  	}
  
        if (ok_object)
--- 2248,2254 ----
  	{
  	  bfd_nonfatal_message (output_name, NULL, NULL, NULL);
  	  status = 1;
! 	  goto cleanup_and_exit;
  	}
  
        if (ok_object)
*************** copy_archive (bfd *ibfd, bfd *obfd, cons
*** 2295,2301 ****
      {
        status = 1;
        bfd_nonfatal_message (filename, NULL, NULL, NULL);
-       return;
      }
  
    filename = bfd_get_filename (ibfd);
--- 2309,2314 ----
*************** copy_archive (bfd *ibfd, bfd *obfd, cons
*** 2303,2311 ****
      {
        status = 1;
        bfd_nonfatal_message (filename, NULL, NULL, NULL);
-       return;
      }
  
    /* Delete all the files that we opened.  */
    for (l = list; l != NULL; l = l->next)
      {
--- 2316,2324 ----
      {
        status = 1;
        bfd_nonfatal_message (filename, NULL, NULL, NULL);
      }
  
+  cleanup_and_exit:
    /* Delete all the files that we opened.  */
    for (l = list; l != NULL; l = l->next)
      {
*** ../binutils-2.23.2.orig/bfd/archive.c	2014-11-19 15:01:01.626689450 +0000
--- bfd/archive.c	2014-11-19 15:06:45.700301515 +0000
*************** _bfd_slurp_extended_name_table (bfd *abf
*** 1281,1286 ****
--- 1281,1288 ----
  	{
  	byebye:
  	  bfd_release (abfd, namedata);
+ 	  bfd_ardata (abfd)->extended_names = NULL;
+ 	  bfd_ardata (abfd)->extended_names_size = 0;
  	  return FALSE;
  	}
  
*** ../binutils-2.23.2.orig/binutils/doc/binutils.texi	2014-11-19 15:01:01.711689848 +0000
--- binutils/doc/binutils.texi	2014-11-19 15:14:13.036397824 +0000
*************** relocatable objects are expected to rema
*** 227,234 ****
  contents of each object would only waste time and space.  Thin archives
  are also @emph{flattened}, so that adding one or more archives to a
  thin archive will add the elements of the nested archive individually.
  The paths to the elements of the archive are stored relative to the
! archive itself.
  
  @cindex compatibility, @command{ar}
  @cindex @command{ar} compatibility
--- 227,236 ----
  contents of each object would only waste time and space.  Thin archives
  are also @emph{flattened}, so that adding one or more archives to a
  thin archive will add the elements of the nested archive individually.
+ 
  The paths to the elements of the archive are stored relative to the
! archive itself.  For security reasons absolute paths and paths with a
! ! @code{/../} component are not allowed.
  
  @cindex compatibility, @command{ar}
  @cindex @command{ar} compatibility
*************** machine types.
*** 4421,4441 ****
  The supported ELF machine types are, @var{L1OM}, @var{K1OM} and
  @var{x86-64}.
  
! @itemx --output-mach=@var{machine}
  Change the ELF machine type in the ELF header to @var{machine}.  The
  supported ELF machine types are the same as @option{--input-mach}.
  
! @itemx --input-type=@var{type}
  Set the matching input ELF file type to @var{type}.  If
  @option{--input-type} isn't specified, it will match any ELF file types.
  
  The supported ELF file types are, @var{rel}, @var{exec} and @var{dyn}.
  
! @itemx --output-type=@var{type}
  Change the ELF file type in the ELF header to @var{type}.  The
  supported ELF types are the same as @option{--input-type}.
  
! @itemx --input-osabi=@var{osabi}
  Set the matching input ELF file OSABI to @var{osabi}.  If
  @option{--input-osabi} isn't specified, it will match any ELF OSABIs.
  
--- 4423,4443 ----
  The supported ELF machine types are, @var{L1OM}, @var{K1OM} and
  @var{x86-64}.
  
! @item --output-mach=@var{machine}
  Change the ELF machine type in the ELF header to @var{machine}.  The
  supported ELF machine types are the same as @option{--input-mach}.
  
! @item --input-type=@var{type}
  Set the matching input ELF file type to @var{type}.  If
  @option{--input-type} isn't specified, it will match any ELF file types.
  
  The supported ELF file types are, @var{rel}, @var{exec} and @var{dyn}.
  
! @item --output-type=@var{type}
  Change the ELF file type in the ELF header to @var{type}.  The
  supported ELF types are the same as @option{--input-type}.
  
! @item --input-osabi=@var{osabi}
  Set the matching input ELF file OSABI to @var{osabi}.  If
  @option{--input-osabi} isn't specified, it will match any ELF OSABIs.
  
*************** The supported ELF OSABIs are, @var{none}
*** 4445,4451 ****
  @var{FreeBSD}, @var{TRU64}, @var{Modesto}, @var{OpenBSD}, @var{OpenVMS},
  @var{NSK}, @var{AROS} and @var{FenixOS}.
  
! @itemx --output-osabi=@var{osabi}
  Change the ELF OSABI in the ELF header to @var{osabi}.  The
  supported ELF OSABI are the same as @option{--input-osabi}.
  
--- 4447,4453 ----
  @var{FreeBSD}, @var{TRU64}, @var{Modesto}, @var{OpenBSD}, @var{OpenVMS},
  @var{NSK}, @var{AROS} and @var{FenixOS}.
  
! @item --output-osabi=@var{osabi}
  Change the ELF OSABI in the ELF header to @var{osabi}.  The
  supported ELF OSABI are the same as @option{--input-osabi}.
  
