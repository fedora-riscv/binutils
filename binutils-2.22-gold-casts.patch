diff -cp ../binutils-2.22.orig/gold/dwarf_reader.cc gold/dwarf_reader.cc
*** ../binutils-2.22.orig/gold/dwarf_reader.cc	2012-01-13 12:20:00.279690374 +0000
--- gold/dwarf_reader.cc	2012-01-13 12:31:15.659709094 +0000
*************** Sized_dwarf_line_info<size, big_endian>:
*** 491,498 ****
                && (shndx == -1U || lsm.shndx == -1U || shndx == lsm.shndx))
              {
                Offset_to_lineno_entry entry
!                   = { lsm.address, this->current_header_index_,
!                       lsm.file_num, true, lsm.line_num };
  	      std::vector<Offset_to_lineno_entry>&
  		map(this->line_number_map_[lsm.shndx]);
  	      // If we see two consecutive entries with the same
--- 491,498 ----
                && (shndx == -1U || lsm.shndx == -1U || shndx == lsm.shndx))
              {
                Offset_to_lineno_entry entry
! 		= { (off_t) lsm.address, this->current_header_index_,
!                     (unsigned int) lsm.file_num, true, lsm.line_num };
  	      std::vector<Offset_to_lineno_entry>&
  		map(this->line_number_map_[lsm.shndx]);
  	      // If we see two consecutive entries with the same
diff -cp ../binutils-2.22.orig/gold/i386.cc gold/i386.cc
*** ../binutils-2.22.orig/gold/i386.cc	2012-01-13 12:20:00.355690373 +0000
--- gold/i386.cc	2012-01-13 12:31:15.662709094 +0000
*************** Target_i386::do_code_fill(section_size_t
*** 3480,3529 ****
      }
  
    // Nop sequences of various lengths.
!   const char nop1[1] = { 0x90 };                   // nop
!   const char nop2[2] = { 0x66, 0x90 };             // xchg %ax %ax
!   const char nop3[3] = { 0x8d, 0x76, 0x00 };       // leal 0(%esi),%esi
!   const char nop4[4] = { 0x8d, 0x74, 0x26, 0x00};  // leal 0(%esi,1),%esi
!   const char nop5[5] = { 0x90, 0x8d, 0x74, 0x26,   // nop
                           0x00 };                   // leal 0(%esi,1),%esi
!   const char nop6[6] = { 0x8d, 0xb6, 0x00, 0x00,   // leal 0L(%esi),%esi
                           0x00, 0x00 };
!   const char nop7[7] = { 0x8d, 0xb4, 0x26, 0x00,   // leal 0L(%esi,1),%esi
                           0x00, 0x00, 0x00 };
!   const char nop8[8] = { 0x90, 0x8d, 0xb4, 0x26,   // nop
                           0x00, 0x00, 0x00, 0x00 }; // leal 0L(%esi,1),%esi
!   const char nop9[9] = { 0x89, 0xf6, 0x8d, 0xbc,   // movl %esi,%esi
                           0x27, 0x00, 0x00, 0x00,   // leal 0L(%edi,1),%edi
                           0x00 };
!   const char nop10[10] = { 0x8d, 0x76, 0x00, 0x8d, // leal 0(%esi),%esi
                             0xbc, 0x27, 0x00, 0x00, // leal 0L(%edi,1),%edi
                             0x00, 0x00 };
!   const char nop11[11] = { 0x8d, 0x74, 0x26, 0x00, // leal 0(%esi,1),%esi
                             0x8d, 0xbc, 0x27, 0x00, // leal 0L(%edi,1),%edi
                             0x00, 0x00, 0x00 };
!   const char nop12[12] = { 0x8d, 0xb6, 0x00, 0x00, // leal 0L(%esi),%esi
                             0x00, 0x00, 0x8d, 0xbf, // leal 0L(%edi),%edi
                             0x00, 0x00, 0x00, 0x00 };
!   const char nop13[13] = { 0x8d, 0xb6, 0x00, 0x00, // leal 0L(%esi),%esi
                             0x00, 0x00, 0x8d, 0xbc, // leal 0L(%edi,1),%edi
                             0x27, 0x00, 0x00, 0x00,
                             0x00 };
!   const char nop14[14] = { 0x8d, 0xb4, 0x26, 0x00, // leal 0L(%esi,1),%esi
                             0x00, 0x00, 0x00, 0x8d, // leal 0L(%edi,1),%edi
                             0xbc, 0x27, 0x00, 0x00,
                             0x00, 0x00 };
!   const char nop15[15] = { 0xeb, 0x0d, 0x90, 0x90, // jmp .+15
                             0x90, 0x90, 0x90, 0x90, // nop,nop,nop,...
                             0x90, 0x90, 0x90, 0x90,
                             0x90, 0x90, 0x90 };
  
!   const char* nops[16] = {
      NULL,
      nop1, nop2, nop3, nop4, nop5, nop6, nop7,
      nop8, nop9, nop10, nop11, nop12, nop13, nop14, nop15
    };
  
!   return std::string(nops[length], length);
  }
  
  // Return the value to use for the base of a DW_EH_PE_datarel offset
--- 3480,3529 ----
      }
  
    // Nop sequences of various lengths.
!   const unsigned char nop1[1] = { 0x90 };                   // nop
!   const unsigned char nop2[2] = { 0x66, 0x90 };             // xchg %ax %ax
!   const unsigned char nop3[3] = { 0x8d, 0x76, 0x00 };       // leal 0(%esi),%esi
!   const unsigned char nop4[4] = { 0x8d, 0x74, 0x26, 0x00};  // leal 0(%esi,1),%esi
!   const unsigned char nop5[5] = { 0x90, 0x8d, 0x74, 0x26,   // nop
                           0x00 };                   // leal 0(%esi,1),%esi
!   const unsigned char nop6[6] = { 0x8d, 0xb6, 0x00, 0x00,   // leal 0L(%esi),%esi
                           0x00, 0x00 };
!   const unsigned char nop7[7] = { 0x8d, 0xb4, 0x26, 0x00,   // leal 0L(%esi,1),%esi
                           0x00, 0x00, 0x00 };
!   const unsigned char nop8[8] = { 0x90, 0x8d, 0xb4, 0x26,   // nop
                           0x00, 0x00, 0x00, 0x00 }; // leal 0L(%esi,1),%esi
!   const unsigned char nop9[9] = { 0x89, 0xf6, 0x8d, 0xbc,   // movl %esi,%esi
                           0x27, 0x00, 0x00, 0x00,   // leal 0L(%edi,1),%edi
                           0x00 };
!   const unsigned char nop10[10] = { 0x8d, 0x76, 0x00, 0x8d, // leal 0(%esi),%esi
                             0xbc, 0x27, 0x00, 0x00, // leal 0L(%edi,1),%edi
                             0x00, 0x00 };
!   const unsigned char nop11[11] = { 0x8d, 0x74, 0x26, 0x00, // leal 0(%esi,1),%esi
                             0x8d, 0xbc, 0x27, 0x00, // leal 0L(%edi,1),%edi
                             0x00, 0x00, 0x00 };
!   const unsigned char nop12[12] = { 0x8d, 0xb6, 0x00, 0x00, // leal 0L(%esi),%esi
                             0x00, 0x00, 0x8d, 0xbf, // leal 0L(%edi),%edi
                             0x00, 0x00, 0x00, 0x00 };
!   const unsigned char nop13[13] = { 0x8d, 0xb6, 0x00, 0x00, // leal 0L(%esi),%esi
                             0x00, 0x00, 0x8d, 0xbc, // leal 0L(%edi,1),%edi
                             0x27, 0x00, 0x00, 0x00,
                             0x00 };
!   const unsigned char nop14[14] = { 0x8d, 0xb4, 0x26, 0x00, // leal 0L(%esi,1),%esi
                             0x00, 0x00, 0x00, 0x8d, // leal 0L(%edi,1),%edi
                             0xbc, 0x27, 0x00, 0x00,
                             0x00, 0x00 };
!   const unsigned char nop15[15] = { 0xeb, 0x0d, 0x90, 0x90, // jmp .+15
                             0x90, 0x90, 0x90, 0x90, // nop,nop,nop,...
                             0x90, 0x90, 0x90, 0x90,
                             0x90, 0x90, 0x90 };
  
!   const unsigned char* nops[16] = {
      NULL,
      nop1, nop2, nop3, nop4, nop5, nop6, nop7,
      nop8, nop9, nop10, nop11, nop12, nop13, nop14, nop15
    };
  
!   return std::string((const char *) nops[length], length);
  }
  
  // Return the value to use for the base of a DW_EH_PE_datarel offset
diff -cp ../binutils-2.22.orig/gold/options.cc gold/options.cc
*** ../binutils-2.22.orig/gold/options.cc	2012-01-13 12:20:00.314690375 +0000
--- gold/options.cc	2012-01-13 13:59:36.972856052 +0000
*************** parse_uint(const char* option_name, cons
*** 198,204 ****
  {
    char* endptr;
    *retval = strtol(arg, &endptr, 0);
!   if (*endptr != '\0' || retval < 0)
      gold_fatal(_("%s: invalid option value (expected an integer): %s"),
                 option_name, arg);
  }
--- 198,204 ----
  {
    char* endptr;
    *retval = strtol(arg, &endptr, 0);
!   if (*endptr != '\0' || *retval < 0)
      gold_fatal(_("%s: invalid option value (expected an integer): %s"),
                 option_name, arg);
  }
diff -cp ../binutils-2.22.orig/gold/resolve.cc gold/resolve.cc
*** ../binutils-2.22.orig/gold/resolve.cc	2012-01-13 12:20:00.288690373 +0000
--- gold/resolve.cc	2012-01-13 12:31:15.663709095 +0000
*************** Symbol_table::resolve(Sized_symbol<size>
*** 336,344 ****
        && to->name()[0] == '_' && to->name()[1] == 'Z')
      {
        Symbol_location fromloc
!           = { object, orig_st_shndx, sym.get_st_value() };
        Symbol_location toloc = { to->object(), to->shndx(&to_is_ordinary),
! 				to->value() };
        this->candidate_odr_violations_[to->name()].insert(fromloc);
        this->candidate_odr_violations_[to->name()].insert(toloc);
      }
--- 336,344 ----
        && to->name()[0] == '_' && to->name()[1] == 'Z')
      {
        Symbol_location fromloc
! 	= { object, orig_st_shndx, (off_t) sym.get_st_value() };
        Symbol_location toloc = { to->object(), to->shndx(&to_is_ordinary),
! 				(off_t) to->value() };
        this->candidate_odr_violations_[to->name()].insert(fromloc);
        this->candidate_odr_violations_[to->name()].insert(toloc);
      }
diff -cp ../binutils-2.22.orig/gold/x86_64.cc gold/x86_64.cc
*** ../binutils-2.22.orig/gold/x86_64.cc	2012-01-13 12:21:24.880692697 +0000
--- gold/x86_64.cc	2012-01-13 12:31:15.666709095 +0000
*************** Target_x86_64::do_code_fill(section_size
*** 3867,3916 ****
      }
  
    // Nop sequences of various lengths.
!   const char nop1[1] = { 0x90 };                   // nop
!   const char nop2[2] = { 0x66, 0x90 };             // xchg %ax %ax
!   const char nop3[3] = { 0x0f, 0x1f, 0x00 };       // nop (%rax)
!   const char nop4[4] = { 0x0f, 0x1f, 0x40, 0x00};  // nop 0(%rax)
!   const char nop5[5] = { 0x0f, 0x1f, 0x44, 0x00,   // nop 0(%rax,%rax,1)
                           0x00 };
!   const char nop6[6] = { 0x66, 0x0f, 0x1f, 0x44,   // nopw 0(%rax,%rax,1)
                           0x00, 0x00 };
!   const char nop7[7] = { 0x0f, 0x1f, 0x80, 0x00,   // nopl 0L(%rax)
                           0x00, 0x00, 0x00 };
!   const char nop8[8] = { 0x0f, 0x1f, 0x84, 0x00,   // nopl 0L(%rax,%rax,1)
                           0x00, 0x00, 0x00, 0x00 };
!   const char nop9[9] = { 0x66, 0x0f, 0x1f, 0x84,   // nopw 0L(%rax,%rax,1)
                           0x00, 0x00, 0x00, 0x00,
                           0x00 };
!   const char nop10[10] = { 0x66, 0x2e, 0x0f, 0x1f, // nopw %cs:0L(%rax,%rax,1)
                             0x84, 0x00, 0x00, 0x00,
                             0x00, 0x00 };
!   const char nop11[11] = { 0x66, 0x66, 0x2e, 0x0f, // data16
                             0x1f, 0x84, 0x00, 0x00, // nopw %cs:0L(%rax,%rax,1)
                             0x00, 0x00, 0x00 };
!   const char nop12[12] = { 0x66, 0x66, 0x66, 0x2e, // data16; data16
                             0x0f, 0x1f, 0x84, 0x00, // nopw %cs:0L(%rax,%rax,1)
                             0x00, 0x00, 0x00, 0x00 };
!   const char nop13[13] = { 0x66, 0x66, 0x66, 0x66, // data16; data16; data16
                             0x2e, 0x0f, 0x1f, 0x84, // nopw %cs:0L(%rax,%rax,1)
                             0x00, 0x00, 0x00, 0x00,
                             0x00 };
!   const char nop14[14] = { 0x66, 0x66, 0x66, 0x66, // data16; data16; data16
                             0x66, 0x2e, 0x0f, 0x1f, // data16
                             0x84, 0x00, 0x00, 0x00, // nopw %cs:0L(%rax,%rax,1)
                             0x00, 0x00 };
!   const char nop15[15] = { 0x66, 0x66, 0x66, 0x66, // data16; data16; data16
                             0x66, 0x66, 0x2e, 0x0f, // data16; data16
                             0x1f, 0x84, 0x00, 0x00, // nopw %cs:0L(%rax,%rax,1)
                             0x00, 0x00, 0x00 };
  
!   const char* nops[16] = {
      NULL,
      nop1, nop2, nop3, nop4, nop5, nop6, nop7,
      nop8, nop9, nop10, nop11, nop12, nop13, nop14, nop15
    };
  
!   return std::string(nops[length], length);
  }
  
  // Return the addend to use for a target specific relocation.  The
--- 3867,3916 ----
      }
  
    // Nop sequences of various lengths.
!   const unsigned char nop1[1] = { 0x90 };                   // nop
!   const unsigned char nop2[2] = { 0x66, 0x90 };             // xchg %ax %ax
!   const unsigned char nop3[3] = { 0x0f, 0x1f, 0x00 };       // nop (%rax)
!   const unsigned char nop4[4] = { 0x0f, 0x1f, 0x40, 0x00};  // nop 0(%rax)
!   const unsigned char nop5[5] = { 0x0f, 0x1f, 0x44, 0x00,   // nop 0(%rax,%rax,1)
                           0x00 };
!   const unsigned char nop6[6] = { 0x66, 0x0f, 0x1f, 0x44,   // nopw 0(%rax,%rax,1)
                           0x00, 0x00 };
!   const unsigned char nop7[7] = { 0x0f, 0x1f, 0x80, 0x00,   // nopl 0L(%rax)
                           0x00, 0x00, 0x00 };
!   const unsigned char nop8[8] = { 0x0f, 0x1f, 0x84, 0x00,   // nopl 0L(%rax,%rax,1)
                           0x00, 0x00, 0x00, 0x00 };
!   const unsigned char nop9[9] = { 0x66, 0x0f, 0x1f, 0x84,   // nopw 0L(%rax,%rax,1)
                           0x00, 0x00, 0x00, 0x00,
                           0x00 };
!   const unsigned char nop10[10] = { 0x66, 0x2e, 0x0f, 0x1f, // nopw %cs:0L(%rax,%rax,1)
                             0x84, 0x00, 0x00, 0x00,
                             0x00, 0x00 };
!   const unsigned char nop11[11] = { 0x66, 0x66, 0x2e, 0x0f, // data16
                             0x1f, 0x84, 0x00, 0x00, // nopw %cs:0L(%rax,%rax,1)
                             0x00, 0x00, 0x00 };
!   const unsigned char nop12[12] = { 0x66, 0x66, 0x66, 0x2e, // data16; data16
                             0x0f, 0x1f, 0x84, 0x00, // nopw %cs:0L(%rax,%rax,1)
                             0x00, 0x00, 0x00, 0x00 };
!   const unsigned char nop13[13] = { 0x66, 0x66, 0x66, 0x66, // data16; data16; data16
                             0x2e, 0x0f, 0x1f, 0x84, // nopw %cs:0L(%rax,%rax,1)
                             0x00, 0x00, 0x00, 0x00,
                             0x00 };
!   const unsigned char nop14[14] = { 0x66, 0x66, 0x66, 0x66, // data16; data16; data16
                             0x66, 0x2e, 0x0f, 0x1f, // data16
                             0x84, 0x00, 0x00, 0x00, // nopw %cs:0L(%rax,%rax,1)
                             0x00, 0x00 };
!   const unsigned char nop15[15] = { 0x66, 0x66, 0x66, 0x66, // data16; data16; data16
                             0x66, 0x66, 0x2e, 0x0f, // data16; data16
                             0x1f, 0x84, 0x00, 0x00, // nopw %cs:0L(%rax,%rax,1)
                             0x00, 0x00, 0x00 };
  
!   const unsigned char* nops[16] = {
      NULL,
      nop1, nop2, nop3, nop4, nop5, nop6, nop7,
      nop8, nop9, nop10, nop11, nop12, nop13, nop14, nop15
    };
  
!   return std::string((const char *) nops[length], length);
  }
  
  // Return the addend to use for a target specific relocation.  The
